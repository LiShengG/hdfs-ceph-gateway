// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NamenodeProtocol.proto

#ifndef PROTOBUF_INCLUDED_NamenodeProtocol_2eproto
#define PROTOBUF_INCLUDED_NamenodeProtocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "hdfs.pb.h"
#include "HdfsServer.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_NamenodeProtocol_2eproto 

namespace protobuf_NamenodeProtocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[28];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_NamenodeProtocol_2eproto
namespace hadoop {
namespace hdfs {
namespace namenode {
class EndCheckpointRequestProto;
class EndCheckpointRequestProtoDefaultTypeInternal;
extern EndCheckpointRequestProtoDefaultTypeInternal _EndCheckpointRequestProto_default_instance_;
class EndCheckpointResponseProto;
class EndCheckpointResponseProtoDefaultTypeInternal;
extern EndCheckpointResponseProtoDefaultTypeInternal _EndCheckpointResponseProto_default_instance_;
class ErrorReportRequestProto;
class ErrorReportRequestProtoDefaultTypeInternal;
extern ErrorReportRequestProtoDefaultTypeInternal _ErrorReportRequestProto_default_instance_;
class ErrorReportResponseProto;
class ErrorReportResponseProtoDefaultTypeInternal;
extern ErrorReportResponseProtoDefaultTypeInternal _ErrorReportResponseProto_default_instance_;
class GetBlockKeysRequestProto;
class GetBlockKeysRequestProtoDefaultTypeInternal;
extern GetBlockKeysRequestProtoDefaultTypeInternal _GetBlockKeysRequestProto_default_instance_;
class GetBlockKeysResponseProto;
class GetBlockKeysResponseProtoDefaultTypeInternal;
extern GetBlockKeysResponseProtoDefaultTypeInternal _GetBlockKeysResponseProto_default_instance_;
class GetBlocksRequestProto;
class GetBlocksRequestProtoDefaultTypeInternal;
extern GetBlocksRequestProtoDefaultTypeInternal _GetBlocksRequestProto_default_instance_;
class GetBlocksResponseProto;
class GetBlocksResponseProtoDefaultTypeInternal;
extern GetBlocksResponseProtoDefaultTypeInternal _GetBlocksResponseProto_default_instance_;
class GetEditLogManifestRequestProto;
class GetEditLogManifestRequestProtoDefaultTypeInternal;
extern GetEditLogManifestRequestProtoDefaultTypeInternal _GetEditLogManifestRequestProto_default_instance_;
class GetEditLogManifestResponseProto;
class GetEditLogManifestResponseProtoDefaultTypeInternal;
extern GetEditLogManifestResponseProtoDefaultTypeInternal _GetEditLogManifestResponseProto_default_instance_;
class GetFilePathRequestProto;
class GetFilePathRequestProtoDefaultTypeInternal;
extern GetFilePathRequestProtoDefaultTypeInternal _GetFilePathRequestProto_default_instance_;
class GetFilePathResponseProto;
class GetFilePathResponseProtoDefaultTypeInternal;
extern GetFilePathResponseProtoDefaultTypeInternal _GetFilePathResponseProto_default_instance_;
class GetMostRecentCheckpointTxIdRequestProto;
class GetMostRecentCheckpointTxIdRequestProtoDefaultTypeInternal;
extern GetMostRecentCheckpointTxIdRequestProtoDefaultTypeInternal _GetMostRecentCheckpointTxIdRequestProto_default_instance_;
class GetMostRecentCheckpointTxIdResponseProto;
class GetMostRecentCheckpointTxIdResponseProtoDefaultTypeInternal;
extern GetMostRecentCheckpointTxIdResponseProtoDefaultTypeInternal _GetMostRecentCheckpointTxIdResponseProto_default_instance_;
class GetNextSPSPathRequestProto;
class GetNextSPSPathRequestProtoDefaultTypeInternal;
extern GetNextSPSPathRequestProtoDefaultTypeInternal _GetNextSPSPathRequestProto_default_instance_;
class GetNextSPSPathResponseProto;
class GetNextSPSPathResponseProtoDefaultTypeInternal;
extern GetNextSPSPathResponseProtoDefaultTypeInternal _GetNextSPSPathResponseProto_default_instance_;
class GetTransactionIdRequestProto;
class GetTransactionIdRequestProtoDefaultTypeInternal;
extern GetTransactionIdRequestProtoDefaultTypeInternal _GetTransactionIdRequestProto_default_instance_;
class GetTransactionIdResponseProto;
class GetTransactionIdResponseProtoDefaultTypeInternal;
extern GetTransactionIdResponseProtoDefaultTypeInternal _GetTransactionIdResponseProto_default_instance_;
class IsRollingUpgradeRequestProto;
class IsRollingUpgradeRequestProtoDefaultTypeInternal;
extern IsRollingUpgradeRequestProtoDefaultTypeInternal _IsRollingUpgradeRequestProto_default_instance_;
class IsRollingUpgradeResponseProto;
class IsRollingUpgradeResponseProtoDefaultTypeInternal;
extern IsRollingUpgradeResponseProtoDefaultTypeInternal _IsRollingUpgradeResponseProto_default_instance_;
class IsUpgradeFinalizedRequestProto;
class IsUpgradeFinalizedRequestProtoDefaultTypeInternal;
extern IsUpgradeFinalizedRequestProtoDefaultTypeInternal _IsUpgradeFinalizedRequestProto_default_instance_;
class IsUpgradeFinalizedResponseProto;
class IsUpgradeFinalizedResponseProtoDefaultTypeInternal;
extern IsUpgradeFinalizedResponseProtoDefaultTypeInternal _IsUpgradeFinalizedResponseProto_default_instance_;
class RegisterRequestProto;
class RegisterRequestProtoDefaultTypeInternal;
extern RegisterRequestProtoDefaultTypeInternal _RegisterRequestProto_default_instance_;
class RegisterResponseProto;
class RegisterResponseProtoDefaultTypeInternal;
extern RegisterResponseProtoDefaultTypeInternal _RegisterResponseProto_default_instance_;
class RollEditLogRequestProto;
class RollEditLogRequestProtoDefaultTypeInternal;
extern RollEditLogRequestProtoDefaultTypeInternal _RollEditLogRequestProto_default_instance_;
class RollEditLogResponseProto;
class RollEditLogResponseProtoDefaultTypeInternal;
extern RollEditLogResponseProtoDefaultTypeInternal _RollEditLogResponseProto_default_instance_;
class StartCheckpointRequestProto;
class StartCheckpointRequestProtoDefaultTypeInternal;
extern StartCheckpointRequestProtoDefaultTypeInternal _StartCheckpointRequestProto_default_instance_;
class StartCheckpointResponseProto;
class StartCheckpointResponseProtoDefaultTypeInternal;
extern StartCheckpointResponseProtoDefaultTypeInternal _StartCheckpointResponseProto_default_instance_;
}  // namespace namenode
}  // namespace hdfs
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::hdfs::namenode::EndCheckpointRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::EndCheckpointRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::EndCheckpointResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::EndCheckpointResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::ErrorReportRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::ErrorReportRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::ErrorReportResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::ErrorReportResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetBlockKeysRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetBlockKeysRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetBlockKeysResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetBlockKeysResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetBlocksRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetBlocksRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetBlocksResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetBlocksResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetEditLogManifestRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetEditLogManifestRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetEditLogManifestResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetEditLogManifestResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetFilePathRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetFilePathRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetFilePathResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetFilePathResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetMostRecentCheckpointTxIdRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetMostRecentCheckpointTxIdRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetMostRecentCheckpointTxIdResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetMostRecentCheckpointTxIdResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetNextSPSPathRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetNextSPSPathRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetNextSPSPathResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetNextSPSPathResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetTransactionIdRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetTransactionIdRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::GetTransactionIdResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::GetTransactionIdResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::IsRollingUpgradeRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::IsRollingUpgradeRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::IsRollingUpgradeResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::IsRollingUpgradeResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::IsUpgradeFinalizedRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::IsUpgradeFinalizedRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::IsUpgradeFinalizedResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::IsUpgradeFinalizedResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::RegisterRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::RegisterRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::RegisterResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::RegisterResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::RollEditLogRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::RollEditLogRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::RollEditLogResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::RollEditLogResponseProto>(Arena*);
template<> ::hadoop::hdfs::namenode::StartCheckpointRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::StartCheckpointRequestProto>(Arena*);
template<> ::hadoop::hdfs::namenode::StartCheckpointResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::namenode::StartCheckpointResponseProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace hdfs {
namespace namenode {

// ===================================================================

class GetBlocksRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetBlocksRequestProto) */ {
 public:
  GetBlocksRequestProto();
  virtual ~GetBlocksRequestProto();

  GetBlocksRequestProto(const GetBlocksRequestProto& from);

  inline GetBlocksRequestProto& operator=(const GetBlocksRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlocksRequestProto(GetBlocksRequestProto&& from) noexcept
    : GetBlocksRequestProto() {
    *this = ::std::move(from);
  }

  inline GetBlocksRequestProto& operator=(GetBlocksRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlocksRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlocksRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetBlocksRequestProto*>(
               &_GetBlocksRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GetBlocksRequestProto* other);
  friend void swap(GetBlocksRequestProto& a, GetBlocksRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlocksRequestProto* New() const final {
    return CreateMaybeMessage<GetBlocksRequestProto>(NULL);
  }

  GetBlocksRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlocksRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlocksRequestProto& from);
  void MergeFrom(const GetBlocksRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlocksRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.DatanodeIDProto datanode = 1;
  bool has_datanode() const;
  void clear_datanode();
  static const int kDatanodeFieldNumber = 1;
  private:
  const ::hadoop::hdfs::DatanodeIDProto& _internal_datanode() const;
  public:
  const ::hadoop::hdfs::DatanodeIDProto& datanode() const;
  ::hadoop::hdfs::DatanodeIDProto* release_datanode();
  ::hadoop::hdfs::DatanodeIDProto* mutable_datanode();
  void set_allocated_datanode(::hadoop::hdfs::DatanodeIDProto* datanode);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // optional uint64 minBlockSize = 3 [default = 10485760];
  bool has_minblocksize() const;
  void clear_minblocksize();
  static const int kMinBlockSizeFieldNumber = 3;
  ::google::protobuf::uint64 minblocksize() const;
  void set_minblocksize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetBlocksRequestProto)
 private:
  void set_has_datanode();
  void clear_has_datanode();
  void set_has_size();
  void clear_has_size();
  void set_has_minblocksize();
  void clear_has_minblocksize();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::DatanodeIDProto* datanode_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 minblocksize_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlocksResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetBlocksResponseProto) */ {
 public:
  GetBlocksResponseProto();
  virtual ~GetBlocksResponseProto();

  GetBlocksResponseProto(const GetBlocksResponseProto& from);

  inline GetBlocksResponseProto& operator=(const GetBlocksResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlocksResponseProto(GetBlocksResponseProto&& from) noexcept
    : GetBlocksResponseProto() {
    *this = ::std::move(from);
  }

  inline GetBlocksResponseProto& operator=(GetBlocksResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlocksResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlocksResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetBlocksResponseProto*>(
               &_GetBlocksResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GetBlocksResponseProto* other);
  friend void swap(GetBlocksResponseProto& a, GetBlocksResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlocksResponseProto* New() const final {
    return CreateMaybeMessage<GetBlocksResponseProto>(NULL);
  }

  GetBlocksResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlocksResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlocksResponseProto& from);
  void MergeFrom(const GetBlocksResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlocksResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.BlocksWithLocationsProto blocks = 1;
  bool has_blocks() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 1;
  private:
  const ::hadoop::hdfs::BlocksWithLocationsProto& _internal_blocks() const;
  public:
  const ::hadoop::hdfs::BlocksWithLocationsProto& blocks() const;
  ::hadoop::hdfs::BlocksWithLocationsProto* release_blocks();
  ::hadoop::hdfs::BlocksWithLocationsProto* mutable_blocks();
  void set_allocated_blocks(::hadoop::hdfs::BlocksWithLocationsProto* blocks);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetBlocksResponseProto)
 private:
  void set_has_blocks();
  void clear_has_blocks();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::BlocksWithLocationsProto* blocks_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockKeysRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetBlockKeysRequestProto) */ {
 public:
  GetBlockKeysRequestProto();
  virtual ~GetBlockKeysRequestProto();

  GetBlockKeysRequestProto(const GetBlockKeysRequestProto& from);

  inline GetBlockKeysRequestProto& operator=(const GetBlockKeysRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockKeysRequestProto(GetBlockKeysRequestProto&& from) noexcept
    : GetBlockKeysRequestProto() {
    *this = ::std::move(from);
  }

  inline GetBlockKeysRequestProto& operator=(GetBlockKeysRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockKeysRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockKeysRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetBlockKeysRequestProto*>(
               &_GetBlockKeysRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetBlockKeysRequestProto* other);
  friend void swap(GetBlockKeysRequestProto& a, GetBlockKeysRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockKeysRequestProto* New() const final {
    return CreateMaybeMessage<GetBlockKeysRequestProto>(NULL);
  }

  GetBlockKeysRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockKeysRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockKeysRequestProto& from);
  void MergeFrom(const GetBlockKeysRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockKeysRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetBlockKeysRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockKeysResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetBlockKeysResponseProto) */ {
 public:
  GetBlockKeysResponseProto();
  virtual ~GetBlockKeysResponseProto();

  GetBlockKeysResponseProto(const GetBlockKeysResponseProto& from);

  inline GetBlockKeysResponseProto& operator=(const GetBlockKeysResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockKeysResponseProto(GetBlockKeysResponseProto&& from) noexcept
    : GetBlockKeysResponseProto() {
    *this = ::std::move(from);
  }

  inline GetBlockKeysResponseProto& operator=(GetBlockKeysResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockKeysResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockKeysResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetBlockKeysResponseProto*>(
               &_GetBlockKeysResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetBlockKeysResponseProto* other);
  friend void swap(GetBlockKeysResponseProto& a, GetBlockKeysResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockKeysResponseProto* New() const final {
    return CreateMaybeMessage<GetBlockKeysResponseProto>(NULL);
  }

  GetBlockKeysResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockKeysResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockKeysResponseProto& from);
  void MergeFrom(const GetBlockKeysResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockKeysResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hadoop.hdfs.ExportedBlockKeysProto keys = 1;
  bool has_keys() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  private:
  const ::hadoop::hdfs::ExportedBlockKeysProto& _internal_keys() const;
  public:
  const ::hadoop::hdfs::ExportedBlockKeysProto& keys() const;
  ::hadoop::hdfs::ExportedBlockKeysProto* release_keys();
  ::hadoop::hdfs::ExportedBlockKeysProto* mutable_keys();
  void set_allocated_keys(::hadoop::hdfs::ExportedBlockKeysProto* keys);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetBlockKeysResponseProto)
 private:
  void set_has_keys();
  void clear_has_keys();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::ExportedBlockKeysProto* keys_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTransactionIdRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetTransactionIdRequestProto) */ {
 public:
  GetTransactionIdRequestProto();
  virtual ~GetTransactionIdRequestProto();

  GetTransactionIdRequestProto(const GetTransactionIdRequestProto& from);

  inline GetTransactionIdRequestProto& operator=(const GetTransactionIdRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTransactionIdRequestProto(GetTransactionIdRequestProto&& from) noexcept
    : GetTransactionIdRequestProto() {
    *this = ::std::move(from);
  }

  inline GetTransactionIdRequestProto& operator=(GetTransactionIdRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTransactionIdRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTransactionIdRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetTransactionIdRequestProto*>(
               &_GetTransactionIdRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetTransactionIdRequestProto* other);
  friend void swap(GetTransactionIdRequestProto& a, GetTransactionIdRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionIdRequestProto* New() const final {
    return CreateMaybeMessage<GetTransactionIdRequestProto>(NULL);
  }

  GetTransactionIdRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTransactionIdRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTransactionIdRequestProto& from);
  void MergeFrom(const GetTransactionIdRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionIdRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetTransactionIdRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTransactionIdResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetTransactionIdResponseProto) */ {
 public:
  GetTransactionIdResponseProto();
  virtual ~GetTransactionIdResponseProto();

  GetTransactionIdResponseProto(const GetTransactionIdResponseProto& from);

  inline GetTransactionIdResponseProto& operator=(const GetTransactionIdResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTransactionIdResponseProto(GetTransactionIdResponseProto&& from) noexcept
    : GetTransactionIdResponseProto() {
    *this = ::std::move(from);
  }

  inline GetTransactionIdResponseProto& operator=(GetTransactionIdResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTransactionIdResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTransactionIdResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetTransactionIdResponseProto*>(
               &_GetTransactionIdResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetTransactionIdResponseProto* other);
  friend void swap(GetTransactionIdResponseProto& a, GetTransactionIdResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionIdResponseProto* New() const final {
    return CreateMaybeMessage<GetTransactionIdResponseProto>(NULL);
  }

  GetTransactionIdResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTransactionIdResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTransactionIdResponseProto& from);
  void MergeFrom(const GetTransactionIdResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionIdResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 txId = 1;
  bool has_txid() const;
  void clear_txid();
  static const int kTxIdFieldNumber = 1;
  ::google::protobuf::uint64 txid() const;
  void set_txid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetTransactionIdResponseProto)
 private:
  void set_has_txid();
  void clear_has_txid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 txid_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RollEditLogRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.RollEditLogRequestProto) */ {
 public:
  RollEditLogRequestProto();
  virtual ~RollEditLogRequestProto();

  RollEditLogRequestProto(const RollEditLogRequestProto& from);

  inline RollEditLogRequestProto& operator=(const RollEditLogRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RollEditLogRequestProto(RollEditLogRequestProto&& from) noexcept
    : RollEditLogRequestProto() {
    *this = ::std::move(from);
  }

  inline RollEditLogRequestProto& operator=(RollEditLogRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RollEditLogRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RollEditLogRequestProto* internal_default_instance() {
    return reinterpret_cast<const RollEditLogRequestProto*>(
               &_RollEditLogRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RollEditLogRequestProto* other);
  friend void swap(RollEditLogRequestProto& a, RollEditLogRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RollEditLogRequestProto* New() const final {
    return CreateMaybeMessage<RollEditLogRequestProto>(NULL);
  }

  RollEditLogRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RollEditLogRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RollEditLogRequestProto& from);
  void MergeFrom(const RollEditLogRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RollEditLogRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.RollEditLogRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RollEditLogResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.RollEditLogResponseProto) */ {
 public:
  RollEditLogResponseProto();
  virtual ~RollEditLogResponseProto();

  RollEditLogResponseProto(const RollEditLogResponseProto& from);

  inline RollEditLogResponseProto& operator=(const RollEditLogResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RollEditLogResponseProto(RollEditLogResponseProto&& from) noexcept
    : RollEditLogResponseProto() {
    *this = ::std::move(from);
  }

  inline RollEditLogResponseProto& operator=(RollEditLogResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RollEditLogResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RollEditLogResponseProto* internal_default_instance() {
    return reinterpret_cast<const RollEditLogResponseProto*>(
               &_RollEditLogResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RollEditLogResponseProto* other);
  friend void swap(RollEditLogResponseProto& a, RollEditLogResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RollEditLogResponseProto* New() const final {
    return CreateMaybeMessage<RollEditLogResponseProto>(NULL);
  }

  RollEditLogResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RollEditLogResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RollEditLogResponseProto& from);
  void MergeFrom(const RollEditLogResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RollEditLogResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.CheckpointSignatureProto signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  private:
  const ::hadoop::hdfs::CheckpointSignatureProto& _internal_signature() const;
  public:
  const ::hadoop::hdfs::CheckpointSignatureProto& signature() const;
  ::hadoop::hdfs::CheckpointSignatureProto* release_signature();
  ::hadoop::hdfs::CheckpointSignatureProto* mutable_signature();
  void set_allocated_signature(::hadoop::hdfs::CheckpointSignatureProto* signature);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.RollEditLogResponseProto)
 private:
  void set_has_signature();
  void clear_has_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::CheckpointSignatureProto* signature_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMostRecentCheckpointTxIdRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetMostRecentCheckpointTxIdRequestProto) */ {
 public:
  GetMostRecentCheckpointTxIdRequestProto();
  virtual ~GetMostRecentCheckpointTxIdRequestProto();

  GetMostRecentCheckpointTxIdRequestProto(const GetMostRecentCheckpointTxIdRequestProto& from);

  inline GetMostRecentCheckpointTxIdRequestProto& operator=(const GetMostRecentCheckpointTxIdRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMostRecentCheckpointTxIdRequestProto(GetMostRecentCheckpointTxIdRequestProto&& from) noexcept
    : GetMostRecentCheckpointTxIdRequestProto() {
    *this = ::std::move(from);
  }

  inline GetMostRecentCheckpointTxIdRequestProto& operator=(GetMostRecentCheckpointTxIdRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMostRecentCheckpointTxIdRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMostRecentCheckpointTxIdRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetMostRecentCheckpointTxIdRequestProto*>(
               &_GetMostRecentCheckpointTxIdRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetMostRecentCheckpointTxIdRequestProto* other);
  friend void swap(GetMostRecentCheckpointTxIdRequestProto& a, GetMostRecentCheckpointTxIdRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMostRecentCheckpointTxIdRequestProto* New() const final {
    return CreateMaybeMessage<GetMostRecentCheckpointTxIdRequestProto>(NULL);
  }

  GetMostRecentCheckpointTxIdRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMostRecentCheckpointTxIdRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMostRecentCheckpointTxIdRequestProto& from);
  void MergeFrom(const GetMostRecentCheckpointTxIdRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMostRecentCheckpointTxIdRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetMostRecentCheckpointTxIdRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMostRecentCheckpointTxIdResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetMostRecentCheckpointTxIdResponseProto) */ {
 public:
  GetMostRecentCheckpointTxIdResponseProto();
  virtual ~GetMostRecentCheckpointTxIdResponseProto();

  GetMostRecentCheckpointTxIdResponseProto(const GetMostRecentCheckpointTxIdResponseProto& from);

  inline GetMostRecentCheckpointTxIdResponseProto& operator=(const GetMostRecentCheckpointTxIdResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMostRecentCheckpointTxIdResponseProto(GetMostRecentCheckpointTxIdResponseProto&& from) noexcept
    : GetMostRecentCheckpointTxIdResponseProto() {
    *this = ::std::move(from);
  }

  inline GetMostRecentCheckpointTxIdResponseProto& operator=(GetMostRecentCheckpointTxIdResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMostRecentCheckpointTxIdResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMostRecentCheckpointTxIdResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetMostRecentCheckpointTxIdResponseProto*>(
               &_GetMostRecentCheckpointTxIdResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetMostRecentCheckpointTxIdResponseProto* other);
  friend void swap(GetMostRecentCheckpointTxIdResponseProto& a, GetMostRecentCheckpointTxIdResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMostRecentCheckpointTxIdResponseProto* New() const final {
    return CreateMaybeMessage<GetMostRecentCheckpointTxIdResponseProto>(NULL);
  }

  GetMostRecentCheckpointTxIdResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMostRecentCheckpointTxIdResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMostRecentCheckpointTxIdResponseProto& from);
  void MergeFrom(const GetMostRecentCheckpointTxIdResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMostRecentCheckpointTxIdResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 txId = 1;
  bool has_txid() const;
  void clear_txid();
  static const int kTxIdFieldNumber = 1;
  ::google::protobuf::uint64 txid() const;
  void set_txid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetMostRecentCheckpointTxIdResponseProto)
 private:
  void set_has_txid();
  void clear_has_txid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 txid_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorReportRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.ErrorReportRequestProto) */ {
 public:
  ErrorReportRequestProto();
  virtual ~ErrorReportRequestProto();

  ErrorReportRequestProto(const ErrorReportRequestProto& from);

  inline ErrorReportRequestProto& operator=(const ErrorReportRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorReportRequestProto(ErrorReportRequestProto&& from) noexcept
    : ErrorReportRequestProto() {
    *this = ::std::move(from);
  }

  inline ErrorReportRequestProto& operator=(ErrorReportRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorReportRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorReportRequestProto* internal_default_instance() {
    return reinterpret_cast<const ErrorReportRequestProto*>(
               &_ErrorReportRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ErrorReportRequestProto* other);
  friend void swap(ErrorReportRequestProto& a, ErrorReportRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorReportRequestProto* New() const final {
    return CreateMaybeMessage<ErrorReportRequestProto>(NULL);
  }

  ErrorReportRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorReportRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorReportRequestProto& from);
  void MergeFrom(const ErrorReportRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorReportRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg = 3;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 3;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 1;
  private:
  const ::hadoop::hdfs::NamenodeRegistrationProto& _internal_registration() const;
  public:
  const ::hadoop::hdfs::NamenodeRegistrationProto& registration() const;
  ::hadoop::hdfs::NamenodeRegistrationProto* release_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* mutable_registration();
  void set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration);

  // required uint32 errorCode = 2;
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 2;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.ErrorReportRequestProto)
 private:
  void set_has_registration();
  void clear_has_registration();
  void set_has_errorcode();
  void clear_has_errorcode();
  void set_has_msg();
  void clear_has_msg();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::hadoop::hdfs::NamenodeRegistrationProto* registration_;
  ::google::protobuf::uint32 errorcode_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorReportResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.ErrorReportResponseProto) */ {
 public:
  ErrorReportResponseProto();
  virtual ~ErrorReportResponseProto();

  ErrorReportResponseProto(const ErrorReportResponseProto& from);

  inline ErrorReportResponseProto& operator=(const ErrorReportResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorReportResponseProto(ErrorReportResponseProto&& from) noexcept
    : ErrorReportResponseProto() {
    *this = ::std::move(from);
  }

  inline ErrorReportResponseProto& operator=(ErrorReportResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorReportResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorReportResponseProto* internal_default_instance() {
    return reinterpret_cast<const ErrorReportResponseProto*>(
               &_ErrorReportResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ErrorReportResponseProto* other);
  friend void swap(ErrorReportResponseProto& a, ErrorReportResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorReportResponseProto* New() const final {
    return CreateMaybeMessage<ErrorReportResponseProto>(NULL);
  }

  ErrorReportResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorReportResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorReportResponseProto& from);
  void MergeFrom(const ErrorReportResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorReportResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.ErrorReportResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.RegisterRequestProto) */ {
 public:
  RegisterRequestProto();
  virtual ~RegisterRequestProto();

  RegisterRequestProto(const RegisterRequestProto& from);

  inline RegisterRequestProto& operator=(const RegisterRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequestProto(RegisterRequestProto&& from) noexcept
    : RegisterRequestProto() {
    *this = ::std::move(from);
  }

  inline RegisterRequestProto& operator=(RegisterRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequestProto* internal_default_instance() {
    return reinterpret_cast<const RegisterRequestProto*>(
               &_RegisterRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RegisterRequestProto* other);
  friend void swap(RegisterRequestProto& a, RegisterRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequestProto* New() const final {
    return CreateMaybeMessage<RegisterRequestProto>(NULL);
  }

  RegisterRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequestProto& from);
  void MergeFrom(const RegisterRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 1;
  private:
  const ::hadoop::hdfs::NamenodeRegistrationProto& _internal_registration() const;
  public:
  const ::hadoop::hdfs::NamenodeRegistrationProto& registration() const;
  ::hadoop::hdfs::NamenodeRegistrationProto* release_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* mutable_registration();
  void set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.RegisterRequestProto)
 private:
  void set_has_registration();
  void clear_has_registration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::NamenodeRegistrationProto* registration_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.RegisterResponseProto) */ {
 public:
  RegisterResponseProto();
  virtual ~RegisterResponseProto();

  RegisterResponseProto(const RegisterResponseProto& from);

  inline RegisterResponseProto& operator=(const RegisterResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponseProto(RegisterResponseProto&& from) noexcept
    : RegisterResponseProto() {
    *this = ::std::move(from);
  }

  inline RegisterResponseProto& operator=(RegisterResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponseProto* internal_default_instance() {
    return reinterpret_cast<const RegisterResponseProto*>(
               &_RegisterResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RegisterResponseProto* other);
  friend void swap(RegisterResponseProto& a, RegisterResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponseProto* New() const final {
    return CreateMaybeMessage<RegisterResponseProto>(NULL);
  }

  RegisterResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponseProto& from);
  void MergeFrom(const RegisterResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 1;
  private:
  const ::hadoop::hdfs::NamenodeRegistrationProto& _internal_registration() const;
  public:
  const ::hadoop::hdfs::NamenodeRegistrationProto& registration() const;
  ::hadoop::hdfs::NamenodeRegistrationProto* release_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* mutable_registration();
  void set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.RegisterResponseProto)
 private:
  void set_has_registration();
  void clear_has_registration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::NamenodeRegistrationProto* registration_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartCheckpointRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.StartCheckpointRequestProto) */ {
 public:
  StartCheckpointRequestProto();
  virtual ~StartCheckpointRequestProto();

  StartCheckpointRequestProto(const StartCheckpointRequestProto& from);

  inline StartCheckpointRequestProto& operator=(const StartCheckpointRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartCheckpointRequestProto(StartCheckpointRequestProto&& from) noexcept
    : StartCheckpointRequestProto() {
    *this = ::std::move(from);
  }

  inline StartCheckpointRequestProto& operator=(StartCheckpointRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartCheckpointRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartCheckpointRequestProto* internal_default_instance() {
    return reinterpret_cast<const StartCheckpointRequestProto*>(
               &_StartCheckpointRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(StartCheckpointRequestProto* other);
  friend void swap(StartCheckpointRequestProto& a, StartCheckpointRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartCheckpointRequestProto* New() const final {
    return CreateMaybeMessage<StartCheckpointRequestProto>(NULL);
  }

  StartCheckpointRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartCheckpointRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartCheckpointRequestProto& from);
  void MergeFrom(const StartCheckpointRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartCheckpointRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 1;
  private:
  const ::hadoop::hdfs::NamenodeRegistrationProto& _internal_registration() const;
  public:
  const ::hadoop::hdfs::NamenodeRegistrationProto& registration() const;
  ::hadoop::hdfs::NamenodeRegistrationProto* release_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* mutable_registration();
  void set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.StartCheckpointRequestProto)
 private:
  void set_has_registration();
  void clear_has_registration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::NamenodeRegistrationProto* registration_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartCheckpointResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.StartCheckpointResponseProto) */ {
 public:
  StartCheckpointResponseProto();
  virtual ~StartCheckpointResponseProto();

  StartCheckpointResponseProto(const StartCheckpointResponseProto& from);

  inline StartCheckpointResponseProto& operator=(const StartCheckpointResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartCheckpointResponseProto(StartCheckpointResponseProto&& from) noexcept
    : StartCheckpointResponseProto() {
    *this = ::std::move(from);
  }

  inline StartCheckpointResponseProto& operator=(StartCheckpointResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartCheckpointResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartCheckpointResponseProto* internal_default_instance() {
    return reinterpret_cast<const StartCheckpointResponseProto*>(
               &_StartCheckpointResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(StartCheckpointResponseProto* other);
  friend void swap(StartCheckpointResponseProto& a, StartCheckpointResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartCheckpointResponseProto* New() const final {
    return CreateMaybeMessage<StartCheckpointResponseProto>(NULL);
  }

  StartCheckpointResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartCheckpointResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartCheckpointResponseProto& from);
  void MergeFrom(const StartCheckpointResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartCheckpointResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.NamenodeCommandProto command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  private:
  const ::hadoop::hdfs::NamenodeCommandProto& _internal_command() const;
  public:
  const ::hadoop::hdfs::NamenodeCommandProto& command() const;
  ::hadoop::hdfs::NamenodeCommandProto* release_command();
  ::hadoop::hdfs::NamenodeCommandProto* mutable_command();
  void set_allocated_command(::hadoop::hdfs::NamenodeCommandProto* command);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.StartCheckpointResponseProto)
 private:
  void set_has_command();
  void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::NamenodeCommandProto* command_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndCheckpointRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.EndCheckpointRequestProto) */ {
 public:
  EndCheckpointRequestProto();
  virtual ~EndCheckpointRequestProto();

  EndCheckpointRequestProto(const EndCheckpointRequestProto& from);

  inline EndCheckpointRequestProto& operator=(const EndCheckpointRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndCheckpointRequestProto(EndCheckpointRequestProto&& from) noexcept
    : EndCheckpointRequestProto() {
    *this = ::std::move(from);
  }

  inline EndCheckpointRequestProto& operator=(EndCheckpointRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndCheckpointRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndCheckpointRequestProto* internal_default_instance() {
    return reinterpret_cast<const EndCheckpointRequestProto*>(
               &_EndCheckpointRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(EndCheckpointRequestProto* other);
  friend void swap(EndCheckpointRequestProto& a, EndCheckpointRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndCheckpointRequestProto* New() const final {
    return CreateMaybeMessage<EndCheckpointRequestProto>(NULL);
  }

  EndCheckpointRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndCheckpointRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EndCheckpointRequestProto& from);
  void MergeFrom(const EndCheckpointRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndCheckpointRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 1;
  private:
  const ::hadoop::hdfs::NamenodeRegistrationProto& _internal_registration() const;
  public:
  const ::hadoop::hdfs::NamenodeRegistrationProto& registration() const;
  ::hadoop::hdfs::NamenodeRegistrationProto* release_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* mutable_registration();
  void set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration);

  // required .hadoop.hdfs.CheckpointSignatureProto signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  private:
  const ::hadoop::hdfs::CheckpointSignatureProto& _internal_signature() const;
  public:
  const ::hadoop::hdfs::CheckpointSignatureProto& signature() const;
  ::hadoop::hdfs::CheckpointSignatureProto* release_signature();
  ::hadoop::hdfs::CheckpointSignatureProto* mutable_signature();
  void set_allocated_signature(::hadoop::hdfs::CheckpointSignatureProto* signature);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.EndCheckpointRequestProto)
 private:
  void set_has_registration();
  void clear_has_registration();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::NamenodeRegistrationProto* registration_;
  ::hadoop::hdfs::CheckpointSignatureProto* signature_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndCheckpointResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.EndCheckpointResponseProto) */ {
 public:
  EndCheckpointResponseProto();
  virtual ~EndCheckpointResponseProto();

  EndCheckpointResponseProto(const EndCheckpointResponseProto& from);

  inline EndCheckpointResponseProto& operator=(const EndCheckpointResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndCheckpointResponseProto(EndCheckpointResponseProto&& from) noexcept
    : EndCheckpointResponseProto() {
    *this = ::std::move(from);
  }

  inline EndCheckpointResponseProto& operator=(EndCheckpointResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndCheckpointResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndCheckpointResponseProto* internal_default_instance() {
    return reinterpret_cast<const EndCheckpointResponseProto*>(
               &_EndCheckpointResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(EndCheckpointResponseProto* other);
  friend void swap(EndCheckpointResponseProto& a, EndCheckpointResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndCheckpointResponseProto* New() const final {
    return CreateMaybeMessage<EndCheckpointResponseProto>(NULL);
  }

  EndCheckpointResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndCheckpointResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EndCheckpointResponseProto& from);
  void MergeFrom(const EndCheckpointResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndCheckpointResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.EndCheckpointResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEditLogManifestRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetEditLogManifestRequestProto) */ {
 public:
  GetEditLogManifestRequestProto();
  virtual ~GetEditLogManifestRequestProto();

  GetEditLogManifestRequestProto(const GetEditLogManifestRequestProto& from);

  inline GetEditLogManifestRequestProto& operator=(const GetEditLogManifestRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetEditLogManifestRequestProto(GetEditLogManifestRequestProto&& from) noexcept
    : GetEditLogManifestRequestProto() {
    *this = ::std::move(from);
  }

  inline GetEditLogManifestRequestProto& operator=(GetEditLogManifestRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEditLogManifestRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEditLogManifestRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetEditLogManifestRequestProto*>(
               &_GetEditLogManifestRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetEditLogManifestRequestProto* other);
  friend void swap(GetEditLogManifestRequestProto& a, GetEditLogManifestRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEditLogManifestRequestProto* New() const final {
    return CreateMaybeMessage<GetEditLogManifestRequestProto>(NULL);
  }

  GetEditLogManifestRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetEditLogManifestRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetEditLogManifestRequestProto& from);
  void MergeFrom(const GetEditLogManifestRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEditLogManifestRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 sinceTxId = 1;
  bool has_sincetxid() const;
  void clear_sincetxid();
  static const int kSinceTxIdFieldNumber = 1;
  ::google::protobuf::uint64 sincetxid() const;
  void set_sincetxid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetEditLogManifestRequestProto)
 private:
  void set_has_sincetxid();
  void clear_has_sincetxid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 sincetxid_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEditLogManifestResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetEditLogManifestResponseProto) */ {
 public:
  GetEditLogManifestResponseProto();
  virtual ~GetEditLogManifestResponseProto();

  GetEditLogManifestResponseProto(const GetEditLogManifestResponseProto& from);

  inline GetEditLogManifestResponseProto& operator=(const GetEditLogManifestResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetEditLogManifestResponseProto(GetEditLogManifestResponseProto&& from) noexcept
    : GetEditLogManifestResponseProto() {
    *this = ::std::move(from);
  }

  inline GetEditLogManifestResponseProto& operator=(GetEditLogManifestResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEditLogManifestResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEditLogManifestResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetEditLogManifestResponseProto*>(
               &_GetEditLogManifestResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GetEditLogManifestResponseProto* other);
  friend void swap(GetEditLogManifestResponseProto& a, GetEditLogManifestResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEditLogManifestResponseProto* New() const final {
    return CreateMaybeMessage<GetEditLogManifestResponseProto>(NULL);
  }

  GetEditLogManifestResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetEditLogManifestResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetEditLogManifestResponseProto& from);
  void MergeFrom(const GetEditLogManifestResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEditLogManifestResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.RemoteEditLogManifestProto manifest = 1;
  bool has_manifest() const;
  void clear_manifest();
  static const int kManifestFieldNumber = 1;
  private:
  const ::hadoop::hdfs::RemoteEditLogManifestProto& _internal_manifest() const;
  public:
  const ::hadoop::hdfs::RemoteEditLogManifestProto& manifest() const;
  ::hadoop::hdfs::RemoteEditLogManifestProto* release_manifest();
  ::hadoop::hdfs::RemoteEditLogManifestProto* mutable_manifest();
  void set_allocated_manifest(::hadoop::hdfs::RemoteEditLogManifestProto* manifest);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetEditLogManifestResponseProto)
 private:
  void set_has_manifest();
  void clear_has_manifest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::RemoteEditLogManifestProto* manifest_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsUpgradeFinalizedRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.IsUpgradeFinalizedRequestProto) */ {
 public:
  IsUpgradeFinalizedRequestProto();
  virtual ~IsUpgradeFinalizedRequestProto();

  IsUpgradeFinalizedRequestProto(const IsUpgradeFinalizedRequestProto& from);

  inline IsUpgradeFinalizedRequestProto& operator=(const IsUpgradeFinalizedRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsUpgradeFinalizedRequestProto(IsUpgradeFinalizedRequestProto&& from) noexcept
    : IsUpgradeFinalizedRequestProto() {
    *this = ::std::move(from);
  }

  inline IsUpgradeFinalizedRequestProto& operator=(IsUpgradeFinalizedRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsUpgradeFinalizedRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsUpgradeFinalizedRequestProto* internal_default_instance() {
    return reinterpret_cast<const IsUpgradeFinalizedRequestProto*>(
               &_IsUpgradeFinalizedRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(IsUpgradeFinalizedRequestProto* other);
  friend void swap(IsUpgradeFinalizedRequestProto& a, IsUpgradeFinalizedRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsUpgradeFinalizedRequestProto* New() const final {
    return CreateMaybeMessage<IsUpgradeFinalizedRequestProto>(NULL);
  }

  IsUpgradeFinalizedRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsUpgradeFinalizedRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsUpgradeFinalizedRequestProto& from);
  void MergeFrom(const IsUpgradeFinalizedRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsUpgradeFinalizedRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.IsUpgradeFinalizedRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsUpgradeFinalizedResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.IsUpgradeFinalizedResponseProto) */ {
 public:
  IsUpgradeFinalizedResponseProto();
  virtual ~IsUpgradeFinalizedResponseProto();

  IsUpgradeFinalizedResponseProto(const IsUpgradeFinalizedResponseProto& from);

  inline IsUpgradeFinalizedResponseProto& operator=(const IsUpgradeFinalizedResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsUpgradeFinalizedResponseProto(IsUpgradeFinalizedResponseProto&& from) noexcept
    : IsUpgradeFinalizedResponseProto() {
    *this = ::std::move(from);
  }

  inline IsUpgradeFinalizedResponseProto& operator=(IsUpgradeFinalizedResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsUpgradeFinalizedResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsUpgradeFinalizedResponseProto* internal_default_instance() {
    return reinterpret_cast<const IsUpgradeFinalizedResponseProto*>(
               &_IsUpgradeFinalizedResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(IsUpgradeFinalizedResponseProto* other);
  friend void swap(IsUpgradeFinalizedResponseProto& a, IsUpgradeFinalizedResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsUpgradeFinalizedResponseProto* New() const final {
    return CreateMaybeMessage<IsUpgradeFinalizedResponseProto>(NULL);
  }

  IsUpgradeFinalizedResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsUpgradeFinalizedResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsUpgradeFinalizedResponseProto& from);
  void MergeFrom(const IsUpgradeFinalizedResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsUpgradeFinalizedResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isUpgradeFinalized = 1;
  bool has_isupgradefinalized() const;
  void clear_isupgradefinalized();
  static const int kIsUpgradeFinalizedFieldNumber = 1;
  bool isupgradefinalized() const;
  void set_isupgradefinalized(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.IsUpgradeFinalizedResponseProto)
 private:
  void set_has_isupgradefinalized();
  void clear_has_isupgradefinalized();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool isupgradefinalized_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsRollingUpgradeRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.IsRollingUpgradeRequestProto) */ {
 public:
  IsRollingUpgradeRequestProto();
  virtual ~IsRollingUpgradeRequestProto();

  IsRollingUpgradeRequestProto(const IsRollingUpgradeRequestProto& from);

  inline IsRollingUpgradeRequestProto& operator=(const IsRollingUpgradeRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsRollingUpgradeRequestProto(IsRollingUpgradeRequestProto&& from) noexcept
    : IsRollingUpgradeRequestProto() {
    *this = ::std::move(from);
  }

  inline IsRollingUpgradeRequestProto& operator=(IsRollingUpgradeRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsRollingUpgradeRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsRollingUpgradeRequestProto* internal_default_instance() {
    return reinterpret_cast<const IsRollingUpgradeRequestProto*>(
               &_IsRollingUpgradeRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(IsRollingUpgradeRequestProto* other);
  friend void swap(IsRollingUpgradeRequestProto& a, IsRollingUpgradeRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsRollingUpgradeRequestProto* New() const final {
    return CreateMaybeMessage<IsRollingUpgradeRequestProto>(NULL);
  }

  IsRollingUpgradeRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsRollingUpgradeRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsRollingUpgradeRequestProto& from);
  void MergeFrom(const IsRollingUpgradeRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsRollingUpgradeRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.IsRollingUpgradeRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsRollingUpgradeResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.IsRollingUpgradeResponseProto) */ {
 public:
  IsRollingUpgradeResponseProto();
  virtual ~IsRollingUpgradeResponseProto();

  IsRollingUpgradeResponseProto(const IsRollingUpgradeResponseProto& from);

  inline IsRollingUpgradeResponseProto& operator=(const IsRollingUpgradeResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsRollingUpgradeResponseProto(IsRollingUpgradeResponseProto&& from) noexcept
    : IsRollingUpgradeResponseProto() {
    *this = ::std::move(from);
  }

  inline IsRollingUpgradeResponseProto& operator=(IsRollingUpgradeResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsRollingUpgradeResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsRollingUpgradeResponseProto* internal_default_instance() {
    return reinterpret_cast<const IsRollingUpgradeResponseProto*>(
               &_IsRollingUpgradeResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(IsRollingUpgradeResponseProto* other);
  friend void swap(IsRollingUpgradeResponseProto& a, IsRollingUpgradeResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsRollingUpgradeResponseProto* New() const final {
    return CreateMaybeMessage<IsRollingUpgradeResponseProto>(NULL);
  }

  IsRollingUpgradeResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsRollingUpgradeResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsRollingUpgradeResponseProto& from);
  void MergeFrom(const IsRollingUpgradeResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsRollingUpgradeResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isRollingUpgrade = 1;
  bool has_isrollingupgrade() const;
  void clear_isrollingupgrade();
  static const int kIsRollingUpgradeFieldNumber = 1;
  bool isrollingupgrade() const;
  void set_isrollingupgrade(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.IsRollingUpgradeResponseProto)
 private:
  void set_has_isrollingupgrade();
  void clear_has_isrollingupgrade();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool isrollingupgrade_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetFilePathRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetFilePathRequestProto) */ {
 public:
  GetFilePathRequestProto();
  virtual ~GetFilePathRequestProto();

  GetFilePathRequestProto(const GetFilePathRequestProto& from);

  inline GetFilePathRequestProto& operator=(const GetFilePathRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetFilePathRequestProto(GetFilePathRequestProto&& from) noexcept
    : GetFilePathRequestProto() {
    *this = ::std::move(from);
  }

  inline GetFilePathRequestProto& operator=(GetFilePathRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFilePathRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFilePathRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetFilePathRequestProto*>(
               &_GetFilePathRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(GetFilePathRequestProto* other);
  friend void swap(GetFilePathRequestProto& a, GetFilePathRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetFilePathRequestProto* New() const final {
    return CreateMaybeMessage<GetFilePathRequestProto>(NULL);
  }

  GetFilePathRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetFilePathRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetFilePathRequestProto& from);
  void MergeFrom(const GetFilePathRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFilePathRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 fileId = 1;
  bool has_fileid() const;
  void clear_fileid();
  static const int kFileIdFieldNumber = 1;
  ::google::protobuf::uint64 fileid() const;
  void set_fileid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetFilePathRequestProto)
 private:
  void set_has_fileid();
  void clear_has_fileid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 fileid_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetFilePathResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetFilePathResponseProto) */ {
 public:
  GetFilePathResponseProto();
  virtual ~GetFilePathResponseProto();

  GetFilePathResponseProto(const GetFilePathResponseProto& from);

  inline GetFilePathResponseProto& operator=(const GetFilePathResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetFilePathResponseProto(GetFilePathResponseProto&& from) noexcept
    : GetFilePathResponseProto() {
    *this = ::std::move(from);
  }

  inline GetFilePathResponseProto& operator=(GetFilePathResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFilePathResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFilePathResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetFilePathResponseProto*>(
               &_GetFilePathResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(GetFilePathResponseProto* other);
  friend void swap(GetFilePathResponseProto& a, GetFilePathResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetFilePathResponseProto* New() const final {
    return CreateMaybeMessage<GetFilePathResponseProto>(NULL);
  }

  GetFilePathResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetFilePathResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetFilePathResponseProto& from);
  void MergeFrom(const GetFilePathResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFilePathResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string srcPath = 1;
  bool has_srcpath() const;
  void clear_srcpath();
  static const int kSrcPathFieldNumber = 1;
  const ::std::string& srcpath() const;
  void set_srcpath(const ::std::string& value);
  #if LANG_CXX11
  void set_srcpath(::std::string&& value);
  #endif
  void set_srcpath(const char* value);
  void set_srcpath(const char* value, size_t size);
  ::std::string* mutable_srcpath();
  ::std::string* release_srcpath();
  void set_allocated_srcpath(::std::string* srcpath);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetFilePathResponseProto)
 private:
  void set_has_srcpath();
  void clear_has_srcpath();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr srcpath_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNextSPSPathRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetNextSPSPathRequestProto) */ {
 public:
  GetNextSPSPathRequestProto();
  virtual ~GetNextSPSPathRequestProto();

  GetNextSPSPathRequestProto(const GetNextSPSPathRequestProto& from);

  inline GetNextSPSPathRequestProto& operator=(const GetNextSPSPathRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNextSPSPathRequestProto(GetNextSPSPathRequestProto&& from) noexcept
    : GetNextSPSPathRequestProto() {
    *this = ::std::move(from);
  }

  inline GetNextSPSPathRequestProto& operator=(GetNextSPSPathRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNextSPSPathRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNextSPSPathRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetNextSPSPathRequestProto*>(
               &_GetNextSPSPathRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(GetNextSPSPathRequestProto* other);
  friend void swap(GetNextSPSPathRequestProto& a, GetNextSPSPathRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNextSPSPathRequestProto* New() const final {
    return CreateMaybeMessage<GetNextSPSPathRequestProto>(NULL);
  }

  GetNextSPSPathRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetNextSPSPathRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetNextSPSPathRequestProto& from);
  void MergeFrom(const GetNextSPSPathRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNextSPSPathRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetNextSPSPathRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNextSPSPathResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.namenode.GetNextSPSPathResponseProto) */ {
 public:
  GetNextSPSPathResponseProto();
  virtual ~GetNextSPSPathResponseProto();

  GetNextSPSPathResponseProto(const GetNextSPSPathResponseProto& from);

  inline GetNextSPSPathResponseProto& operator=(const GetNextSPSPathResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNextSPSPathResponseProto(GetNextSPSPathResponseProto&& from) noexcept
    : GetNextSPSPathResponseProto() {
    *this = ::std::move(from);
  }

  inline GetNextSPSPathResponseProto& operator=(GetNextSPSPathResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNextSPSPathResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNextSPSPathResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetNextSPSPathResponseProto*>(
               &_GetNextSPSPathResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(GetNextSPSPathResponseProto* other);
  friend void swap(GetNextSPSPathResponseProto& a, GetNextSPSPathResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNextSPSPathResponseProto* New() const final {
    return CreateMaybeMessage<GetNextSPSPathResponseProto>(NULL);
  }

  GetNextSPSPathResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetNextSPSPathResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetNextSPSPathResponseProto& from);
  void MergeFrom(const GetNextSPSPathResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNextSPSPathResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 spsPath = 1;
  bool has_spspath() const;
  void clear_spspath();
  static const int kSpsPathFieldNumber = 1;
  ::google::protobuf::uint64 spspath() const;
  void set_spspath(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.namenode.GetNextSPSPathResponseProto)
 private:
  void set_has_spspath();
  void clear_has_spspath();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 spspath_;
  friend struct ::protobuf_NamenodeProtocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetBlocksRequestProto

// required .hadoop.hdfs.DatanodeIDProto datanode = 1;
inline bool GetBlocksRequestProto::has_datanode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBlocksRequestProto::set_has_datanode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBlocksRequestProto::clear_has_datanode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::DatanodeIDProto& GetBlocksRequestProto::_internal_datanode() const {
  return *datanode_;
}
inline const ::hadoop::hdfs::DatanodeIDProto& GetBlocksRequestProto::datanode() const {
  const ::hadoop::hdfs::DatanodeIDProto* p = datanode_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetBlocksRequestProto.datanode)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::DatanodeIDProto*>(
      &::hadoop::hdfs::_DatanodeIDProto_default_instance_);
}
inline ::hadoop::hdfs::DatanodeIDProto* GetBlocksRequestProto::release_datanode() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.GetBlocksRequestProto.datanode)
  clear_has_datanode();
  ::hadoop::hdfs::DatanodeIDProto* temp = datanode_;
  datanode_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::DatanodeIDProto* GetBlocksRequestProto::mutable_datanode() {
  set_has_datanode();
  if (datanode_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::DatanodeIDProto>(GetArenaNoVirtual());
    datanode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.GetBlocksRequestProto.datanode)
  return datanode_;
}
inline void GetBlocksRequestProto::set_allocated_datanode(::hadoop::hdfs::DatanodeIDProto* datanode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(datanode_);
  }
  if (datanode) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      datanode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, datanode, submessage_arena);
    }
    set_has_datanode();
  } else {
    clear_has_datanode();
  }
  datanode_ = datanode;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.GetBlocksRequestProto.datanode)
}

// required uint64 size = 2;
inline bool GetBlocksRequestProto::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBlocksRequestProto::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBlocksRequestProto::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBlocksRequestProto::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 GetBlocksRequestProto::size() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetBlocksRequestProto.size)
  return size_;
}
inline void GetBlocksRequestProto::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetBlocksRequestProto.size)
}

// optional uint64 minBlockSize = 3 [default = 10485760];
inline bool GetBlocksRequestProto::has_minblocksize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBlocksRequestProto::set_has_minblocksize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBlocksRequestProto::clear_has_minblocksize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBlocksRequestProto::clear_minblocksize() {
  minblocksize_ = GOOGLE_ULONGLONG(10485760);
  clear_has_minblocksize();
}
inline ::google::protobuf::uint64 GetBlocksRequestProto::minblocksize() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetBlocksRequestProto.minBlockSize)
  return minblocksize_;
}
inline void GetBlocksRequestProto::set_minblocksize(::google::protobuf::uint64 value) {
  set_has_minblocksize();
  minblocksize_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetBlocksRequestProto.minBlockSize)
}

// -------------------------------------------------------------------

// GetBlocksResponseProto

// required .hadoop.hdfs.BlocksWithLocationsProto blocks = 1;
inline bool GetBlocksResponseProto::has_blocks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBlocksResponseProto::set_has_blocks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBlocksResponseProto::clear_has_blocks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::BlocksWithLocationsProto& GetBlocksResponseProto::_internal_blocks() const {
  return *blocks_;
}
inline const ::hadoop::hdfs::BlocksWithLocationsProto& GetBlocksResponseProto::blocks() const {
  const ::hadoop::hdfs::BlocksWithLocationsProto* p = blocks_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetBlocksResponseProto.blocks)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::BlocksWithLocationsProto*>(
      &::hadoop::hdfs::_BlocksWithLocationsProto_default_instance_);
}
inline ::hadoop::hdfs::BlocksWithLocationsProto* GetBlocksResponseProto::release_blocks() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.GetBlocksResponseProto.blocks)
  clear_has_blocks();
  ::hadoop::hdfs::BlocksWithLocationsProto* temp = blocks_;
  blocks_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::BlocksWithLocationsProto* GetBlocksResponseProto::mutable_blocks() {
  set_has_blocks();
  if (blocks_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::BlocksWithLocationsProto>(GetArenaNoVirtual());
    blocks_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.GetBlocksResponseProto.blocks)
  return blocks_;
}
inline void GetBlocksResponseProto::set_allocated_blocks(::hadoop::hdfs::BlocksWithLocationsProto* blocks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(blocks_);
  }
  if (blocks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blocks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blocks, submessage_arena);
    }
    set_has_blocks();
  } else {
    clear_has_blocks();
  }
  blocks_ = blocks;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.GetBlocksResponseProto.blocks)
}

// -------------------------------------------------------------------

// GetBlockKeysRequestProto

// -------------------------------------------------------------------

// GetBlockKeysResponseProto

// optional .hadoop.hdfs.ExportedBlockKeysProto keys = 1;
inline bool GetBlockKeysResponseProto::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBlockKeysResponseProto::set_has_keys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBlockKeysResponseProto::clear_has_keys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::ExportedBlockKeysProto& GetBlockKeysResponseProto::_internal_keys() const {
  return *keys_;
}
inline const ::hadoop::hdfs::ExportedBlockKeysProto& GetBlockKeysResponseProto::keys() const {
  const ::hadoop::hdfs::ExportedBlockKeysProto* p = keys_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetBlockKeysResponseProto.keys)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::ExportedBlockKeysProto*>(
      &::hadoop::hdfs::_ExportedBlockKeysProto_default_instance_);
}
inline ::hadoop::hdfs::ExportedBlockKeysProto* GetBlockKeysResponseProto::release_keys() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.GetBlockKeysResponseProto.keys)
  clear_has_keys();
  ::hadoop::hdfs::ExportedBlockKeysProto* temp = keys_;
  keys_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::ExportedBlockKeysProto* GetBlockKeysResponseProto::mutable_keys() {
  set_has_keys();
  if (keys_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::ExportedBlockKeysProto>(GetArenaNoVirtual());
    keys_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.GetBlockKeysResponseProto.keys)
  return keys_;
}
inline void GetBlockKeysResponseProto::set_allocated_keys(::hadoop::hdfs::ExportedBlockKeysProto* keys) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(keys_);
  }
  if (keys) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      keys = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, keys, submessage_arena);
    }
    set_has_keys();
  } else {
    clear_has_keys();
  }
  keys_ = keys;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.GetBlockKeysResponseProto.keys)
}

// -------------------------------------------------------------------

// GetTransactionIdRequestProto

// -------------------------------------------------------------------

// GetTransactionIdResponseProto

// required uint64 txId = 1;
inline bool GetTransactionIdResponseProto::has_txid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTransactionIdResponseProto::set_has_txid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTransactionIdResponseProto::clear_has_txid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTransactionIdResponseProto::clear_txid() {
  txid_ = GOOGLE_ULONGLONG(0);
  clear_has_txid();
}
inline ::google::protobuf::uint64 GetTransactionIdResponseProto::txid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetTransactionIdResponseProto.txId)
  return txid_;
}
inline void GetTransactionIdResponseProto::set_txid(::google::protobuf::uint64 value) {
  set_has_txid();
  txid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetTransactionIdResponseProto.txId)
}

// -------------------------------------------------------------------

// RollEditLogRequestProto

// -------------------------------------------------------------------

// RollEditLogResponseProto

// required .hadoop.hdfs.CheckpointSignatureProto signature = 1;
inline bool RollEditLogResponseProto::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RollEditLogResponseProto::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RollEditLogResponseProto::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::CheckpointSignatureProto& RollEditLogResponseProto::_internal_signature() const {
  return *signature_;
}
inline const ::hadoop::hdfs::CheckpointSignatureProto& RollEditLogResponseProto::signature() const {
  const ::hadoop::hdfs::CheckpointSignatureProto* p = signature_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.RollEditLogResponseProto.signature)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::CheckpointSignatureProto*>(
      &::hadoop::hdfs::_CheckpointSignatureProto_default_instance_);
}
inline ::hadoop::hdfs::CheckpointSignatureProto* RollEditLogResponseProto::release_signature() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.RollEditLogResponseProto.signature)
  clear_has_signature();
  ::hadoop::hdfs::CheckpointSignatureProto* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::CheckpointSignatureProto* RollEditLogResponseProto::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::CheckpointSignatureProto>(GetArenaNoVirtual());
    signature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.RollEditLogResponseProto.signature)
  return signature_;
}
inline void RollEditLogResponseProto::set_allocated_signature(::hadoop::hdfs::CheckpointSignatureProto* signature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(signature_);
  }
  if (signature) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.RollEditLogResponseProto.signature)
}

// -------------------------------------------------------------------

// GetMostRecentCheckpointTxIdRequestProto

// -------------------------------------------------------------------

// GetMostRecentCheckpointTxIdResponseProto

// required uint64 txId = 1;
inline bool GetMostRecentCheckpointTxIdResponseProto::has_txid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMostRecentCheckpointTxIdResponseProto::set_has_txid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMostRecentCheckpointTxIdResponseProto::clear_has_txid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMostRecentCheckpointTxIdResponseProto::clear_txid() {
  txid_ = GOOGLE_ULONGLONG(0);
  clear_has_txid();
}
inline ::google::protobuf::uint64 GetMostRecentCheckpointTxIdResponseProto::txid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetMostRecentCheckpointTxIdResponseProto.txId)
  return txid_;
}
inline void GetMostRecentCheckpointTxIdResponseProto::set_txid(::google::protobuf::uint64 value) {
  set_has_txid();
  txid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetMostRecentCheckpointTxIdResponseProto.txId)
}

// -------------------------------------------------------------------

// ErrorReportRequestProto

// required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
inline bool ErrorReportRequestProto::has_registration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorReportRequestProto::set_has_registration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorReportRequestProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& ErrorReportRequestProto::_internal_registration() const {
  return *registration_;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& ErrorReportRequestProto::registration() const {
  const ::hadoop::hdfs::NamenodeRegistrationProto* p = registration_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.ErrorReportRequestProto.registration)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamenodeRegistrationProto*>(
      &::hadoop::hdfs::_NamenodeRegistrationProto_default_instance_);
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* ErrorReportRequestProto::release_registration() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.ErrorReportRequestProto.registration)
  clear_has_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* ErrorReportRequestProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamenodeRegistrationProto>(GetArenaNoVirtual());
    registration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.ErrorReportRequestProto.registration)
  return registration_;
}
inline void ErrorReportRequestProto::set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(registration_);
  }
  if (registration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      registration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    set_has_registration();
  } else {
    clear_has_registration();
  }
  registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.ErrorReportRequestProto.registration)
}

// required uint32 errorCode = 2;
inline bool ErrorReportRequestProto::has_errorcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ErrorReportRequestProto::set_has_errorcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ErrorReportRequestProto::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ErrorReportRequestProto::clear_errorcode() {
  errorcode_ = 0u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 ErrorReportRequestProto::errorcode() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.ErrorReportRequestProto.errorCode)
  return errorcode_;
}
inline void ErrorReportRequestProto::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.ErrorReportRequestProto.errorCode)
}

// required string msg = 3;
inline bool ErrorReportRequestProto::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorReportRequestProto::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorReportRequestProto::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorReportRequestProto::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
inline const ::std::string& ErrorReportRequestProto::msg() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
  return msg_.GetNoArena();
}
inline void ErrorReportRequestProto::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
}
#if LANG_CXX11
inline void ErrorReportRequestProto::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
}
#endif
inline void ErrorReportRequestProto::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
}
inline void ErrorReportRequestProto::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
}
inline ::std::string* ErrorReportRequestProto::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorReportRequestProto::release_msg() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
  if (!has_msg()) {
    return NULL;
  }
  clear_has_msg();
  return msg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorReportRequestProto::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.ErrorReportRequestProto.msg)
}

// -------------------------------------------------------------------

// ErrorReportResponseProto

// -------------------------------------------------------------------

// RegisterRequestProto

// required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
inline bool RegisterRequestProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequestProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequestProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& RegisterRequestProto::_internal_registration() const {
  return *registration_;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& RegisterRequestProto::registration() const {
  const ::hadoop::hdfs::NamenodeRegistrationProto* p = registration_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.RegisterRequestProto.registration)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamenodeRegistrationProto*>(
      &::hadoop::hdfs::_NamenodeRegistrationProto_default_instance_);
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* RegisterRequestProto::release_registration() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.RegisterRequestProto.registration)
  clear_has_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* RegisterRequestProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamenodeRegistrationProto>(GetArenaNoVirtual());
    registration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.RegisterRequestProto.registration)
  return registration_;
}
inline void RegisterRequestProto::set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(registration_);
  }
  if (registration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      registration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    set_has_registration();
  } else {
    clear_has_registration();
  }
  registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.RegisterRequestProto.registration)
}

// -------------------------------------------------------------------

// RegisterResponseProto

// required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
inline bool RegisterResponseProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponseProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponseProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& RegisterResponseProto::_internal_registration() const {
  return *registration_;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& RegisterResponseProto::registration() const {
  const ::hadoop::hdfs::NamenodeRegistrationProto* p = registration_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.RegisterResponseProto.registration)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamenodeRegistrationProto*>(
      &::hadoop::hdfs::_NamenodeRegistrationProto_default_instance_);
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* RegisterResponseProto::release_registration() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.RegisterResponseProto.registration)
  clear_has_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* RegisterResponseProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamenodeRegistrationProto>(GetArenaNoVirtual());
    registration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.RegisterResponseProto.registration)
  return registration_;
}
inline void RegisterResponseProto::set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(registration_);
  }
  if (registration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      registration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    set_has_registration();
  } else {
    clear_has_registration();
  }
  registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.RegisterResponseProto.registration)
}

// -------------------------------------------------------------------

// StartCheckpointRequestProto

// required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
inline bool StartCheckpointRequestProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartCheckpointRequestProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartCheckpointRequestProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& StartCheckpointRequestProto::_internal_registration() const {
  return *registration_;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& StartCheckpointRequestProto::registration() const {
  const ::hadoop::hdfs::NamenodeRegistrationProto* p = registration_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.StartCheckpointRequestProto.registration)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamenodeRegistrationProto*>(
      &::hadoop::hdfs::_NamenodeRegistrationProto_default_instance_);
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* StartCheckpointRequestProto::release_registration() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.StartCheckpointRequestProto.registration)
  clear_has_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* StartCheckpointRequestProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamenodeRegistrationProto>(GetArenaNoVirtual());
    registration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.StartCheckpointRequestProto.registration)
  return registration_;
}
inline void StartCheckpointRequestProto::set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(registration_);
  }
  if (registration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      registration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    set_has_registration();
  } else {
    clear_has_registration();
  }
  registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.StartCheckpointRequestProto.registration)
}

// -------------------------------------------------------------------

// StartCheckpointResponseProto

// required .hadoop.hdfs.NamenodeCommandProto command = 1;
inline bool StartCheckpointResponseProto::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartCheckpointResponseProto::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartCheckpointResponseProto::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::NamenodeCommandProto& StartCheckpointResponseProto::_internal_command() const {
  return *command_;
}
inline const ::hadoop::hdfs::NamenodeCommandProto& StartCheckpointResponseProto::command() const {
  const ::hadoop::hdfs::NamenodeCommandProto* p = command_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.StartCheckpointResponseProto.command)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamenodeCommandProto*>(
      &::hadoop::hdfs::_NamenodeCommandProto_default_instance_);
}
inline ::hadoop::hdfs::NamenodeCommandProto* StartCheckpointResponseProto::release_command() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.StartCheckpointResponseProto.command)
  clear_has_command();
  ::hadoop::hdfs::NamenodeCommandProto* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamenodeCommandProto* StartCheckpointResponseProto::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamenodeCommandProto>(GetArenaNoVirtual());
    command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.StartCheckpointResponseProto.command)
  return command_;
}
inline void StartCheckpointResponseProto::set_allocated_command(::hadoop::hdfs::NamenodeCommandProto* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(command_);
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.StartCheckpointResponseProto.command)
}

// -------------------------------------------------------------------

// EndCheckpointRequestProto

// required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;
inline bool EndCheckpointRequestProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndCheckpointRequestProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndCheckpointRequestProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& EndCheckpointRequestProto::_internal_registration() const {
  return *registration_;
}
inline const ::hadoop::hdfs::NamenodeRegistrationProto& EndCheckpointRequestProto::registration() const {
  const ::hadoop::hdfs::NamenodeRegistrationProto* p = registration_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.EndCheckpointRequestProto.registration)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamenodeRegistrationProto*>(
      &::hadoop::hdfs::_NamenodeRegistrationProto_default_instance_);
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* EndCheckpointRequestProto::release_registration() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.EndCheckpointRequestProto.registration)
  clear_has_registration();
  ::hadoop::hdfs::NamenodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamenodeRegistrationProto* EndCheckpointRequestProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamenodeRegistrationProto>(GetArenaNoVirtual());
    registration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.EndCheckpointRequestProto.registration)
  return registration_;
}
inline void EndCheckpointRequestProto::set_allocated_registration(::hadoop::hdfs::NamenodeRegistrationProto* registration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(registration_);
  }
  if (registration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      registration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    set_has_registration();
  } else {
    clear_has_registration();
  }
  registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.EndCheckpointRequestProto.registration)
}

// required .hadoop.hdfs.CheckpointSignatureProto signature = 2;
inline bool EndCheckpointRequestProto::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndCheckpointRequestProto::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndCheckpointRequestProto::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hadoop::hdfs::CheckpointSignatureProto& EndCheckpointRequestProto::_internal_signature() const {
  return *signature_;
}
inline const ::hadoop::hdfs::CheckpointSignatureProto& EndCheckpointRequestProto::signature() const {
  const ::hadoop::hdfs::CheckpointSignatureProto* p = signature_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.EndCheckpointRequestProto.signature)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::CheckpointSignatureProto*>(
      &::hadoop::hdfs::_CheckpointSignatureProto_default_instance_);
}
inline ::hadoop::hdfs::CheckpointSignatureProto* EndCheckpointRequestProto::release_signature() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.EndCheckpointRequestProto.signature)
  clear_has_signature();
  ::hadoop::hdfs::CheckpointSignatureProto* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::CheckpointSignatureProto* EndCheckpointRequestProto::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::CheckpointSignatureProto>(GetArenaNoVirtual());
    signature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.EndCheckpointRequestProto.signature)
  return signature_;
}
inline void EndCheckpointRequestProto::set_allocated_signature(::hadoop::hdfs::CheckpointSignatureProto* signature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(signature_);
  }
  if (signature) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.EndCheckpointRequestProto.signature)
}

// -------------------------------------------------------------------

// EndCheckpointResponseProto

// -------------------------------------------------------------------

// GetEditLogManifestRequestProto

// required uint64 sinceTxId = 1;
inline bool GetEditLogManifestRequestProto::has_sincetxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEditLogManifestRequestProto::set_has_sincetxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEditLogManifestRequestProto::clear_has_sincetxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEditLogManifestRequestProto::clear_sincetxid() {
  sincetxid_ = GOOGLE_ULONGLONG(0);
  clear_has_sincetxid();
}
inline ::google::protobuf::uint64 GetEditLogManifestRequestProto::sincetxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetEditLogManifestRequestProto.sinceTxId)
  return sincetxid_;
}
inline void GetEditLogManifestRequestProto::set_sincetxid(::google::protobuf::uint64 value) {
  set_has_sincetxid();
  sincetxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetEditLogManifestRequestProto.sinceTxId)
}

// -------------------------------------------------------------------

// GetEditLogManifestResponseProto

// required .hadoop.hdfs.RemoteEditLogManifestProto manifest = 1;
inline bool GetEditLogManifestResponseProto::has_manifest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEditLogManifestResponseProto::set_has_manifest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEditLogManifestResponseProto::clear_has_manifest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::RemoteEditLogManifestProto& GetEditLogManifestResponseProto::_internal_manifest() const {
  return *manifest_;
}
inline const ::hadoop::hdfs::RemoteEditLogManifestProto& GetEditLogManifestResponseProto::manifest() const {
  const ::hadoop::hdfs::RemoteEditLogManifestProto* p = manifest_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetEditLogManifestResponseProto.manifest)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::RemoteEditLogManifestProto*>(
      &::hadoop::hdfs::_RemoteEditLogManifestProto_default_instance_);
}
inline ::hadoop::hdfs::RemoteEditLogManifestProto* GetEditLogManifestResponseProto::release_manifest() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.GetEditLogManifestResponseProto.manifest)
  clear_has_manifest();
  ::hadoop::hdfs::RemoteEditLogManifestProto* temp = manifest_;
  manifest_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::RemoteEditLogManifestProto* GetEditLogManifestResponseProto::mutable_manifest() {
  set_has_manifest();
  if (manifest_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::RemoteEditLogManifestProto>(GetArenaNoVirtual());
    manifest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.GetEditLogManifestResponseProto.manifest)
  return manifest_;
}
inline void GetEditLogManifestResponseProto::set_allocated_manifest(::hadoop::hdfs::RemoteEditLogManifestProto* manifest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(manifest_);
  }
  if (manifest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      manifest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, manifest, submessage_arena);
    }
    set_has_manifest();
  } else {
    clear_has_manifest();
  }
  manifest_ = manifest;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.GetEditLogManifestResponseProto.manifest)
}

// -------------------------------------------------------------------

// IsUpgradeFinalizedRequestProto

// -------------------------------------------------------------------

// IsUpgradeFinalizedResponseProto

// required bool isUpgradeFinalized = 1;
inline bool IsUpgradeFinalizedResponseProto::has_isupgradefinalized() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsUpgradeFinalizedResponseProto::set_has_isupgradefinalized() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsUpgradeFinalizedResponseProto::clear_has_isupgradefinalized() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsUpgradeFinalizedResponseProto::clear_isupgradefinalized() {
  isupgradefinalized_ = false;
  clear_has_isupgradefinalized();
}
inline bool IsUpgradeFinalizedResponseProto::isupgradefinalized() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.IsUpgradeFinalizedResponseProto.isUpgradeFinalized)
  return isupgradefinalized_;
}
inline void IsUpgradeFinalizedResponseProto::set_isupgradefinalized(bool value) {
  set_has_isupgradefinalized();
  isupgradefinalized_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.IsUpgradeFinalizedResponseProto.isUpgradeFinalized)
}

// -------------------------------------------------------------------

// IsRollingUpgradeRequestProto

// -------------------------------------------------------------------

// IsRollingUpgradeResponseProto

// required bool isRollingUpgrade = 1;
inline bool IsRollingUpgradeResponseProto::has_isrollingupgrade() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsRollingUpgradeResponseProto::set_has_isrollingupgrade() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsRollingUpgradeResponseProto::clear_has_isrollingupgrade() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsRollingUpgradeResponseProto::clear_isrollingupgrade() {
  isrollingupgrade_ = false;
  clear_has_isrollingupgrade();
}
inline bool IsRollingUpgradeResponseProto::isrollingupgrade() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.IsRollingUpgradeResponseProto.isRollingUpgrade)
  return isrollingupgrade_;
}
inline void IsRollingUpgradeResponseProto::set_isrollingupgrade(bool value) {
  set_has_isrollingupgrade();
  isrollingupgrade_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.IsRollingUpgradeResponseProto.isRollingUpgrade)
}

// -------------------------------------------------------------------

// GetFilePathRequestProto

// required uint64 fileId = 1;
inline bool GetFilePathRequestProto::has_fileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFilePathRequestProto::set_has_fileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFilePathRequestProto::clear_has_fileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFilePathRequestProto::clear_fileid() {
  fileid_ = GOOGLE_ULONGLONG(0);
  clear_has_fileid();
}
inline ::google::protobuf::uint64 GetFilePathRequestProto::fileid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetFilePathRequestProto.fileId)
  return fileid_;
}
inline void GetFilePathRequestProto::set_fileid(::google::protobuf::uint64 value) {
  set_has_fileid();
  fileid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetFilePathRequestProto.fileId)
}

// -------------------------------------------------------------------

// GetFilePathResponseProto

// required string srcPath = 1;
inline bool GetFilePathResponseProto::has_srcpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFilePathResponseProto::set_has_srcpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFilePathResponseProto::clear_has_srcpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFilePathResponseProto::clear_srcpath() {
  srcpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_srcpath();
}
inline const ::std::string& GetFilePathResponseProto::srcpath() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
  return srcpath_.GetNoArena();
}
inline void GetFilePathResponseProto::set_srcpath(const ::std::string& value) {
  set_has_srcpath();
  srcpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
}
#if LANG_CXX11
inline void GetFilePathResponseProto::set_srcpath(::std::string&& value) {
  set_has_srcpath();
  srcpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
}
#endif
inline void GetFilePathResponseProto::set_srcpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_srcpath();
  srcpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
}
inline void GetFilePathResponseProto::set_srcpath(const char* value, size_t size) {
  set_has_srcpath();
  srcpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
}
inline ::std::string* GetFilePathResponseProto::mutable_srcpath() {
  set_has_srcpath();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
  return srcpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetFilePathResponseProto::release_srcpath() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
  if (!has_srcpath()) {
    return NULL;
  }
  clear_has_srcpath();
  return srcpath_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetFilePathResponseProto::set_allocated_srcpath(::std::string* srcpath) {
  if (srcpath != NULL) {
    set_has_srcpath();
  } else {
    clear_has_srcpath();
  }
  srcpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), srcpath);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.namenode.GetFilePathResponseProto.srcPath)
}

// -------------------------------------------------------------------

// GetNextSPSPathRequestProto

// -------------------------------------------------------------------

// GetNextSPSPathResponseProto

// optional uint64 spsPath = 1;
inline bool GetNextSPSPathResponseProto::has_spspath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNextSPSPathResponseProto::set_has_spspath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNextSPSPathResponseProto::clear_has_spspath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNextSPSPathResponseProto::clear_spspath() {
  spspath_ = GOOGLE_ULONGLONG(0);
  clear_has_spspath();
}
inline ::google::protobuf::uint64 GetNextSPSPathResponseProto::spspath() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.namenode.GetNextSPSPathResponseProto.spsPath)
  return spspath_;
}
inline void GetNextSPSPathResponseProto::set_spspath(::google::protobuf::uint64 value) {
  set_has_spspath();
  spspath_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.namenode.GetNextSPSPathResponseProto.spsPath)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace namenode
}  // namespace hdfs
}  // namespace hadoop

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_NamenodeProtocol_2eproto
