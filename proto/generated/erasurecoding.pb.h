// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: erasurecoding.proto

#ifndef PROTOBUF_INCLUDED_erasurecoding_2eproto
#define PROTOBUF_INCLUDED_erasurecoding_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "hdfs.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_erasurecoding_2eproto 

namespace protobuf_erasurecoding_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_erasurecoding_2eproto
namespace hadoop {
namespace hdfs {
class AddErasureCodingPoliciesRequestProto;
class AddErasureCodingPoliciesRequestProtoDefaultTypeInternal;
extern AddErasureCodingPoliciesRequestProtoDefaultTypeInternal _AddErasureCodingPoliciesRequestProto_default_instance_;
class AddErasureCodingPoliciesResponseProto;
class AddErasureCodingPoliciesResponseProtoDefaultTypeInternal;
extern AddErasureCodingPoliciesResponseProtoDefaultTypeInternal _AddErasureCodingPoliciesResponseProto_default_instance_;
class BlockECReconstructionInfoProto;
class BlockECReconstructionInfoProtoDefaultTypeInternal;
extern BlockECReconstructionInfoProtoDefaultTypeInternal _BlockECReconstructionInfoProto_default_instance_;
class CodecProto;
class CodecProtoDefaultTypeInternal;
extern CodecProtoDefaultTypeInternal _CodecProto_default_instance_;
class DisableErasureCodingPolicyRequestProto;
class DisableErasureCodingPolicyRequestProtoDefaultTypeInternal;
extern DisableErasureCodingPolicyRequestProtoDefaultTypeInternal _DisableErasureCodingPolicyRequestProto_default_instance_;
class DisableErasureCodingPolicyResponseProto;
class DisableErasureCodingPolicyResponseProtoDefaultTypeInternal;
extern DisableErasureCodingPolicyResponseProtoDefaultTypeInternal _DisableErasureCodingPolicyResponseProto_default_instance_;
class EnableErasureCodingPolicyRequestProto;
class EnableErasureCodingPolicyRequestProtoDefaultTypeInternal;
extern EnableErasureCodingPolicyRequestProtoDefaultTypeInternal _EnableErasureCodingPolicyRequestProto_default_instance_;
class EnableErasureCodingPolicyResponseProto;
class EnableErasureCodingPolicyResponseProtoDefaultTypeInternal;
extern EnableErasureCodingPolicyResponseProtoDefaultTypeInternal _EnableErasureCodingPolicyResponseProto_default_instance_;
class GetECTopologyResultForPoliciesRequestProto;
class GetECTopologyResultForPoliciesRequestProtoDefaultTypeInternal;
extern GetECTopologyResultForPoliciesRequestProtoDefaultTypeInternal _GetECTopologyResultForPoliciesRequestProto_default_instance_;
class GetECTopologyResultForPoliciesResponseProto;
class GetECTopologyResultForPoliciesResponseProtoDefaultTypeInternal;
extern GetECTopologyResultForPoliciesResponseProtoDefaultTypeInternal _GetECTopologyResultForPoliciesResponseProto_default_instance_;
class GetErasureCodingCodecsRequestProto;
class GetErasureCodingCodecsRequestProtoDefaultTypeInternal;
extern GetErasureCodingCodecsRequestProtoDefaultTypeInternal _GetErasureCodingCodecsRequestProto_default_instance_;
class GetErasureCodingCodecsResponseProto;
class GetErasureCodingCodecsResponseProtoDefaultTypeInternal;
extern GetErasureCodingCodecsResponseProtoDefaultTypeInternal _GetErasureCodingCodecsResponseProto_default_instance_;
class GetErasureCodingPoliciesRequestProto;
class GetErasureCodingPoliciesRequestProtoDefaultTypeInternal;
extern GetErasureCodingPoliciesRequestProtoDefaultTypeInternal _GetErasureCodingPoliciesRequestProto_default_instance_;
class GetErasureCodingPoliciesResponseProto;
class GetErasureCodingPoliciesResponseProtoDefaultTypeInternal;
extern GetErasureCodingPoliciesResponseProtoDefaultTypeInternal _GetErasureCodingPoliciesResponseProto_default_instance_;
class GetErasureCodingPolicyRequestProto;
class GetErasureCodingPolicyRequestProtoDefaultTypeInternal;
extern GetErasureCodingPolicyRequestProtoDefaultTypeInternal _GetErasureCodingPolicyRequestProto_default_instance_;
class GetErasureCodingPolicyResponseProto;
class GetErasureCodingPolicyResponseProtoDefaultTypeInternal;
extern GetErasureCodingPolicyResponseProtoDefaultTypeInternal _GetErasureCodingPolicyResponseProto_default_instance_;
class RemoveErasureCodingPolicyRequestProto;
class RemoveErasureCodingPolicyRequestProtoDefaultTypeInternal;
extern RemoveErasureCodingPolicyRequestProtoDefaultTypeInternal _RemoveErasureCodingPolicyRequestProto_default_instance_;
class RemoveErasureCodingPolicyResponseProto;
class RemoveErasureCodingPolicyResponseProtoDefaultTypeInternal;
extern RemoveErasureCodingPolicyResponseProtoDefaultTypeInternal _RemoveErasureCodingPolicyResponseProto_default_instance_;
class SetErasureCodingPolicyRequestProto;
class SetErasureCodingPolicyRequestProtoDefaultTypeInternal;
extern SetErasureCodingPolicyRequestProtoDefaultTypeInternal _SetErasureCodingPolicyRequestProto_default_instance_;
class SetErasureCodingPolicyResponseProto;
class SetErasureCodingPolicyResponseProtoDefaultTypeInternal;
extern SetErasureCodingPolicyResponseProtoDefaultTypeInternal _SetErasureCodingPolicyResponseProto_default_instance_;
class UnsetErasureCodingPolicyRequestProto;
class UnsetErasureCodingPolicyRequestProtoDefaultTypeInternal;
extern UnsetErasureCodingPolicyRequestProtoDefaultTypeInternal _UnsetErasureCodingPolicyRequestProto_default_instance_;
class UnsetErasureCodingPolicyResponseProto;
class UnsetErasureCodingPolicyResponseProtoDefaultTypeInternal;
extern UnsetErasureCodingPolicyResponseProtoDefaultTypeInternal _UnsetErasureCodingPolicyResponseProto_default_instance_;
}  // namespace hdfs
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::hdfs::AddErasureCodingPoliciesRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::AddErasureCodingPoliciesRequestProto>(Arena*);
template<> ::hadoop::hdfs::AddErasureCodingPoliciesResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::AddErasureCodingPoliciesResponseProto>(Arena*);
template<> ::hadoop::hdfs::BlockECReconstructionInfoProto* Arena::CreateMaybeMessage<::hadoop::hdfs::BlockECReconstructionInfoProto>(Arena*);
template<> ::hadoop::hdfs::CodecProto* Arena::CreateMaybeMessage<::hadoop::hdfs::CodecProto>(Arena*);
template<> ::hadoop::hdfs::DisableErasureCodingPolicyRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::DisableErasureCodingPolicyRequestProto>(Arena*);
template<> ::hadoop::hdfs::DisableErasureCodingPolicyResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::DisableErasureCodingPolicyResponseProto>(Arena*);
template<> ::hadoop::hdfs::EnableErasureCodingPolicyRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::EnableErasureCodingPolicyRequestProto>(Arena*);
template<> ::hadoop::hdfs::EnableErasureCodingPolicyResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::EnableErasureCodingPolicyResponseProto>(Arena*);
template<> ::hadoop::hdfs::GetECTopologyResultForPoliciesRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetECTopologyResultForPoliciesRequestProto>(Arena*);
template<> ::hadoop::hdfs::GetECTopologyResultForPoliciesResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetECTopologyResultForPoliciesResponseProto>(Arena*);
template<> ::hadoop::hdfs::GetErasureCodingCodecsRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetErasureCodingCodecsRequestProto>(Arena*);
template<> ::hadoop::hdfs::GetErasureCodingCodecsResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetErasureCodingCodecsResponseProto>(Arena*);
template<> ::hadoop::hdfs::GetErasureCodingPoliciesRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetErasureCodingPoliciesRequestProto>(Arena*);
template<> ::hadoop::hdfs::GetErasureCodingPoliciesResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetErasureCodingPoliciesResponseProto>(Arena*);
template<> ::hadoop::hdfs::GetErasureCodingPolicyRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetErasureCodingPolicyRequestProto>(Arena*);
template<> ::hadoop::hdfs::GetErasureCodingPolicyResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetErasureCodingPolicyResponseProto>(Arena*);
template<> ::hadoop::hdfs::RemoveErasureCodingPolicyRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::RemoveErasureCodingPolicyRequestProto>(Arena*);
template<> ::hadoop::hdfs::RemoveErasureCodingPolicyResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::RemoveErasureCodingPolicyResponseProto>(Arena*);
template<> ::hadoop::hdfs::SetErasureCodingPolicyRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::SetErasureCodingPolicyRequestProto>(Arena*);
template<> ::hadoop::hdfs::SetErasureCodingPolicyResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::SetErasureCodingPolicyResponseProto>(Arena*);
template<> ::hadoop::hdfs::UnsetErasureCodingPolicyRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::UnsetErasureCodingPolicyRequestProto>(Arena*);
template<> ::hadoop::hdfs::UnsetErasureCodingPolicyResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::UnsetErasureCodingPolicyResponseProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace hdfs {

// ===================================================================

class SetErasureCodingPolicyRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.SetErasureCodingPolicyRequestProto) */ {
 public:
  SetErasureCodingPolicyRequestProto();
  virtual ~SetErasureCodingPolicyRequestProto();

  SetErasureCodingPolicyRequestProto(const SetErasureCodingPolicyRequestProto& from);

  inline SetErasureCodingPolicyRequestProto& operator=(const SetErasureCodingPolicyRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetErasureCodingPolicyRequestProto(SetErasureCodingPolicyRequestProto&& from) noexcept
    : SetErasureCodingPolicyRequestProto() {
    *this = ::std::move(from);
  }

  inline SetErasureCodingPolicyRequestProto& operator=(SetErasureCodingPolicyRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetErasureCodingPolicyRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetErasureCodingPolicyRequestProto* internal_default_instance() {
    return reinterpret_cast<const SetErasureCodingPolicyRequestProto*>(
               &_SetErasureCodingPolicyRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SetErasureCodingPolicyRequestProto* other);
  friend void swap(SetErasureCodingPolicyRequestProto& a, SetErasureCodingPolicyRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetErasureCodingPolicyRequestProto* New() const final {
    return CreateMaybeMessage<SetErasureCodingPolicyRequestProto>(NULL);
  }

  SetErasureCodingPolicyRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetErasureCodingPolicyRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetErasureCodingPolicyRequestProto& from);
  void MergeFrom(const SetErasureCodingPolicyRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetErasureCodingPolicyRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // optional string ecPolicyName = 2;
  bool has_ecpolicyname() const;
  void clear_ecpolicyname();
  static const int kEcPolicyNameFieldNumber = 2;
  const ::std::string& ecpolicyname() const;
  void set_ecpolicyname(const ::std::string& value);
  #if LANG_CXX11
  void set_ecpolicyname(::std::string&& value);
  #endif
  void set_ecpolicyname(const char* value);
  void set_ecpolicyname(const char* value, size_t size);
  ::std::string* mutable_ecpolicyname();
  ::std::string* release_ecpolicyname();
  void set_allocated_ecpolicyname(::std::string* ecpolicyname);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.SetErasureCodingPolicyRequestProto)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_ecpolicyname();
  void clear_has_ecpolicyname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  ::google::protobuf::internal::ArenaStringPtr ecpolicyname_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetErasureCodingPolicyResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.SetErasureCodingPolicyResponseProto) */ {
 public:
  SetErasureCodingPolicyResponseProto();
  virtual ~SetErasureCodingPolicyResponseProto();

  SetErasureCodingPolicyResponseProto(const SetErasureCodingPolicyResponseProto& from);

  inline SetErasureCodingPolicyResponseProto& operator=(const SetErasureCodingPolicyResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetErasureCodingPolicyResponseProto(SetErasureCodingPolicyResponseProto&& from) noexcept
    : SetErasureCodingPolicyResponseProto() {
    *this = ::std::move(from);
  }

  inline SetErasureCodingPolicyResponseProto& operator=(SetErasureCodingPolicyResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetErasureCodingPolicyResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetErasureCodingPolicyResponseProto* internal_default_instance() {
    return reinterpret_cast<const SetErasureCodingPolicyResponseProto*>(
               &_SetErasureCodingPolicyResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SetErasureCodingPolicyResponseProto* other);
  friend void swap(SetErasureCodingPolicyResponseProto& a, SetErasureCodingPolicyResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetErasureCodingPolicyResponseProto* New() const final {
    return CreateMaybeMessage<SetErasureCodingPolicyResponseProto>(NULL);
  }

  SetErasureCodingPolicyResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetErasureCodingPolicyResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetErasureCodingPolicyResponseProto& from);
  void MergeFrom(const SetErasureCodingPolicyResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetErasureCodingPolicyResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.SetErasureCodingPolicyResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetErasureCodingPoliciesRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetErasureCodingPoliciesRequestProto) */ {
 public:
  GetErasureCodingPoliciesRequestProto();
  virtual ~GetErasureCodingPoliciesRequestProto();

  GetErasureCodingPoliciesRequestProto(const GetErasureCodingPoliciesRequestProto& from);

  inline GetErasureCodingPoliciesRequestProto& operator=(const GetErasureCodingPoliciesRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetErasureCodingPoliciesRequestProto(GetErasureCodingPoliciesRequestProto&& from) noexcept
    : GetErasureCodingPoliciesRequestProto() {
    *this = ::std::move(from);
  }

  inline GetErasureCodingPoliciesRequestProto& operator=(GetErasureCodingPoliciesRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetErasureCodingPoliciesRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetErasureCodingPoliciesRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetErasureCodingPoliciesRequestProto*>(
               &_GetErasureCodingPoliciesRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetErasureCodingPoliciesRequestProto* other);
  friend void swap(GetErasureCodingPoliciesRequestProto& a, GetErasureCodingPoliciesRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetErasureCodingPoliciesRequestProto* New() const final {
    return CreateMaybeMessage<GetErasureCodingPoliciesRequestProto>(NULL);
  }

  GetErasureCodingPoliciesRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetErasureCodingPoliciesRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetErasureCodingPoliciesRequestProto& from);
  void MergeFrom(const GetErasureCodingPoliciesRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetErasureCodingPoliciesRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetErasureCodingPoliciesRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetErasureCodingPoliciesResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetErasureCodingPoliciesResponseProto) */ {
 public:
  GetErasureCodingPoliciesResponseProto();
  virtual ~GetErasureCodingPoliciesResponseProto();

  GetErasureCodingPoliciesResponseProto(const GetErasureCodingPoliciesResponseProto& from);

  inline GetErasureCodingPoliciesResponseProto& operator=(const GetErasureCodingPoliciesResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetErasureCodingPoliciesResponseProto(GetErasureCodingPoliciesResponseProto&& from) noexcept
    : GetErasureCodingPoliciesResponseProto() {
    *this = ::std::move(from);
  }

  inline GetErasureCodingPoliciesResponseProto& operator=(GetErasureCodingPoliciesResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetErasureCodingPoliciesResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetErasureCodingPoliciesResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetErasureCodingPoliciesResponseProto*>(
               &_GetErasureCodingPoliciesResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetErasureCodingPoliciesResponseProto* other);
  friend void swap(GetErasureCodingPoliciesResponseProto& a, GetErasureCodingPoliciesResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetErasureCodingPoliciesResponseProto* New() const final {
    return CreateMaybeMessage<GetErasureCodingPoliciesResponseProto>(NULL);
  }

  GetErasureCodingPoliciesResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetErasureCodingPoliciesResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetErasureCodingPoliciesResponseProto& from);
  void MergeFrom(const GetErasureCodingPoliciesResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetErasureCodingPoliciesResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.ErasureCodingPolicyProto ecPolicies = 1;
  int ecpolicies_size() const;
  void clear_ecpolicies();
  static const int kEcPoliciesFieldNumber = 1;
  ::hadoop::hdfs::ErasureCodingPolicyProto* mutable_ecpolicies(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >*
      mutable_ecpolicies();
  const ::hadoop::hdfs::ErasureCodingPolicyProto& ecpolicies(int index) const;
  ::hadoop::hdfs::ErasureCodingPolicyProto* add_ecpolicies();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >&
      ecpolicies() const;

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetErasureCodingPoliciesResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto > ecpolicies_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetErasureCodingCodecsRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetErasureCodingCodecsRequestProto) */ {
 public:
  GetErasureCodingCodecsRequestProto();
  virtual ~GetErasureCodingCodecsRequestProto();

  GetErasureCodingCodecsRequestProto(const GetErasureCodingCodecsRequestProto& from);

  inline GetErasureCodingCodecsRequestProto& operator=(const GetErasureCodingCodecsRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetErasureCodingCodecsRequestProto(GetErasureCodingCodecsRequestProto&& from) noexcept
    : GetErasureCodingCodecsRequestProto() {
    *this = ::std::move(from);
  }

  inline GetErasureCodingCodecsRequestProto& operator=(GetErasureCodingCodecsRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetErasureCodingCodecsRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetErasureCodingCodecsRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetErasureCodingCodecsRequestProto*>(
               &_GetErasureCodingCodecsRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetErasureCodingCodecsRequestProto* other);
  friend void swap(GetErasureCodingCodecsRequestProto& a, GetErasureCodingCodecsRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetErasureCodingCodecsRequestProto* New() const final {
    return CreateMaybeMessage<GetErasureCodingCodecsRequestProto>(NULL);
  }

  GetErasureCodingCodecsRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetErasureCodingCodecsRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetErasureCodingCodecsRequestProto& from);
  void MergeFrom(const GetErasureCodingCodecsRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetErasureCodingCodecsRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetErasureCodingCodecsRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetErasureCodingCodecsResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetErasureCodingCodecsResponseProto) */ {
 public:
  GetErasureCodingCodecsResponseProto();
  virtual ~GetErasureCodingCodecsResponseProto();

  GetErasureCodingCodecsResponseProto(const GetErasureCodingCodecsResponseProto& from);

  inline GetErasureCodingCodecsResponseProto& operator=(const GetErasureCodingCodecsResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetErasureCodingCodecsResponseProto(GetErasureCodingCodecsResponseProto&& from) noexcept
    : GetErasureCodingCodecsResponseProto() {
    *this = ::std::move(from);
  }

  inline GetErasureCodingCodecsResponseProto& operator=(GetErasureCodingCodecsResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetErasureCodingCodecsResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetErasureCodingCodecsResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetErasureCodingCodecsResponseProto*>(
               &_GetErasureCodingCodecsResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetErasureCodingCodecsResponseProto* other);
  friend void swap(GetErasureCodingCodecsResponseProto& a, GetErasureCodingCodecsResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetErasureCodingCodecsResponseProto* New() const final {
    return CreateMaybeMessage<GetErasureCodingCodecsResponseProto>(NULL);
  }

  GetErasureCodingCodecsResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetErasureCodingCodecsResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetErasureCodingCodecsResponseProto& from);
  void MergeFrom(const GetErasureCodingCodecsResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetErasureCodingCodecsResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.CodecProto codec = 1;
  int codec_size() const;
  void clear_codec();
  static const int kCodecFieldNumber = 1;
  ::hadoop::hdfs::CodecProto* mutable_codec(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::CodecProto >*
      mutable_codec();
  const ::hadoop::hdfs::CodecProto& codec(int index) const;
  ::hadoop::hdfs::CodecProto* add_codec();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::CodecProto >&
      codec() const;

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetErasureCodingCodecsResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::CodecProto > codec_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetErasureCodingPolicyRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetErasureCodingPolicyRequestProto) */ {
 public:
  GetErasureCodingPolicyRequestProto();
  virtual ~GetErasureCodingPolicyRequestProto();

  GetErasureCodingPolicyRequestProto(const GetErasureCodingPolicyRequestProto& from);

  inline GetErasureCodingPolicyRequestProto& operator=(const GetErasureCodingPolicyRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetErasureCodingPolicyRequestProto(GetErasureCodingPolicyRequestProto&& from) noexcept
    : GetErasureCodingPolicyRequestProto() {
    *this = ::std::move(from);
  }

  inline GetErasureCodingPolicyRequestProto& operator=(GetErasureCodingPolicyRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetErasureCodingPolicyRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetErasureCodingPolicyRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetErasureCodingPolicyRequestProto*>(
               &_GetErasureCodingPolicyRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetErasureCodingPolicyRequestProto* other);
  friend void swap(GetErasureCodingPolicyRequestProto& a, GetErasureCodingPolicyRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetErasureCodingPolicyRequestProto* New() const final {
    return CreateMaybeMessage<GetErasureCodingPolicyRequestProto>(NULL);
  }

  GetErasureCodingPolicyRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetErasureCodingPolicyRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetErasureCodingPolicyRequestProto& from);
  void MergeFrom(const GetErasureCodingPolicyRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetErasureCodingPolicyRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetErasureCodingPolicyRequestProto)
 private:
  void set_has_src();
  void clear_has_src();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetErasureCodingPolicyResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetErasureCodingPolicyResponseProto) */ {
 public:
  GetErasureCodingPolicyResponseProto();
  virtual ~GetErasureCodingPolicyResponseProto();

  GetErasureCodingPolicyResponseProto(const GetErasureCodingPolicyResponseProto& from);

  inline GetErasureCodingPolicyResponseProto& operator=(const GetErasureCodingPolicyResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetErasureCodingPolicyResponseProto(GetErasureCodingPolicyResponseProto&& from) noexcept
    : GetErasureCodingPolicyResponseProto() {
    *this = ::std::move(from);
  }

  inline GetErasureCodingPolicyResponseProto& operator=(GetErasureCodingPolicyResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetErasureCodingPolicyResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetErasureCodingPolicyResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetErasureCodingPolicyResponseProto*>(
               &_GetErasureCodingPolicyResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetErasureCodingPolicyResponseProto* other);
  friend void swap(GetErasureCodingPolicyResponseProto& a, GetErasureCodingPolicyResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetErasureCodingPolicyResponseProto* New() const final {
    return CreateMaybeMessage<GetErasureCodingPolicyResponseProto>(NULL);
  }

  GetErasureCodingPolicyResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetErasureCodingPolicyResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetErasureCodingPolicyResponseProto& from);
  void MergeFrom(const GetErasureCodingPolicyResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetErasureCodingPolicyResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hadoop.hdfs.ErasureCodingPolicyProto ecPolicy = 1;
  bool has_ecpolicy() const;
  void clear_ecpolicy();
  static const int kEcPolicyFieldNumber = 1;
  private:
  const ::hadoop::hdfs::ErasureCodingPolicyProto& _internal_ecpolicy() const;
  public:
  const ::hadoop::hdfs::ErasureCodingPolicyProto& ecpolicy() const;
  ::hadoop::hdfs::ErasureCodingPolicyProto* release_ecpolicy();
  ::hadoop::hdfs::ErasureCodingPolicyProto* mutable_ecpolicy();
  void set_allocated_ecpolicy(::hadoop::hdfs::ErasureCodingPolicyProto* ecpolicy);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetErasureCodingPolicyResponseProto)
 private:
  void set_has_ecpolicy();
  void clear_has_ecpolicy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::ErasureCodingPolicyProto* ecpolicy_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddErasureCodingPoliciesRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.AddErasureCodingPoliciesRequestProto) */ {
 public:
  AddErasureCodingPoliciesRequestProto();
  virtual ~AddErasureCodingPoliciesRequestProto();

  AddErasureCodingPoliciesRequestProto(const AddErasureCodingPoliciesRequestProto& from);

  inline AddErasureCodingPoliciesRequestProto& operator=(const AddErasureCodingPoliciesRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddErasureCodingPoliciesRequestProto(AddErasureCodingPoliciesRequestProto&& from) noexcept
    : AddErasureCodingPoliciesRequestProto() {
    *this = ::std::move(from);
  }

  inline AddErasureCodingPoliciesRequestProto& operator=(AddErasureCodingPoliciesRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddErasureCodingPoliciesRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddErasureCodingPoliciesRequestProto* internal_default_instance() {
    return reinterpret_cast<const AddErasureCodingPoliciesRequestProto*>(
               &_AddErasureCodingPoliciesRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(AddErasureCodingPoliciesRequestProto* other);
  friend void swap(AddErasureCodingPoliciesRequestProto& a, AddErasureCodingPoliciesRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddErasureCodingPoliciesRequestProto* New() const final {
    return CreateMaybeMessage<AddErasureCodingPoliciesRequestProto>(NULL);
  }

  AddErasureCodingPoliciesRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddErasureCodingPoliciesRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddErasureCodingPoliciesRequestProto& from);
  void MergeFrom(const AddErasureCodingPoliciesRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddErasureCodingPoliciesRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.ErasureCodingPolicyProto ecPolicies = 1;
  int ecpolicies_size() const;
  void clear_ecpolicies();
  static const int kEcPoliciesFieldNumber = 1;
  ::hadoop::hdfs::ErasureCodingPolicyProto* mutable_ecpolicies(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >*
      mutable_ecpolicies();
  const ::hadoop::hdfs::ErasureCodingPolicyProto& ecpolicies(int index) const;
  ::hadoop::hdfs::ErasureCodingPolicyProto* add_ecpolicies();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >&
      ecpolicies() const;

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.AddErasureCodingPoliciesRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto > ecpolicies_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddErasureCodingPoliciesResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.AddErasureCodingPoliciesResponseProto) */ {
 public:
  AddErasureCodingPoliciesResponseProto();
  virtual ~AddErasureCodingPoliciesResponseProto();

  AddErasureCodingPoliciesResponseProto(const AddErasureCodingPoliciesResponseProto& from);

  inline AddErasureCodingPoliciesResponseProto& operator=(const AddErasureCodingPoliciesResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddErasureCodingPoliciesResponseProto(AddErasureCodingPoliciesResponseProto&& from) noexcept
    : AddErasureCodingPoliciesResponseProto() {
    *this = ::std::move(from);
  }

  inline AddErasureCodingPoliciesResponseProto& operator=(AddErasureCodingPoliciesResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddErasureCodingPoliciesResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddErasureCodingPoliciesResponseProto* internal_default_instance() {
    return reinterpret_cast<const AddErasureCodingPoliciesResponseProto*>(
               &_AddErasureCodingPoliciesResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AddErasureCodingPoliciesResponseProto* other);
  friend void swap(AddErasureCodingPoliciesResponseProto& a, AddErasureCodingPoliciesResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddErasureCodingPoliciesResponseProto* New() const final {
    return CreateMaybeMessage<AddErasureCodingPoliciesResponseProto>(NULL);
  }

  AddErasureCodingPoliciesResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddErasureCodingPoliciesResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddErasureCodingPoliciesResponseProto& from);
  void MergeFrom(const AddErasureCodingPoliciesResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddErasureCodingPoliciesResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.AddErasureCodingPolicyResponseProto responses = 1;
  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 1;
  ::hadoop::hdfs::AddErasureCodingPolicyResponseProto* mutable_responses(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AddErasureCodingPolicyResponseProto >*
      mutable_responses();
  const ::hadoop::hdfs::AddErasureCodingPolicyResponseProto& responses(int index) const;
  ::hadoop::hdfs::AddErasureCodingPolicyResponseProto* add_responses();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AddErasureCodingPolicyResponseProto >&
      responses() const;

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.AddErasureCodingPoliciesResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AddErasureCodingPolicyResponseProto > responses_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemoveErasureCodingPolicyRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto) */ {
 public:
  RemoveErasureCodingPolicyRequestProto();
  virtual ~RemoveErasureCodingPolicyRequestProto();

  RemoveErasureCodingPolicyRequestProto(const RemoveErasureCodingPolicyRequestProto& from);

  inline RemoveErasureCodingPolicyRequestProto& operator=(const RemoveErasureCodingPolicyRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveErasureCodingPolicyRequestProto(RemoveErasureCodingPolicyRequestProto&& from) noexcept
    : RemoveErasureCodingPolicyRequestProto() {
    *this = ::std::move(from);
  }

  inline RemoveErasureCodingPolicyRequestProto& operator=(RemoveErasureCodingPolicyRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveErasureCodingPolicyRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveErasureCodingPolicyRequestProto* internal_default_instance() {
    return reinterpret_cast<const RemoveErasureCodingPolicyRequestProto*>(
               &_RemoveErasureCodingPolicyRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RemoveErasureCodingPolicyRequestProto* other);
  friend void swap(RemoveErasureCodingPolicyRequestProto& a, RemoveErasureCodingPolicyRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveErasureCodingPolicyRequestProto* New() const final {
    return CreateMaybeMessage<RemoveErasureCodingPolicyRequestProto>(NULL);
  }

  RemoveErasureCodingPolicyRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemoveErasureCodingPolicyRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemoveErasureCodingPolicyRequestProto& from);
  void MergeFrom(const RemoveErasureCodingPolicyRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveErasureCodingPolicyRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ecPolicyName = 1;
  bool has_ecpolicyname() const;
  void clear_ecpolicyname();
  static const int kEcPolicyNameFieldNumber = 1;
  const ::std::string& ecpolicyname() const;
  void set_ecpolicyname(const ::std::string& value);
  #if LANG_CXX11
  void set_ecpolicyname(::std::string&& value);
  #endif
  void set_ecpolicyname(const char* value);
  void set_ecpolicyname(const char* value, size_t size);
  ::std::string* mutable_ecpolicyname();
  ::std::string* release_ecpolicyname();
  void set_allocated_ecpolicyname(::std::string* ecpolicyname);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto)
 private:
  void set_has_ecpolicyname();
  void clear_has_ecpolicyname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ecpolicyname_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemoveErasureCodingPolicyResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.RemoveErasureCodingPolicyResponseProto) */ {
 public:
  RemoveErasureCodingPolicyResponseProto();
  virtual ~RemoveErasureCodingPolicyResponseProto();

  RemoveErasureCodingPolicyResponseProto(const RemoveErasureCodingPolicyResponseProto& from);

  inline RemoveErasureCodingPolicyResponseProto& operator=(const RemoveErasureCodingPolicyResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveErasureCodingPolicyResponseProto(RemoveErasureCodingPolicyResponseProto&& from) noexcept
    : RemoveErasureCodingPolicyResponseProto() {
    *this = ::std::move(from);
  }

  inline RemoveErasureCodingPolicyResponseProto& operator=(RemoveErasureCodingPolicyResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveErasureCodingPolicyResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveErasureCodingPolicyResponseProto* internal_default_instance() {
    return reinterpret_cast<const RemoveErasureCodingPolicyResponseProto*>(
               &_RemoveErasureCodingPolicyResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RemoveErasureCodingPolicyResponseProto* other);
  friend void swap(RemoveErasureCodingPolicyResponseProto& a, RemoveErasureCodingPolicyResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveErasureCodingPolicyResponseProto* New() const final {
    return CreateMaybeMessage<RemoveErasureCodingPolicyResponseProto>(NULL);
  }

  RemoveErasureCodingPolicyResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemoveErasureCodingPolicyResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemoveErasureCodingPolicyResponseProto& from);
  void MergeFrom(const RemoveErasureCodingPolicyResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveErasureCodingPolicyResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.RemoveErasureCodingPolicyResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnableErasureCodingPolicyRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.EnableErasureCodingPolicyRequestProto) */ {
 public:
  EnableErasureCodingPolicyRequestProto();
  virtual ~EnableErasureCodingPolicyRequestProto();

  EnableErasureCodingPolicyRequestProto(const EnableErasureCodingPolicyRequestProto& from);

  inline EnableErasureCodingPolicyRequestProto& operator=(const EnableErasureCodingPolicyRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnableErasureCodingPolicyRequestProto(EnableErasureCodingPolicyRequestProto&& from) noexcept
    : EnableErasureCodingPolicyRequestProto() {
    *this = ::std::move(from);
  }

  inline EnableErasureCodingPolicyRequestProto& operator=(EnableErasureCodingPolicyRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableErasureCodingPolicyRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnableErasureCodingPolicyRequestProto* internal_default_instance() {
    return reinterpret_cast<const EnableErasureCodingPolicyRequestProto*>(
               &_EnableErasureCodingPolicyRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(EnableErasureCodingPolicyRequestProto* other);
  friend void swap(EnableErasureCodingPolicyRequestProto& a, EnableErasureCodingPolicyRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnableErasureCodingPolicyRequestProto* New() const final {
    return CreateMaybeMessage<EnableErasureCodingPolicyRequestProto>(NULL);
  }

  EnableErasureCodingPolicyRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnableErasureCodingPolicyRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnableErasureCodingPolicyRequestProto& from);
  void MergeFrom(const EnableErasureCodingPolicyRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableErasureCodingPolicyRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ecPolicyName = 1;
  bool has_ecpolicyname() const;
  void clear_ecpolicyname();
  static const int kEcPolicyNameFieldNumber = 1;
  const ::std::string& ecpolicyname() const;
  void set_ecpolicyname(const ::std::string& value);
  #if LANG_CXX11
  void set_ecpolicyname(::std::string&& value);
  #endif
  void set_ecpolicyname(const char* value);
  void set_ecpolicyname(const char* value, size_t size);
  ::std::string* mutable_ecpolicyname();
  ::std::string* release_ecpolicyname();
  void set_allocated_ecpolicyname(::std::string* ecpolicyname);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.EnableErasureCodingPolicyRequestProto)
 private:
  void set_has_ecpolicyname();
  void clear_has_ecpolicyname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ecpolicyname_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnableErasureCodingPolicyResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.EnableErasureCodingPolicyResponseProto) */ {
 public:
  EnableErasureCodingPolicyResponseProto();
  virtual ~EnableErasureCodingPolicyResponseProto();

  EnableErasureCodingPolicyResponseProto(const EnableErasureCodingPolicyResponseProto& from);

  inline EnableErasureCodingPolicyResponseProto& operator=(const EnableErasureCodingPolicyResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnableErasureCodingPolicyResponseProto(EnableErasureCodingPolicyResponseProto&& from) noexcept
    : EnableErasureCodingPolicyResponseProto() {
    *this = ::std::move(from);
  }

  inline EnableErasureCodingPolicyResponseProto& operator=(EnableErasureCodingPolicyResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableErasureCodingPolicyResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnableErasureCodingPolicyResponseProto* internal_default_instance() {
    return reinterpret_cast<const EnableErasureCodingPolicyResponseProto*>(
               &_EnableErasureCodingPolicyResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(EnableErasureCodingPolicyResponseProto* other);
  friend void swap(EnableErasureCodingPolicyResponseProto& a, EnableErasureCodingPolicyResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnableErasureCodingPolicyResponseProto* New() const final {
    return CreateMaybeMessage<EnableErasureCodingPolicyResponseProto>(NULL);
  }

  EnableErasureCodingPolicyResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnableErasureCodingPolicyResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnableErasureCodingPolicyResponseProto& from);
  void MergeFrom(const EnableErasureCodingPolicyResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableErasureCodingPolicyResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.EnableErasureCodingPolicyResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DisableErasureCodingPolicyRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.DisableErasureCodingPolicyRequestProto) */ {
 public:
  DisableErasureCodingPolicyRequestProto();
  virtual ~DisableErasureCodingPolicyRequestProto();

  DisableErasureCodingPolicyRequestProto(const DisableErasureCodingPolicyRequestProto& from);

  inline DisableErasureCodingPolicyRequestProto& operator=(const DisableErasureCodingPolicyRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DisableErasureCodingPolicyRequestProto(DisableErasureCodingPolicyRequestProto&& from) noexcept
    : DisableErasureCodingPolicyRequestProto() {
    *this = ::std::move(from);
  }

  inline DisableErasureCodingPolicyRequestProto& operator=(DisableErasureCodingPolicyRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisableErasureCodingPolicyRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisableErasureCodingPolicyRequestProto* internal_default_instance() {
    return reinterpret_cast<const DisableErasureCodingPolicyRequestProto*>(
               &_DisableErasureCodingPolicyRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(DisableErasureCodingPolicyRequestProto* other);
  friend void swap(DisableErasureCodingPolicyRequestProto& a, DisableErasureCodingPolicyRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DisableErasureCodingPolicyRequestProto* New() const final {
    return CreateMaybeMessage<DisableErasureCodingPolicyRequestProto>(NULL);
  }

  DisableErasureCodingPolicyRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DisableErasureCodingPolicyRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DisableErasureCodingPolicyRequestProto& from);
  void MergeFrom(const DisableErasureCodingPolicyRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableErasureCodingPolicyRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ecPolicyName = 1;
  bool has_ecpolicyname() const;
  void clear_ecpolicyname();
  static const int kEcPolicyNameFieldNumber = 1;
  const ::std::string& ecpolicyname() const;
  void set_ecpolicyname(const ::std::string& value);
  #if LANG_CXX11
  void set_ecpolicyname(::std::string&& value);
  #endif
  void set_ecpolicyname(const char* value);
  void set_ecpolicyname(const char* value, size_t size);
  ::std::string* mutable_ecpolicyname();
  ::std::string* release_ecpolicyname();
  void set_allocated_ecpolicyname(::std::string* ecpolicyname);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.DisableErasureCodingPolicyRequestProto)
 private:
  void set_has_ecpolicyname();
  void clear_has_ecpolicyname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ecpolicyname_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DisableErasureCodingPolicyResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.DisableErasureCodingPolicyResponseProto) */ {
 public:
  DisableErasureCodingPolicyResponseProto();
  virtual ~DisableErasureCodingPolicyResponseProto();

  DisableErasureCodingPolicyResponseProto(const DisableErasureCodingPolicyResponseProto& from);

  inline DisableErasureCodingPolicyResponseProto& operator=(const DisableErasureCodingPolicyResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DisableErasureCodingPolicyResponseProto(DisableErasureCodingPolicyResponseProto&& from) noexcept
    : DisableErasureCodingPolicyResponseProto() {
    *this = ::std::move(from);
  }

  inline DisableErasureCodingPolicyResponseProto& operator=(DisableErasureCodingPolicyResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisableErasureCodingPolicyResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisableErasureCodingPolicyResponseProto* internal_default_instance() {
    return reinterpret_cast<const DisableErasureCodingPolicyResponseProto*>(
               &_DisableErasureCodingPolicyResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(DisableErasureCodingPolicyResponseProto* other);
  friend void swap(DisableErasureCodingPolicyResponseProto& a, DisableErasureCodingPolicyResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DisableErasureCodingPolicyResponseProto* New() const final {
    return CreateMaybeMessage<DisableErasureCodingPolicyResponseProto>(NULL);
  }

  DisableErasureCodingPolicyResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DisableErasureCodingPolicyResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DisableErasureCodingPolicyResponseProto& from);
  void MergeFrom(const DisableErasureCodingPolicyResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableErasureCodingPolicyResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.DisableErasureCodingPolicyResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnsetErasureCodingPolicyRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto) */ {
 public:
  UnsetErasureCodingPolicyRequestProto();
  virtual ~UnsetErasureCodingPolicyRequestProto();

  UnsetErasureCodingPolicyRequestProto(const UnsetErasureCodingPolicyRequestProto& from);

  inline UnsetErasureCodingPolicyRequestProto& operator=(const UnsetErasureCodingPolicyRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnsetErasureCodingPolicyRequestProto(UnsetErasureCodingPolicyRequestProto&& from) noexcept
    : UnsetErasureCodingPolicyRequestProto() {
    *this = ::std::move(from);
  }

  inline UnsetErasureCodingPolicyRequestProto& operator=(UnsetErasureCodingPolicyRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsetErasureCodingPolicyRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnsetErasureCodingPolicyRequestProto* internal_default_instance() {
    return reinterpret_cast<const UnsetErasureCodingPolicyRequestProto*>(
               &_UnsetErasureCodingPolicyRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(UnsetErasureCodingPolicyRequestProto* other);
  friend void swap(UnsetErasureCodingPolicyRequestProto& a, UnsetErasureCodingPolicyRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnsetErasureCodingPolicyRequestProto* New() const final {
    return CreateMaybeMessage<UnsetErasureCodingPolicyRequestProto>(NULL);
  }

  UnsetErasureCodingPolicyRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnsetErasureCodingPolicyRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnsetErasureCodingPolicyRequestProto& from);
  void MergeFrom(const UnsetErasureCodingPolicyRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetErasureCodingPolicyRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto)
 private:
  void set_has_src();
  void clear_has_src();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnsetErasureCodingPolicyResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.UnsetErasureCodingPolicyResponseProto) */ {
 public:
  UnsetErasureCodingPolicyResponseProto();
  virtual ~UnsetErasureCodingPolicyResponseProto();

  UnsetErasureCodingPolicyResponseProto(const UnsetErasureCodingPolicyResponseProto& from);

  inline UnsetErasureCodingPolicyResponseProto& operator=(const UnsetErasureCodingPolicyResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnsetErasureCodingPolicyResponseProto(UnsetErasureCodingPolicyResponseProto&& from) noexcept
    : UnsetErasureCodingPolicyResponseProto() {
    *this = ::std::move(from);
  }

  inline UnsetErasureCodingPolicyResponseProto& operator=(UnsetErasureCodingPolicyResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsetErasureCodingPolicyResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnsetErasureCodingPolicyResponseProto* internal_default_instance() {
    return reinterpret_cast<const UnsetErasureCodingPolicyResponseProto*>(
               &_UnsetErasureCodingPolicyResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(UnsetErasureCodingPolicyResponseProto* other);
  friend void swap(UnsetErasureCodingPolicyResponseProto& a, UnsetErasureCodingPolicyResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnsetErasureCodingPolicyResponseProto* New() const final {
    return CreateMaybeMessage<UnsetErasureCodingPolicyResponseProto>(NULL);
  }

  UnsetErasureCodingPolicyResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnsetErasureCodingPolicyResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnsetErasureCodingPolicyResponseProto& from);
  void MergeFrom(const UnsetErasureCodingPolicyResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetErasureCodingPolicyResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.UnsetErasureCodingPolicyResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetECTopologyResultForPoliciesRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto) */ {
 public:
  GetECTopologyResultForPoliciesRequestProto();
  virtual ~GetECTopologyResultForPoliciesRequestProto();

  GetECTopologyResultForPoliciesRequestProto(const GetECTopologyResultForPoliciesRequestProto& from);

  inline GetECTopologyResultForPoliciesRequestProto& operator=(const GetECTopologyResultForPoliciesRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetECTopologyResultForPoliciesRequestProto(GetECTopologyResultForPoliciesRequestProto&& from) noexcept
    : GetECTopologyResultForPoliciesRequestProto() {
    *this = ::std::move(from);
  }

  inline GetECTopologyResultForPoliciesRequestProto& operator=(GetECTopologyResultForPoliciesRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetECTopologyResultForPoliciesRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetECTopologyResultForPoliciesRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetECTopologyResultForPoliciesRequestProto*>(
               &_GetECTopologyResultForPoliciesRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetECTopologyResultForPoliciesRequestProto* other);
  friend void swap(GetECTopologyResultForPoliciesRequestProto& a, GetECTopologyResultForPoliciesRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetECTopologyResultForPoliciesRequestProto* New() const final {
    return CreateMaybeMessage<GetECTopologyResultForPoliciesRequestProto>(NULL);
  }

  GetECTopologyResultForPoliciesRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetECTopologyResultForPoliciesRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetECTopologyResultForPoliciesRequestProto& from);
  void MergeFrom(const GetECTopologyResultForPoliciesRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetECTopologyResultForPoliciesRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string policies = 1;
  int policies_size() const;
  void clear_policies();
  static const int kPoliciesFieldNumber = 1;
  const ::std::string& policies(int index) const;
  ::std::string* mutable_policies(int index);
  void set_policies(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_policies(int index, ::std::string&& value);
  #endif
  void set_policies(int index, const char* value);
  void set_policies(int index, const char* value, size_t size);
  ::std::string* add_policies();
  void add_policies(const ::std::string& value);
  #if LANG_CXX11
  void add_policies(::std::string&& value);
  #endif
  void add_policies(const char* value);
  void add_policies(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& policies() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_policies();

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> policies_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetECTopologyResultForPoliciesResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetECTopologyResultForPoliciesResponseProto) */ {
 public:
  GetECTopologyResultForPoliciesResponseProto();
  virtual ~GetECTopologyResultForPoliciesResponseProto();

  GetECTopologyResultForPoliciesResponseProto(const GetECTopologyResultForPoliciesResponseProto& from);

  inline GetECTopologyResultForPoliciesResponseProto& operator=(const GetECTopologyResultForPoliciesResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetECTopologyResultForPoliciesResponseProto(GetECTopologyResultForPoliciesResponseProto&& from) noexcept
    : GetECTopologyResultForPoliciesResponseProto() {
    *this = ::std::move(from);
  }

  inline GetECTopologyResultForPoliciesResponseProto& operator=(GetECTopologyResultForPoliciesResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetECTopologyResultForPoliciesResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetECTopologyResultForPoliciesResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetECTopologyResultForPoliciesResponseProto*>(
               &_GetECTopologyResultForPoliciesResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GetECTopologyResultForPoliciesResponseProto* other);
  friend void swap(GetECTopologyResultForPoliciesResponseProto& a, GetECTopologyResultForPoliciesResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetECTopologyResultForPoliciesResponseProto* New() const final {
    return CreateMaybeMessage<GetECTopologyResultForPoliciesResponseProto>(NULL);
  }

  GetECTopologyResultForPoliciesResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetECTopologyResultForPoliciesResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetECTopologyResultForPoliciesResponseProto& from);
  void MergeFrom(const GetECTopologyResultForPoliciesResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetECTopologyResultForPoliciesResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.ECTopologyVerifierResultProto response = 1;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  private:
  const ::hadoop::hdfs::ECTopologyVerifierResultProto& _internal_response() const;
  public:
  const ::hadoop::hdfs::ECTopologyVerifierResultProto& response() const;
  ::hadoop::hdfs::ECTopologyVerifierResultProto* release_response();
  ::hadoop::hdfs::ECTopologyVerifierResultProto* mutable_response();
  void set_allocated_response(::hadoop::hdfs::ECTopologyVerifierResultProto* response);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetECTopologyResultForPoliciesResponseProto)
 private:
  void set_has_response();
  void clear_has_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::ECTopologyVerifierResultProto* response_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockECReconstructionInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.BlockECReconstructionInfoProto) */ {
 public:
  BlockECReconstructionInfoProto();
  virtual ~BlockECReconstructionInfoProto();

  BlockECReconstructionInfoProto(const BlockECReconstructionInfoProto& from);

  inline BlockECReconstructionInfoProto& operator=(const BlockECReconstructionInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockECReconstructionInfoProto(BlockECReconstructionInfoProto&& from) noexcept
    : BlockECReconstructionInfoProto() {
    *this = ::std::move(from);
  }

  inline BlockECReconstructionInfoProto& operator=(BlockECReconstructionInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockECReconstructionInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockECReconstructionInfoProto* internal_default_instance() {
    return reinterpret_cast<const BlockECReconstructionInfoProto*>(
               &_BlockECReconstructionInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(BlockECReconstructionInfoProto* other);
  friend void swap(BlockECReconstructionInfoProto& a, BlockECReconstructionInfoProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockECReconstructionInfoProto* New() const final {
    return CreateMaybeMessage<BlockECReconstructionInfoProto>(NULL);
  }

  BlockECReconstructionInfoProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockECReconstructionInfoProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockECReconstructionInfoProto& from);
  void MergeFrom(const BlockECReconstructionInfoProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockECReconstructionInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes liveBlockIndices = 6;
  bool has_liveblockindices() const;
  void clear_liveblockindices();
  static const int kLiveBlockIndicesFieldNumber = 6;
  const ::std::string& liveblockindices() const;
  void set_liveblockindices(const ::std::string& value);
  #if LANG_CXX11
  void set_liveblockindices(::std::string&& value);
  #endif
  void set_liveblockindices(const char* value);
  void set_liveblockindices(const void* value, size_t size);
  ::std::string* mutable_liveblockindices();
  ::std::string* release_liveblockindices();
  void set_allocated_liveblockindices(::std::string* liveblockindices);

  // optional bytes excludeReconstructedIndices = 8;
  bool has_excludereconstructedindices() const;
  void clear_excludereconstructedindices();
  static const int kExcludeReconstructedIndicesFieldNumber = 8;
  const ::std::string& excludereconstructedindices() const;
  void set_excludereconstructedindices(const ::std::string& value);
  #if LANG_CXX11
  void set_excludereconstructedindices(::std::string&& value);
  #endif
  void set_excludereconstructedindices(const char* value);
  void set_excludereconstructedindices(const void* value, size_t size);
  ::std::string* mutable_excludereconstructedindices();
  ::std::string* release_excludereconstructedindices();
  void set_allocated_excludereconstructedindices(::std::string* excludereconstructedindices);

  // required .hadoop.hdfs.ExtendedBlockProto block = 1;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  private:
  const ::hadoop::hdfs::ExtendedBlockProto& _internal_block() const;
  public:
  const ::hadoop::hdfs::ExtendedBlockProto& block() const;
  ::hadoop::hdfs::ExtendedBlockProto* release_block();
  ::hadoop::hdfs::ExtendedBlockProto* mutable_block();
  void set_allocated_block(::hadoop::hdfs::ExtendedBlockProto* block);

  // required .hadoop.hdfs.DatanodeInfosProto sourceDnInfos = 2;
  bool has_sourcedninfos() const;
  void clear_sourcedninfos();
  static const int kSourceDnInfosFieldNumber = 2;
  private:
  const ::hadoop::hdfs::DatanodeInfosProto& _internal_sourcedninfos() const;
  public:
  const ::hadoop::hdfs::DatanodeInfosProto& sourcedninfos() const;
  ::hadoop::hdfs::DatanodeInfosProto* release_sourcedninfos();
  ::hadoop::hdfs::DatanodeInfosProto* mutable_sourcedninfos();
  void set_allocated_sourcedninfos(::hadoop::hdfs::DatanodeInfosProto* sourcedninfos);

  // required .hadoop.hdfs.DatanodeInfosProto targetDnInfos = 3;
  bool has_targetdninfos() const;
  void clear_targetdninfos();
  static const int kTargetDnInfosFieldNumber = 3;
  private:
  const ::hadoop::hdfs::DatanodeInfosProto& _internal_targetdninfos() const;
  public:
  const ::hadoop::hdfs::DatanodeInfosProto& targetdninfos() const;
  ::hadoop::hdfs::DatanodeInfosProto* release_targetdninfos();
  ::hadoop::hdfs::DatanodeInfosProto* mutable_targetdninfos();
  void set_allocated_targetdninfos(::hadoop::hdfs::DatanodeInfosProto* targetdninfos);

  // required .hadoop.hdfs.StorageUuidsProto targetStorageUuids = 4;
  bool has_targetstorageuuids() const;
  void clear_targetstorageuuids();
  static const int kTargetStorageUuidsFieldNumber = 4;
  private:
  const ::hadoop::hdfs::StorageUuidsProto& _internal_targetstorageuuids() const;
  public:
  const ::hadoop::hdfs::StorageUuidsProto& targetstorageuuids() const;
  ::hadoop::hdfs::StorageUuidsProto* release_targetstorageuuids();
  ::hadoop::hdfs::StorageUuidsProto* mutable_targetstorageuuids();
  void set_allocated_targetstorageuuids(::hadoop::hdfs::StorageUuidsProto* targetstorageuuids);

  // required .hadoop.hdfs.StorageTypesProto targetStorageTypes = 5;
  bool has_targetstoragetypes() const;
  void clear_targetstoragetypes();
  static const int kTargetStorageTypesFieldNumber = 5;
  private:
  const ::hadoop::hdfs::StorageTypesProto& _internal_targetstoragetypes() const;
  public:
  const ::hadoop::hdfs::StorageTypesProto& targetstoragetypes() const;
  ::hadoop::hdfs::StorageTypesProto* release_targetstoragetypes();
  ::hadoop::hdfs::StorageTypesProto* mutable_targetstoragetypes();
  void set_allocated_targetstoragetypes(::hadoop::hdfs::StorageTypesProto* targetstoragetypes);

  // required .hadoop.hdfs.ErasureCodingPolicyProto ecPolicy = 7;
  bool has_ecpolicy() const;
  void clear_ecpolicy();
  static const int kEcPolicyFieldNumber = 7;
  private:
  const ::hadoop::hdfs::ErasureCodingPolicyProto& _internal_ecpolicy() const;
  public:
  const ::hadoop::hdfs::ErasureCodingPolicyProto& ecpolicy() const;
  ::hadoop::hdfs::ErasureCodingPolicyProto* release_ecpolicy();
  ::hadoop::hdfs::ErasureCodingPolicyProto* mutable_ecpolicy();
  void set_allocated_ecpolicy(::hadoop::hdfs::ErasureCodingPolicyProto* ecpolicy);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.BlockECReconstructionInfoProto)
 private:
  void set_has_block();
  void clear_has_block();
  void set_has_sourcedninfos();
  void clear_has_sourcedninfos();
  void set_has_targetdninfos();
  void clear_has_targetdninfos();
  void set_has_targetstorageuuids();
  void clear_has_targetstorageuuids();
  void set_has_targetstoragetypes();
  void clear_has_targetstoragetypes();
  void set_has_liveblockindices();
  void clear_has_liveblockindices();
  void set_has_ecpolicy();
  void clear_has_ecpolicy();
  void set_has_excludereconstructedindices();
  void clear_has_excludereconstructedindices();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr liveblockindices_;
  ::google::protobuf::internal::ArenaStringPtr excludereconstructedindices_;
  ::hadoop::hdfs::ExtendedBlockProto* block_;
  ::hadoop::hdfs::DatanodeInfosProto* sourcedninfos_;
  ::hadoop::hdfs::DatanodeInfosProto* targetdninfos_;
  ::hadoop::hdfs::StorageUuidsProto* targetstorageuuids_;
  ::hadoop::hdfs::StorageTypesProto* targetstoragetypes_;
  ::hadoop::hdfs::ErasureCodingPolicyProto* ecpolicy_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CodecProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.CodecProto) */ {
 public:
  CodecProto();
  virtual ~CodecProto();

  CodecProto(const CodecProto& from);

  inline CodecProto& operator=(const CodecProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CodecProto(CodecProto&& from) noexcept
    : CodecProto() {
    *this = ::std::move(from);
  }

  inline CodecProto& operator=(CodecProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CodecProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CodecProto* internal_default_instance() {
    return reinterpret_cast<const CodecProto*>(
               &_CodecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CodecProto* other);
  friend void swap(CodecProto& a, CodecProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CodecProto* New() const final {
    return CreateMaybeMessage<CodecProto>(NULL);
  }

  CodecProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CodecProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CodecProto& from);
  void MergeFrom(const CodecProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodecProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string codec = 1;
  bool has_codec() const;
  void clear_codec();
  static const int kCodecFieldNumber = 1;
  const ::std::string& codec() const;
  void set_codec(const ::std::string& value);
  #if LANG_CXX11
  void set_codec(::std::string&& value);
  #endif
  void set_codec(const char* value);
  void set_codec(const char* value, size_t size);
  ::std::string* mutable_codec();
  ::std::string* release_codec();
  void set_allocated_codec(::std::string* codec);

  // required string coders = 2;
  bool has_coders() const;
  void clear_coders();
  static const int kCodersFieldNumber = 2;
  const ::std::string& coders() const;
  void set_coders(const ::std::string& value);
  #if LANG_CXX11
  void set_coders(::std::string&& value);
  #endif
  void set_coders(const char* value);
  void set_coders(const char* value, size_t size);
  ::std::string* mutable_coders();
  ::std::string* release_coders();
  void set_allocated_coders(::std::string* coders);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.CodecProto)
 private:
  void set_has_codec();
  void clear_has_codec();
  void set_has_coders();
  void clear_has_coders();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr codec_;
  ::google::protobuf::internal::ArenaStringPtr coders_;
  friend struct ::protobuf_erasurecoding_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetErasureCodingPolicyRequestProto

// required string src = 1;
inline bool SetErasureCodingPolicyRequestProto::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetErasureCodingPolicyRequestProto::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetErasureCodingPolicyRequestProto::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetErasureCodingPolicyRequestProto::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src();
}
inline const ::std::string& SetErasureCodingPolicyRequestProto::src() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
  return src_.GetNoArena();
}
inline void SetErasureCodingPolicyRequestProto::set_src(const ::std::string& value) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
}
#if LANG_CXX11
inline void SetErasureCodingPolicyRequestProto::set_src(::std::string&& value) {
  set_has_src();
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
}
#endif
inline void SetErasureCodingPolicyRequestProto::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
}
inline void SetErasureCodingPolicyRequestProto::set_src(const char* value, size_t size) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
}
inline ::std::string* SetErasureCodingPolicyRequestProto::mutable_src() {
  set_has_src();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetErasureCodingPolicyRequestProto::release_src() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
  if (!has_src()) {
    return NULL;
  }
  clear_has_src();
  return src_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetErasureCodingPolicyRequestProto::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    set_has_src();
  } else {
    clear_has_src();
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.SetErasureCodingPolicyRequestProto.src)
}

// optional string ecPolicyName = 2;
inline bool SetErasureCodingPolicyRequestProto::has_ecpolicyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetErasureCodingPolicyRequestProto::set_has_ecpolicyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetErasureCodingPolicyRequestProto::clear_has_ecpolicyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetErasureCodingPolicyRequestProto::clear_ecpolicyname() {
  ecpolicyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecpolicyname();
}
inline const ::std::string& SetErasureCodingPolicyRequestProto::ecpolicyname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.GetNoArena();
}
inline void SetErasureCodingPolicyRequestProto::set_ecpolicyname(const ::std::string& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
}
#if LANG_CXX11
inline void SetErasureCodingPolicyRequestProto::set_ecpolicyname(::std::string&& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
}
#endif
inline void SetErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
}
inline void SetErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value, size_t size) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
}
inline ::std::string* SetErasureCodingPolicyRequestProto::mutable_ecpolicyname() {
  set_has_ecpolicyname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetErasureCodingPolicyRequestProto::release_ecpolicyname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
  if (!has_ecpolicyname()) {
    return NULL;
  }
  clear_has_ecpolicyname();
  return ecpolicyname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetErasureCodingPolicyRequestProto::set_allocated_ecpolicyname(::std::string* ecpolicyname) {
  if (ecpolicyname != NULL) {
    set_has_ecpolicyname();
  } else {
    clear_has_ecpolicyname();
  }
  ecpolicyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecpolicyname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.SetErasureCodingPolicyRequestProto.ecPolicyName)
}

// -------------------------------------------------------------------

// SetErasureCodingPolicyResponseProto

// -------------------------------------------------------------------

// GetErasureCodingPoliciesRequestProto

// -------------------------------------------------------------------

// GetErasureCodingPoliciesResponseProto

// repeated .hadoop.hdfs.ErasureCodingPolicyProto ecPolicies = 1;
inline int GetErasureCodingPoliciesResponseProto::ecpolicies_size() const {
  return ecpolicies_.size();
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* GetErasureCodingPoliciesResponseProto::mutable_ecpolicies(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetErasureCodingPoliciesResponseProto.ecPolicies)
  return ecpolicies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >*
GetErasureCodingPoliciesResponseProto::mutable_ecpolicies() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.GetErasureCodingPoliciesResponseProto.ecPolicies)
  return &ecpolicies_;
}
inline const ::hadoop::hdfs::ErasureCodingPolicyProto& GetErasureCodingPoliciesResponseProto::ecpolicies(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetErasureCodingPoliciesResponseProto.ecPolicies)
  return ecpolicies_.Get(index);
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* GetErasureCodingPoliciesResponseProto::add_ecpolicies() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.GetErasureCodingPoliciesResponseProto.ecPolicies)
  return ecpolicies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >&
GetErasureCodingPoliciesResponseProto::ecpolicies() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.GetErasureCodingPoliciesResponseProto.ecPolicies)
  return ecpolicies_;
}

// -------------------------------------------------------------------

// GetErasureCodingCodecsRequestProto

// -------------------------------------------------------------------

// GetErasureCodingCodecsResponseProto

// repeated .hadoop.hdfs.CodecProto codec = 1;
inline int GetErasureCodingCodecsResponseProto::codec_size() const {
  return codec_.size();
}
inline void GetErasureCodingCodecsResponseProto::clear_codec() {
  codec_.Clear();
}
inline ::hadoop::hdfs::CodecProto* GetErasureCodingCodecsResponseProto::mutable_codec(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetErasureCodingCodecsResponseProto.codec)
  return codec_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::CodecProto >*
GetErasureCodingCodecsResponseProto::mutable_codec() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.GetErasureCodingCodecsResponseProto.codec)
  return &codec_;
}
inline const ::hadoop::hdfs::CodecProto& GetErasureCodingCodecsResponseProto::codec(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetErasureCodingCodecsResponseProto.codec)
  return codec_.Get(index);
}
inline ::hadoop::hdfs::CodecProto* GetErasureCodingCodecsResponseProto::add_codec() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.GetErasureCodingCodecsResponseProto.codec)
  return codec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::CodecProto >&
GetErasureCodingCodecsResponseProto::codec() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.GetErasureCodingCodecsResponseProto.codec)
  return codec_;
}

// -------------------------------------------------------------------

// GetErasureCodingPolicyRequestProto

// required string src = 1;
inline bool GetErasureCodingPolicyRequestProto::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetErasureCodingPolicyRequestProto::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetErasureCodingPolicyRequestProto::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetErasureCodingPolicyRequestProto::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src();
}
inline const ::std::string& GetErasureCodingPolicyRequestProto::src() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
  return src_.GetNoArena();
}
inline void GetErasureCodingPolicyRequestProto::set_src(const ::std::string& value) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
}
#if LANG_CXX11
inline void GetErasureCodingPolicyRequestProto::set_src(::std::string&& value) {
  set_has_src();
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
}
#endif
inline void GetErasureCodingPolicyRequestProto::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
}
inline void GetErasureCodingPolicyRequestProto::set_src(const char* value, size_t size) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
}
inline ::std::string* GetErasureCodingPolicyRequestProto::mutable_src() {
  set_has_src();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetErasureCodingPolicyRequestProto::release_src() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
  if (!has_src()) {
    return NULL;
  }
  clear_has_src();
  return src_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetErasureCodingPolicyRequestProto::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    set_has_src();
  } else {
    clear_has_src();
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.GetErasureCodingPolicyRequestProto.src)
}

// -------------------------------------------------------------------

// GetErasureCodingPolicyResponseProto

// optional .hadoop.hdfs.ErasureCodingPolicyProto ecPolicy = 1;
inline bool GetErasureCodingPolicyResponseProto::has_ecpolicy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetErasureCodingPolicyResponseProto::set_has_ecpolicy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetErasureCodingPolicyResponseProto::clear_has_ecpolicy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::ErasureCodingPolicyProto& GetErasureCodingPolicyResponseProto::_internal_ecpolicy() const {
  return *ecpolicy_;
}
inline const ::hadoop::hdfs::ErasureCodingPolicyProto& GetErasureCodingPolicyResponseProto::ecpolicy() const {
  const ::hadoop::hdfs::ErasureCodingPolicyProto* p = ecpolicy_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetErasureCodingPolicyResponseProto.ecPolicy)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::ErasureCodingPolicyProto*>(
      &::hadoop::hdfs::_ErasureCodingPolicyProto_default_instance_);
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* GetErasureCodingPolicyResponseProto::release_ecpolicy() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.GetErasureCodingPolicyResponseProto.ecPolicy)
  clear_has_ecpolicy();
  ::hadoop::hdfs::ErasureCodingPolicyProto* temp = ecpolicy_;
  ecpolicy_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* GetErasureCodingPolicyResponseProto::mutable_ecpolicy() {
  set_has_ecpolicy();
  if (ecpolicy_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::ErasureCodingPolicyProto>(GetArenaNoVirtual());
    ecpolicy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetErasureCodingPolicyResponseProto.ecPolicy)
  return ecpolicy_;
}
inline void GetErasureCodingPolicyResponseProto::set_allocated_ecpolicy(::hadoop::hdfs::ErasureCodingPolicyProto* ecpolicy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ecpolicy_);
  }
  if (ecpolicy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ecpolicy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ecpolicy, submessage_arena);
    }
    set_has_ecpolicy();
  } else {
    clear_has_ecpolicy();
  }
  ecpolicy_ = ecpolicy;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.GetErasureCodingPolicyResponseProto.ecPolicy)
}

// -------------------------------------------------------------------

// AddErasureCodingPoliciesRequestProto

// repeated .hadoop.hdfs.ErasureCodingPolicyProto ecPolicies = 1;
inline int AddErasureCodingPoliciesRequestProto::ecpolicies_size() const {
  return ecpolicies_.size();
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* AddErasureCodingPoliciesRequestProto::mutable_ecpolicies(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.AddErasureCodingPoliciesRequestProto.ecPolicies)
  return ecpolicies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >*
AddErasureCodingPoliciesRequestProto::mutable_ecpolicies() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.AddErasureCodingPoliciesRequestProto.ecPolicies)
  return &ecpolicies_;
}
inline const ::hadoop::hdfs::ErasureCodingPolicyProto& AddErasureCodingPoliciesRequestProto::ecpolicies(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.AddErasureCodingPoliciesRequestProto.ecPolicies)
  return ecpolicies_.Get(index);
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* AddErasureCodingPoliciesRequestProto::add_ecpolicies() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.AddErasureCodingPoliciesRequestProto.ecPolicies)
  return ecpolicies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ErasureCodingPolicyProto >&
AddErasureCodingPoliciesRequestProto::ecpolicies() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.AddErasureCodingPoliciesRequestProto.ecPolicies)
  return ecpolicies_;
}

// -------------------------------------------------------------------

// AddErasureCodingPoliciesResponseProto

// repeated .hadoop.hdfs.AddErasureCodingPolicyResponseProto responses = 1;
inline int AddErasureCodingPoliciesResponseProto::responses_size() const {
  return responses_.size();
}
inline ::hadoop::hdfs::AddErasureCodingPolicyResponseProto* AddErasureCodingPoliciesResponseProto::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.AddErasureCodingPoliciesResponseProto.responses)
  return responses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AddErasureCodingPolicyResponseProto >*
AddErasureCodingPoliciesResponseProto::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.AddErasureCodingPoliciesResponseProto.responses)
  return &responses_;
}
inline const ::hadoop::hdfs::AddErasureCodingPolicyResponseProto& AddErasureCodingPoliciesResponseProto::responses(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.AddErasureCodingPoliciesResponseProto.responses)
  return responses_.Get(index);
}
inline ::hadoop::hdfs::AddErasureCodingPolicyResponseProto* AddErasureCodingPoliciesResponseProto::add_responses() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.AddErasureCodingPoliciesResponseProto.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AddErasureCodingPolicyResponseProto >&
AddErasureCodingPoliciesResponseProto::responses() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.AddErasureCodingPoliciesResponseProto.responses)
  return responses_;
}

// -------------------------------------------------------------------

// RemoveErasureCodingPolicyRequestProto

// required string ecPolicyName = 1;
inline bool RemoveErasureCodingPolicyRequestProto::has_ecpolicyname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveErasureCodingPolicyRequestProto::set_has_ecpolicyname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveErasureCodingPolicyRequestProto::clear_has_ecpolicyname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveErasureCodingPolicyRequestProto::clear_ecpolicyname() {
  ecpolicyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecpolicyname();
}
inline const ::std::string& RemoveErasureCodingPolicyRequestProto::ecpolicyname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.GetNoArena();
}
inline void RemoveErasureCodingPolicyRequestProto::set_ecpolicyname(const ::std::string& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
}
#if LANG_CXX11
inline void RemoveErasureCodingPolicyRequestProto::set_ecpolicyname(::std::string&& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
}
#endif
inline void RemoveErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
}
inline void RemoveErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value, size_t size) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
}
inline ::std::string* RemoveErasureCodingPolicyRequestProto::mutable_ecpolicyname() {
  set_has_ecpolicyname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemoveErasureCodingPolicyRequestProto::release_ecpolicyname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
  if (!has_ecpolicyname()) {
    return NULL;
  }
  clear_has_ecpolicyname();
  return ecpolicyname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoveErasureCodingPolicyRequestProto::set_allocated_ecpolicyname(::std::string* ecpolicyname) {
  if (ecpolicyname != NULL) {
    set_has_ecpolicyname();
  } else {
    clear_has_ecpolicyname();
  }
  ecpolicyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecpolicyname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.RemoveErasureCodingPolicyRequestProto.ecPolicyName)
}

// -------------------------------------------------------------------

// RemoveErasureCodingPolicyResponseProto

// -------------------------------------------------------------------

// EnableErasureCodingPolicyRequestProto

// required string ecPolicyName = 1;
inline bool EnableErasureCodingPolicyRequestProto::has_ecpolicyname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableErasureCodingPolicyRequestProto::set_has_ecpolicyname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableErasureCodingPolicyRequestProto::clear_has_ecpolicyname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableErasureCodingPolicyRequestProto::clear_ecpolicyname() {
  ecpolicyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecpolicyname();
}
inline const ::std::string& EnableErasureCodingPolicyRequestProto::ecpolicyname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.GetNoArena();
}
inline void EnableErasureCodingPolicyRequestProto::set_ecpolicyname(const ::std::string& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
}
#if LANG_CXX11
inline void EnableErasureCodingPolicyRequestProto::set_ecpolicyname(::std::string&& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
}
#endif
inline void EnableErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
}
inline void EnableErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value, size_t size) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
}
inline ::std::string* EnableErasureCodingPolicyRequestProto::mutable_ecpolicyname() {
  set_has_ecpolicyname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnableErasureCodingPolicyRequestProto::release_ecpolicyname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
  if (!has_ecpolicyname()) {
    return NULL;
  }
  clear_has_ecpolicyname();
  return ecpolicyname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnableErasureCodingPolicyRequestProto::set_allocated_ecpolicyname(::std::string* ecpolicyname) {
  if (ecpolicyname != NULL) {
    set_has_ecpolicyname();
  } else {
    clear_has_ecpolicyname();
  }
  ecpolicyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecpolicyname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.EnableErasureCodingPolicyRequestProto.ecPolicyName)
}

// -------------------------------------------------------------------

// EnableErasureCodingPolicyResponseProto

// -------------------------------------------------------------------

// DisableErasureCodingPolicyRequestProto

// required string ecPolicyName = 1;
inline bool DisableErasureCodingPolicyRequestProto::has_ecpolicyname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisableErasureCodingPolicyRequestProto::set_has_ecpolicyname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisableErasureCodingPolicyRequestProto::clear_has_ecpolicyname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisableErasureCodingPolicyRequestProto::clear_ecpolicyname() {
  ecpolicyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecpolicyname();
}
inline const ::std::string& DisableErasureCodingPolicyRequestProto::ecpolicyname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.GetNoArena();
}
inline void DisableErasureCodingPolicyRequestProto::set_ecpolicyname(const ::std::string& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
}
#if LANG_CXX11
inline void DisableErasureCodingPolicyRequestProto::set_ecpolicyname(::std::string&& value) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
}
#endif
inline void DisableErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
}
inline void DisableErasureCodingPolicyRequestProto::set_ecpolicyname(const char* value, size_t size) {
  set_has_ecpolicyname();
  ecpolicyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
}
inline ::std::string* DisableErasureCodingPolicyRequestProto::mutable_ecpolicyname() {
  set_has_ecpolicyname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
  return ecpolicyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisableErasureCodingPolicyRequestProto::release_ecpolicyname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
  if (!has_ecpolicyname()) {
    return NULL;
  }
  clear_has_ecpolicyname();
  return ecpolicyname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisableErasureCodingPolicyRequestProto::set_allocated_ecpolicyname(::std::string* ecpolicyname) {
  if (ecpolicyname != NULL) {
    set_has_ecpolicyname();
  } else {
    clear_has_ecpolicyname();
  }
  ecpolicyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecpolicyname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.DisableErasureCodingPolicyRequestProto.ecPolicyName)
}

// -------------------------------------------------------------------

// DisableErasureCodingPolicyResponseProto

// -------------------------------------------------------------------

// UnsetErasureCodingPolicyRequestProto

// required string src = 1;
inline bool UnsetErasureCodingPolicyRequestProto::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnsetErasureCodingPolicyRequestProto::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnsetErasureCodingPolicyRequestProto::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnsetErasureCodingPolicyRequestProto::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src();
}
inline const ::std::string& UnsetErasureCodingPolicyRequestProto::src() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
  return src_.GetNoArena();
}
inline void UnsetErasureCodingPolicyRequestProto::set_src(const ::std::string& value) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
}
#if LANG_CXX11
inline void UnsetErasureCodingPolicyRequestProto::set_src(::std::string&& value) {
  set_has_src();
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
}
#endif
inline void UnsetErasureCodingPolicyRequestProto::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
}
inline void UnsetErasureCodingPolicyRequestProto::set_src(const char* value, size_t size) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
}
inline ::std::string* UnsetErasureCodingPolicyRequestProto::mutable_src() {
  set_has_src();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnsetErasureCodingPolicyRequestProto::release_src() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
  if (!has_src()) {
    return NULL;
  }
  clear_has_src();
  return src_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnsetErasureCodingPolicyRequestProto::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    set_has_src();
  } else {
    clear_has_src();
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.UnsetErasureCodingPolicyRequestProto.src)
}

// -------------------------------------------------------------------

// UnsetErasureCodingPolicyResponseProto

// -------------------------------------------------------------------

// GetECTopologyResultForPoliciesRequestProto

// repeated string policies = 1;
inline int GetECTopologyResultForPoliciesRequestProto::policies_size() const {
  return policies_.size();
}
inline void GetECTopologyResultForPoliciesRequestProto::clear_policies() {
  policies_.Clear();
}
inline const ::std::string& GetECTopologyResultForPoliciesRequestProto::policies(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
  return policies_.Get(index);
}
inline ::std::string* GetECTopologyResultForPoliciesRequestProto::mutable_policies(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
  return policies_.Mutable(index);
}
inline void GetECTopologyResultForPoliciesRequestProto::set_policies(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
  policies_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetECTopologyResultForPoliciesRequestProto::set_policies(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
  policies_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetECTopologyResultForPoliciesRequestProto::set_policies(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  policies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
}
inline void GetECTopologyResultForPoliciesRequestProto::set_policies(int index, const char* value, size_t size) {
  policies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
}
inline ::std::string* GetECTopologyResultForPoliciesRequestProto::add_policies() {
  // @@protoc_insertion_point(field_add_mutable:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
  return policies_.Add();
}
inline void GetECTopologyResultForPoliciesRequestProto::add_policies(const ::std::string& value) {
  policies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
}
#if LANG_CXX11
inline void GetECTopologyResultForPoliciesRequestProto::add_policies(::std::string&& value) {
  policies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
}
#endif
inline void GetECTopologyResultForPoliciesRequestProto::add_policies(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  policies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
}
inline void GetECTopologyResultForPoliciesRequestProto::add_policies(const char* value, size_t size) {
  policies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetECTopologyResultForPoliciesRequestProto::policies() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
  return policies_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetECTopologyResultForPoliciesRequestProto::mutable_policies() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.GetECTopologyResultForPoliciesRequestProto.policies)
  return &policies_;
}

// -------------------------------------------------------------------

// GetECTopologyResultForPoliciesResponseProto

// required .hadoop.hdfs.ECTopologyVerifierResultProto response = 1;
inline bool GetECTopologyResultForPoliciesResponseProto::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetECTopologyResultForPoliciesResponseProto::set_has_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetECTopologyResultForPoliciesResponseProto::clear_has_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::ECTopologyVerifierResultProto& GetECTopologyResultForPoliciesResponseProto::_internal_response() const {
  return *response_;
}
inline const ::hadoop::hdfs::ECTopologyVerifierResultProto& GetECTopologyResultForPoliciesResponseProto::response() const {
  const ::hadoop::hdfs::ECTopologyVerifierResultProto* p = response_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetECTopologyResultForPoliciesResponseProto.response)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::ECTopologyVerifierResultProto*>(
      &::hadoop::hdfs::_ECTopologyVerifierResultProto_default_instance_);
}
inline ::hadoop::hdfs::ECTopologyVerifierResultProto* GetECTopologyResultForPoliciesResponseProto::release_response() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.GetECTopologyResultForPoliciesResponseProto.response)
  clear_has_response();
  ::hadoop::hdfs::ECTopologyVerifierResultProto* temp = response_;
  response_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::ECTopologyVerifierResultProto* GetECTopologyResultForPoliciesResponseProto::mutable_response() {
  set_has_response();
  if (response_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::ECTopologyVerifierResultProto>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetECTopologyResultForPoliciesResponseProto.response)
  return response_;
}
inline void GetECTopologyResultForPoliciesResponseProto::set_allocated_response(::hadoop::hdfs::ECTopologyVerifierResultProto* response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(response_);
  }
  if (response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    set_has_response();
  } else {
    clear_has_response();
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.GetECTopologyResultForPoliciesResponseProto.response)
}

// -------------------------------------------------------------------

// BlockECReconstructionInfoProto

// required .hadoop.hdfs.ExtendedBlockProto block = 1;
inline bool BlockECReconstructionInfoProto::has_block() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_block() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockECReconstructionInfoProto::clear_has_block() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hadoop::hdfs::ExtendedBlockProto& BlockECReconstructionInfoProto::_internal_block() const {
  return *block_;
}
inline const ::hadoop::hdfs::ExtendedBlockProto& BlockECReconstructionInfoProto::block() const {
  const ::hadoop::hdfs::ExtendedBlockProto* p = block_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.block)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::ExtendedBlockProto*>(
      &::hadoop::hdfs::_ExtendedBlockProto_default_instance_);
}
inline ::hadoop::hdfs::ExtendedBlockProto* BlockECReconstructionInfoProto::release_block() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.block)
  clear_has_block();
  ::hadoop::hdfs::ExtendedBlockProto* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::ExtendedBlockProto* BlockECReconstructionInfoProto::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::ExtendedBlockProto>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.block)
  return block_;
}
inline void BlockECReconstructionInfoProto::set_allocated_block(::hadoop::hdfs::ExtendedBlockProto* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(block_);
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    set_has_block();
  } else {
    clear_has_block();
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.block)
}

// required .hadoop.hdfs.DatanodeInfosProto sourceDnInfos = 2;
inline bool BlockECReconstructionInfoProto::has_sourcedninfos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_sourcedninfos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockECReconstructionInfoProto::clear_has_sourcedninfos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hadoop::hdfs::DatanodeInfosProto& BlockECReconstructionInfoProto::_internal_sourcedninfos() const {
  return *sourcedninfos_;
}
inline const ::hadoop::hdfs::DatanodeInfosProto& BlockECReconstructionInfoProto::sourcedninfos() const {
  const ::hadoop::hdfs::DatanodeInfosProto* p = sourcedninfos_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.sourceDnInfos)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::DatanodeInfosProto*>(
      &::hadoop::hdfs::_DatanodeInfosProto_default_instance_);
}
inline ::hadoop::hdfs::DatanodeInfosProto* BlockECReconstructionInfoProto::release_sourcedninfos() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.sourceDnInfos)
  clear_has_sourcedninfos();
  ::hadoop::hdfs::DatanodeInfosProto* temp = sourcedninfos_;
  sourcedninfos_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::DatanodeInfosProto* BlockECReconstructionInfoProto::mutable_sourcedninfos() {
  set_has_sourcedninfos();
  if (sourcedninfos_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::DatanodeInfosProto>(GetArenaNoVirtual());
    sourcedninfos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.sourceDnInfos)
  return sourcedninfos_;
}
inline void BlockECReconstructionInfoProto::set_allocated_sourcedninfos(::hadoop::hdfs::DatanodeInfosProto* sourcedninfos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sourcedninfos_);
  }
  if (sourcedninfos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sourcedninfos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sourcedninfos, submessage_arena);
    }
    set_has_sourcedninfos();
  } else {
    clear_has_sourcedninfos();
  }
  sourcedninfos_ = sourcedninfos;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.sourceDnInfos)
}

// required .hadoop.hdfs.DatanodeInfosProto targetDnInfos = 3;
inline bool BlockECReconstructionInfoProto::has_targetdninfos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_targetdninfos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockECReconstructionInfoProto::clear_has_targetdninfos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hadoop::hdfs::DatanodeInfosProto& BlockECReconstructionInfoProto::_internal_targetdninfos() const {
  return *targetdninfos_;
}
inline const ::hadoop::hdfs::DatanodeInfosProto& BlockECReconstructionInfoProto::targetdninfos() const {
  const ::hadoop::hdfs::DatanodeInfosProto* p = targetdninfos_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.targetDnInfos)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::DatanodeInfosProto*>(
      &::hadoop::hdfs::_DatanodeInfosProto_default_instance_);
}
inline ::hadoop::hdfs::DatanodeInfosProto* BlockECReconstructionInfoProto::release_targetdninfos() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.targetDnInfos)
  clear_has_targetdninfos();
  ::hadoop::hdfs::DatanodeInfosProto* temp = targetdninfos_;
  targetdninfos_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::DatanodeInfosProto* BlockECReconstructionInfoProto::mutable_targetdninfos() {
  set_has_targetdninfos();
  if (targetdninfos_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::DatanodeInfosProto>(GetArenaNoVirtual());
    targetdninfos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.targetDnInfos)
  return targetdninfos_;
}
inline void BlockECReconstructionInfoProto::set_allocated_targetdninfos(::hadoop::hdfs::DatanodeInfosProto* targetdninfos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(targetdninfos_);
  }
  if (targetdninfos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      targetdninfos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, targetdninfos, submessage_arena);
    }
    set_has_targetdninfos();
  } else {
    clear_has_targetdninfos();
  }
  targetdninfos_ = targetdninfos;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.targetDnInfos)
}

// required .hadoop.hdfs.StorageUuidsProto targetStorageUuids = 4;
inline bool BlockECReconstructionInfoProto::has_targetstorageuuids() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_targetstorageuuids() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockECReconstructionInfoProto::clear_has_targetstorageuuids() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::hadoop::hdfs::StorageUuidsProto& BlockECReconstructionInfoProto::_internal_targetstorageuuids() const {
  return *targetstorageuuids_;
}
inline const ::hadoop::hdfs::StorageUuidsProto& BlockECReconstructionInfoProto::targetstorageuuids() const {
  const ::hadoop::hdfs::StorageUuidsProto* p = targetstorageuuids_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageUuids)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::StorageUuidsProto*>(
      &::hadoop::hdfs::_StorageUuidsProto_default_instance_);
}
inline ::hadoop::hdfs::StorageUuidsProto* BlockECReconstructionInfoProto::release_targetstorageuuids() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageUuids)
  clear_has_targetstorageuuids();
  ::hadoop::hdfs::StorageUuidsProto* temp = targetstorageuuids_;
  targetstorageuuids_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::StorageUuidsProto* BlockECReconstructionInfoProto::mutable_targetstorageuuids() {
  set_has_targetstorageuuids();
  if (targetstorageuuids_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::StorageUuidsProto>(GetArenaNoVirtual());
    targetstorageuuids_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageUuids)
  return targetstorageuuids_;
}
inline void BlockECReconstructionInfoProto::set_allocated_targetstorageuuids(::hadoop::hdfs::StorageUuidsProto* targetstorageuuids) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(targetstorageuuids_);
  }
  if (targetstorageuuids) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      targetstorageuuids = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, targetstorageuuids, submessage_arena);
    }
    set_has_targetstorageuuids();
  } else {
    clear_has_targetstorageuuids();
  }
  targetstorageuuids_ = targetstorageuuids;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageUuids)
}

// required .hadoop.hdfs.StorageTypesProto targetStorageTypes = 5;
inline bool BlockECReconstructionInfoProto::has_targetstoragetypes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_targetstoragetypes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlockECReconstructionInfoProto::clear_has_targetstoragetypes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::hadoop::hdfs::StorageTypesProto& BlockECReconstructionInfoProto::_internal_targetstoragetypes() const {
  return *targetstoragetypes_;
}
inline const ::hadoop::hdfs::StorageTypesProto& BlockECReconstructionInfoProto::targetstoragetypes() const {
  const ::hadoop::hdfs::StorageTypesProto* p = targetstoragetypes_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageTypes)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::StorageTypesProto*>(
      &::hadoop::hdfs::_StorageTypesProto_default_instance_);
}
inline ::hadoop::hdfs::StorageTypesProto* BlockECReconstructionInfoProto::release_targetstoragetypes() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageTypes)
  clear_has_targetstoragetypes();
  ::hadoop::hdfs::StorageTypesProto* temp = targetstoragetypes_;
  targetstoragetypes_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::StorageTypesProto* BlockECReconstructionInfoProto::mutable_targetstoragetypes() {
  set_has_targetstoragetypes();
  if (targetstoragetypes_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::StorageTypesProto>(GetArenaNoVirtual());
    targetstoragetypes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageTypes)
  return targetstoragetypes_;
}
inline void BlockECReconstructionInfoProto::set_allocated_targetstoragetypes(::hadoop::hdfs::StorageTypesProto* targetstoragetypes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(targetstoragetypes_);
  }
  if (targetstoragetypes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      targetstoragetypes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, targetstoragetypes, submessage_arena);
    }
    set_has_targetstoragetypes();
  } else {
    clear_has_targetstoragetypes();
  }
  targetstoragetypes_ = targetstoragetypes;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.targetStorageTypes)
}

// required bytes liveBlockIndices = 6;
inline bool BlockECReconstructionInfoProto::has_liveblockindices() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_liveblockindices() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockECReconstructionInfoProto::clear_has_liveblockindices() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockECReconstructionInfoProto::clear_liveblockindices() {
  liveblockindices_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_liveblockindices();
}
inline const ::std::string& BlockECReconstructionInfoProto::liveblockindices() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
  return liveblockindices_.GetNoArena();
}
inline void BlockECReconstructionInfoProto::set_liveblockindices(const ::std::string& value) {
  set_has_liveblockindices();
  liveblockindices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
}
#if LANG_CXX11
inline void BlockECReconstructionInfoProto::set_liveblockindices(::std::string&& value) {
  set_has_liveblockindices();
  liveblockindices_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
}
#endif
inline void BlockECReconstructionInfoProto::set_liveblockindices(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_liveblockindices();
  liveblockindices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
}
inline void BlockECReconstructionInfoProto::set_liveblockindices(const void* value, size_t size) {
  set_has_liveblockindices();
  liveblockindices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
}
inline ::std::string* BlockECReconstructionInfoProto::mutable_liveblockindices() {
  set_has_liveblockindices();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
  return liveblockindices_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockECReconstructionInfoProto::release_liveblockindices() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
  if (!has_liveblockindices()) {
    return NULL;
  }
  clear_has_liveblockindices();
  return liveblockindices_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockECReconstructionInfoProto::set_allocated_liveblockindices(::std::string* liveblockindices) {
  if (liveblockindices != NULL) {
    set_has_liveblockindices();
  } else {
    clear_has_liveblockindices();
  }
  liveblockindices_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), liveblockindices);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.liveBlockIndices)
}

// required .hadoop.hdfs.ErasureCodingPolicyProto ecPolicy = 7;
inline bool BlockECReconstructionInfoProto::has_ecpolicy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_ecpolicy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BlockECReconstructionInfoProto::clear_has_ecpolicy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::hadoop::hdfs::ErasureCodingPolicyProto& BlockECReconstructionInfoProto::_internal_ecpolicy() const {
  return *ecpolicy_;
}
inline const ::hadoop::hdfs::ErasureCodingPolicyProto& BlockECReconstructionInfoProto::ecpolicy() const {
  const ::hadoop::hdfs::ErasureCodingPolicyProto* p = ecpolicy_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.ecPolicy)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::ErasureCodingPolicyProto*>(
      &::hadoop::hdfs::_ErasureCodingPolicyProto_default_instance_);
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* BlockECReconstructionInfoProto::release_ecpolicy() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.ecPolicy)
  clear_has_ecpolicy();
  ::hadoop::hdfs::ErasureCodingPolicyProto* temp = ecpolicy_;
  ecpolicy_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::ErasureCodingPolicyProto* BlockECReconstructionInfoProto::mutable_ecpolicy() {
  set_has_ecpolicy();
  if (ecpolicy_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::ErasureCodingPolicyProto>(GetArenaNoVirtual());
    ecpolicy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.ecPolicy)
  return ecpolicy_;
}
inline void BlockECReconstructionInfoProto::set_allocated_ecpolicy(::hadoop::hdfs::ErasureCodingPolicyProto* ecpolicy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ecpolicy_);
  }
  if (ecpolicy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ecpolicy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ecpolicy, submessage_arena);
    }
    set_has_ecpolicy();
  } else {
    clear_has_ecpolicy();
  }
  ecpolicy_ = ecpolicy;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.ecPolicy)
}

// optional bytes excludeReconstructedIndices = 8;
inline bool BlockECReconstructionInfoProto::has_excludereconstructedindices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockECReconstructionInfoProto::set_has_excludereconstructedindices() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockECReconstructionInfoProto::clear_has_excludereconstructedindices() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockECReconstructionInfoProto::clear_excludereconstructedindices() {
  excludereconstructedindices_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_excludereconstructedindices();
}
inline const ::std::string& BlockECReconstructionInfoProto::excludereconstructedindices() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
  return excludereconstructedindices_.GetNoArena();
}
inline void BlockECReconstructionInfoProto::set_excludereconstructedindices(const ::std::string& value) {
  set_has_excludereconstructedindices();
  excludereconstructedindices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
}
#if LANG_CXX11
inline void BlockECReconstructionInfoProto::set_excludereconstructedindices(::std::string&& value) {
  set_has_excludereconstructedindices();
  excludereconstructedindices_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
}
#endif
inline void BlockECReconstructionInfoProto::set_excludereconstructedindices(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_excludereconstructedindices();
  excludereconstructedindices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
}
inline void BlockECReconstructionInfoProto::set_excludereconstructedindices(const void* value, size_t size) {
  set_has_excludereconstructedindices();
  excludereconstructedindices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
}
inline ::std::string* BlockECReconstructionInfoProto::mutable_excludereconstructedindices() {
  set_has_excludereconstructedindices();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
  return excludereconstructedindices_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockECReconstructionInfoProto::release_excludereconstructedindices() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
  if (!has_excludereconstructedindices()) {
    return NULL;
  }
  clear_has_excludereconstructedindices();
  return excludereconstructedindices_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockECReconstructionInfoProto::set_allocated_excludereconstructedindices(::std::string* excludereconstructedindices) {
  if (excludereconstructedindices != NULL) {
    set_has_excludereconstructedindices();
  } else {
    clear_has_excludereconstructedindices();
  }
  excludereconstructedindices_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), excludereconstructedindices);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockECReconstructionInfoProto.excludeReconstructedIndices)
}

// -------------------------------------------------------------------

// CodecProto

// required string codec = 1;
inline bool CodecProto::has_codec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodecProto::set_has_codec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CodecProto::clear_has_codec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CodecProto::clear_codec() {
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_codec();
}
inline const ::std::string& CodecProto::codec() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CodecProto.codec)
  return codec_.GetNoArena();
}
inline void CodecProto::set_codec(const ::std::string& value) {
  set_has_codec();
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CodecProto.codec)
}
#if LANG_CXX11
inline void CodecProto::set_codec(::std::string&& value) {
  set_has_codec();
  codec_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CodecProto.codec)
}
#endif
inline void CodecProto::set_codec(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_codec();
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CodecProto.codec)
}
inline void CodecProto::set_codec(const char* value, size_t size) {
  set_has_codec();
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CodecProto.codec)
}
inline ::std::string* CodecProto::mutable_codec() {
  set_has_codec();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CodecProto.codec)
  return codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CodecProto::release_codec() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CodecProto.codec)
  if (!has_codec()) {
    return NULL;
  }
  clear_has_codec();
  return codec_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CodecProto::set_allocated_codec(::std::string* codec) {
  if (codec != NULL) {
    set_has_codec();
  } else {
    clear_has_codec();
  }
  codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CodecProto.codec)
}

// required string coders = 2;
inline bool CodecProto::has_coders() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CodecProto::set_has_coders() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CodecProto::clear_has_coders() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CodecProto::clear_coders() {
  coders_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coders();
}
inline const ::std::string& CodecProto::coders() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CodecProto.coders)
  return coders_.GetNoArena();
}
inline void CodecProto::set_coders(const ::std::string& value) {
  set_has_coders();
  coders_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CodecProto.coders)
}
#if LANG_CXX11
inline void CodecProto::set_coders(::std::string&& value) {
  set_has_coders();
  coders_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CodecProto.coders)
}
#endif
inline void CodecProto::set_coders(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coders();
  coders_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CodecProto.coders)
}
inline void CodecProto::set_coders(const char* value, size_t size) {
  set_has_coders();
  coders_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CodecProto.coders)
}
inline ::std::string* CodecProto::mutable_coders() {
  set_has_coders();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CodecProto.coders)
  return coders_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CodecProto::release_coders() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CodecProto.coders)
  if (!has_coders()) {
    return NULL;
  }
  clear_has_coders();
  return coders_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CodecProto::set_allocated_coders(::std::string* coders) {
  if (coders != NULL) {
    set_has_coders();
  } else {
    clear_has_coders();
  }
  coders_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coders);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CodecProto.coders)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdfs
}  // namespace hadoop

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_erasurecoding_2eproto
