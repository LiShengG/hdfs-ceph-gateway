// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AliasMapProtocol.proto

#ifndef PROTOBUF_INCLUDED_AliasMapProtocol_2eproto
#define PROTOBUF_INCLUDED_AliasMapProtocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "hdfs.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_AliasMapProtocol_2eproto 

namespace protobuf_AliasMapProtocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_AliasMapProtocol_2eproto
namespace hadoop {
namespace hdfs {
class BlockPoolRequestProto;
class BlockPoolRequestProtoDefaultTypeInternal;
extern BlockPoolRequestProtoDefaultTypeInternal _BlockPoolRequestProto_default_instance_;
class BlockPoolResponseProto;
class BlockPoolResponseProtoDefaultTypeInternal;
extern BlockPoolResponseProtoDefaultTypeInternal _BlockPoolResponseProto_default_instance_;
class KeyValueProto;
class KeyValueProtoDefaultTypeInternal;
extern KeyValueProtoDefaultTypeInternal _KeyValueProto_default_instance_;
class ListRequestProto;
class ListRequestProtoDefaultTypeInternal;
extern ListRequestProtoDefaultTypeInternal _ListRequestProto_default_instance_;
class ListResponseProto;
class ListResponseProtoDefaultTypeInternal;
extern ListResponseProtoDefaultTypeInternal _ListResponseProto_default_instance_;
class ReadRequestProto;
class ReadRequestProtoDefaultTypeInternal;
extern ReadRequestProtoDefaultTypeInternal _ReadRequestProto_default_instance_;
class ReadResponseProto;
class ReadResponseProtoDefaultTypeInternal;
extern ReadResponseProtoDefaultTypeInternal _ReadResponseProto_default_instance_;
class WriteRequestProto;
class WriteRequestProtoDefaultTypeInternal;
extern WriteRequestProtoDefaultTypeInternal _WriteRequestProto_default_instance_;
class WriteResponseProto;
class WriteResponseProtoDefaultTypeInternal;
extern WriteResponseProtoDefaultTypeInternal _WriteResponseProto_default_instance_;
}  // namespace hdfs
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::hdfs::BlockPoolRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::BlockPoolRequestProto>(Arena*);
template<> ::hadoop::hdfs::BlockPoolResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::BlockPoolResponseProto>(Arena*);
template<> ::hadoop::hdfs::KeyValueProto* Arena::CreateMaybeMessage<::hadoop::hdfs::KeyValueProto>(Arena*);
template<> ::hadoop::hdfs::ListRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ListRequestProto>(Arena*);
template<> ::hadoop::hdfs::ListResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ListResponseProto>(Arena*);
template<> ::hadoop::hdfs::ReadRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ReadRequestProto>(Arena*);
template<> ::hadoop::hdfs::ReadResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ReadResponseProto>(Arena*);
template<> ::hadoop::hdfs::WriteRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::WriteRequestProto>(Arena*);
template<> ::hadoop::hdfs::WriteResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::WriteResponseProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace hdfs {

// ===================================================================

class KeyValueProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.KeyValueProto) */ {
 public:
  KeyValueProto();
  virtual ~KeyValueProto();

  KeyValueProto(const KeyValueProto& from);

  inline KeyValueProto& operator=(const KeyValueProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValueProto(KeyValueProto&& from) noexcept
    : KeyValueProto() {
    *this = ::std::move(from);
  }

  inline KeyValueProto& operator=(KeyValueProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValueProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValueProto* internal_default_instance() {
    return reinterpret_cast<const KeyValueProto*>(
               &_KeyValueProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(KeyValueProto* other);
  friend void swap(KeyValueProto& a, KeyValueProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValueProto* New() const final {
    return CreateMaybeMessage<KeyValueProto>(NULL);
  }

  KeyValueProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValueProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValueProto& from);
  void MergeFrom(const KeyValueProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hadoop.hdfs.BlockProto key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::hadoop::hdfs::BlockProto& _internal_key() const;
  public:
  const ::hadoop::hdfs::BlockProto& key() const;
  ::hadoop::hdfs::BlockProto* release_key();
  ::hadoop::hdfs::BlockProto* mutable_key();
  void set_allocated_key(::hadoop::hdfs::BlockProto* key);

  // optional .hadoop.hdfs.ProvidedStorageLocationProto value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::hadoop::hdfs::ProvidedStorageLocationProto& _internal_value() const;
  public:
  const ::hadoop::hdfs::ProvidedStorageLocationProto& value() const;
  ::hadoop::hdfs::ProvidedStorageLocationProto* release_value();
  ::hadoop::hdfs::ProvidedStorageLocationProto* mutable_value();
  void set_allocated_value(::hadoop::hdfs::ProvidedStorageLocationProto* value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.KeyValueProto)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::BlockProto* key_;
  ::hadoop::hdfs::ProvidedStorageLocationProto* value_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.WriteRequestProto) */ {
 public:
  WriteRequestProto();
  virtual ~WriteRequestProto();

  WriteRequestProto(const WriteRequestProto& from);

  inline WriteRequestProto& operator=(const WriteRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteRequestProto(WriteRequestProto&& from) noexcept
    : WriteRequestProto() {
    *this = ::std::move(from);
  }

  inline WriteRequestProto& operator=(WriteRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteRequestProto* internal_default_instance() {
    return reinterpret_cast<const WriteRequestProto*>(
               &_WriteRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WriteRequestProto* other);
  friend void swap(WriteRequestProto& a, WriteRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteRequestProto* New() const final {
    return CreateMaybeMessage<WriteRequestProto>(NULL);
  }

  WriteRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteRequestProto& from);
  void MergeFrom(const WriteRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.KeyValueProto keyValuePair = 1;
  bool has_keyvaluepair() const;
  void clear_keyvaluepair();
  static const int kKeyValuePairFieldNumber = 1;
  private:
  const ::hadoop::hdfs::KeyValueProto& _internal_keyvaluepair() const;
  public:
  const ::hadoop::hdfs::KeyValueProto& keyvaluepair() const;
  ::hadoop::hdfs::KeyValueProto* release_keyvaluepair();
  ::hadoop::hdfs::KeyValueProto* mutable_keyvaluepair();
  void set_allocated_keyvaluepair(::hadoop::hdfs::KeyValueProto* keyvaluepair);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.WriteRequestProto)
 private:
  void set_has_keyvaluepair();
  void clear_has_keyvaluepair();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::KeyValueProto* keyvaluepair_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.WriteResponseProto) */ {
 public:
  WriteResponseProto();
  virtual ~WriteResponseProto();

  WriteResponseProto(const WriteResponseProto& from);

  inline WriteResponseProto& operator=(const WriteResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteResponseProto(WriteResponseProto&& from) noexcept
    : WriteResponseProto() {
    *this = ::std::move(from);
  }

  inline WriteResponseProto& operator=(WriteResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteResponseProto* internal_default_instance() {
    return reinterpret_cast<const WriteResponseProto*>(
               &_WriteResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WriteResponseProto* other);
  friend void swap(WriteResponseProto& a, WriteResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteResponseProto* New() const final {
    return CreateMaybeMessage<WriteResponseProto>(NULL);
  }

  WriteResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteResponseProto& from);
  void MergeFrom(const WriteResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.WriteResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ReadRequestProto) */ {
 public:
  ReadRequestProto();
  virtual ~ReadRequestProto();

  ReadRequestProto(const ReadRequestProto& from);

  inline ReadRequestProto& operator=(const ReadRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRequestProto(ReadRequestProto&& from) noexcept
    : ReadRequestProto() {
    *this = ::std::move(from);
  }

  inline ReadRequestProto& operator=(ReadRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRequestProto* internal_default_instance() {
    return reinterpret_cast<const ReadRequestProto*>(
               &_ReadRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ReadRequestProto* other);
  friend void swap(ReadRequestProto& a, ReadRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRequestProto* New() const final {
    return CreateMaybeMessage<ReadRequestProto>(NULL);
  }

  ReadRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRequestProto& from);
  void MergeFrom(const ReadRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.BlockProto key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::hadoop::hdfs::BlockProto& _internal_key() const;
  public:
  const ::hadoop::hdfs::BlockProto& key() const;
  ::hadoop::hdfs::BlockProto* release_key();
  ::hadoop::hdfs::BlockProto* mutable_key();
  void set_allocated_key(::hadoop::hdfs::BlockProto* key);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ReadRequestProto)
 private:
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::BlockProto* key_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ReadResponseProto) */ {
 public:
  ReadResponseProto();
  virtual ~ReadResponseProto();

  ReadResponseProto(const ReadResponseProto& from);

  inline ReadResponseProto& operator=(const ReadResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadResponseProto(ReadResponseProto&& from) noexcept
    : ReadResponseProto() {
    *this = ::std::move(from);
  }

  inline ReadResponseProto& operator=(ReadResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadResponseProto* internal_default_instance() {
    return reinterpret_cast<const ReadResponseProto*>(
               &_ReadResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ReadResponseProto* other);
  friend void swap(ReadResponseProto& a, ReadResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadResponseProto* New() const final {
    return CreateMaybeMessage<ReadResponseProto>(NULL);
  }

  ReadResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadResponseProto& from);
  void MergeFrom(const ReadResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hadoop.hdfs.ProvidedStorageLocationProto value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::hadoop::hdfs::ProvidedStorageLocationProto& _internal_value() const;
  public:
  const ::hadoop::hdfs::ProvidedStorageLocationProto& value() const;
  ::hadoop::hdfs::ProvidedStorageLocationProto* release_value();
  ::hadoop::hdfs::ProvidedStorageLocationProto* mutable_value();
  void set_allocated_value(::hadoop::hdfs::ProvidedStorageLocationProto* value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ReadResponseProto)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::ProvidedStorageLocationProto* value_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ListRequestProto) */ {
 public:
  ListRequestProto();
  virtual ~ListRequestProto();

  ListRequestProto(const ListRequestProto& from);

  inline ListRequestProto& operator=(const ListRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListRequestProto(ListRequestProto&& from) noexcept
    : ListRequestProto() {
    *this = ::std::move(from);
  }

  inline ListRequestProto& operator=(ListRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListRequestProto* internal_default_instance() {
    return reinterpret_cast<const ListRequestProto*>(
               &_ListRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ListRequestProto* other);
  friend void swap(ListRequestProto& a, ListRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListRequestProto* New() const final {
    return CreateMaybeMessage<ListRequestProto>(NULL);
  }

  ListRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListRequestProto& from);
  void MergeFrom(const ListRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hadoop.hdfs.BlockProto marker = 1;
  bool has_marker() const;
  void clear_marker();
  static const int kMarkerFieldNumber = 1;
  private:
  const ::hadoop::hdfs::BlockProto& _internal_marker() const;
  public:
  const ::hadoop::hdfs::BlockProto& marker() const;
  ::hadoop::hdfs::BlockProto* release_marker();
  ::hadoop::hdfs::BlockProto* mutable_marker();
  void set_allocated_marker(::hadoop::hdfs::BlockProto* marker);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ListRequestProto)
 private:
  void set_has_marker();
  void clear_has_marker();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::BlockProto* marker_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ListResponseProto) */ {
 public:
  ListResponseProto();
  virtual ~ListResponseProto();

  ListResponseProto(const ListResponseProto& from);

  inline ListResponseProto& operator=(const ListResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListResponseProto(ListResponseProto&& from) noexcept
    : ListResponseProto() {
    *this = ::std::move(from);
  }

  inline ListResponseProto& operator=(ListResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListResponseProto* internal_default_instance() {
    return reinterpret_cast<const ListResponseProto*>(
               &_ListResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ListResponseProto* other);
  friend void swap(ListResponseProto& a, ListResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListResponseProto* New() const final {
    return CreateMaybeMessage<ListResponseProto>(NULL);
  }

  ListResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListResponseProto& from);
  void MergeFrom(const ListResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.KeyValueProto fileRegions = 1;
  int fileregions_size() const;
  void clear_fileregions();
  static const int kFileRegionsFieldNumber = 1;
  ::hadoop::hdfs::KeyValueProto* mutable_fileregions(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::KeyValueProto >*
      mutable_fileregions();
  const ::hadoop::hdfs::KeyValueProto& fileregions(int index) const;
  ::hadoop::hdfs::KeyValueProto* add_fileregions();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::KeyValueProto >&
      fileregions() const;

  // optional .hadoop.hdfs.BlockProto nextMarker = 2;
  bool has_nextmarker() const;
  void clear_nextmarker();
  static const int kNextMarkerFieldNumber = 2;
  private:
  const ::hadoop::hdfs::BlockProto& _internal_nextmarker() const;
  public:
  const ::hadoop::hdfs::BlockProto& nextmarker() const;
  ::hadoop::hdfs::BlockProto* release_nextmarker();
  ::hadoop::hdfs::BlockProto* mutable_nextmarker();
  void set_allocated_nextmarker(::hadoop::hdfs::BlockProto* nextmarker);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ListResponseProto)
 private:
  void set_has_nextmarker();
  void clear_has_nextmarker();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::KeyValueProto > fileregions_;
  ::hadoop::hdfs::BlockProto* nextmarker_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockPoolRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.BlockPoolRequestProto) */ {
 public:
  BlockPoolRequestProto();
  virtual ~BlockPoolRequestProto();

  BlockPoolRequestProto(const BlockPoolRequestProto& from);

  inline BlockPoolRequestProto& operator=(const BlockPoolRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockPoolRequestProto(BlockPoolRequestProto&& from) noexcept
    : BlockPoolRequestProto() {
    *this = ::std::move(from);
  }

  inline BlockPoolRequestProto& operator=(BlockPoolRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockPoolRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockPoolRequestProto* internal_default_instance() {
    return reinterpret_cast<const BlockPoolRequestProto*>(
               &_BlockPoolRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(BlockPoolRequestProto* other);
  friend void swap(BlockPoolRequestProto& a, BlockPoolRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockPoolRequestProto* New() const final {
    return CreateMaybeMessage<BlockPoolRequestProto>(NULL);
  }

  BlockPoolRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockPoolRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockPoolRequestProto& from);
  void MergeFrom(const BlockPoolRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockPoolRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.BlockPoolRequestProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockPoolResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.BlockPoolResponseProto) */ {
 public:
  BlockPoolResponseProto();
  virtual ~BlockPoolResponseProto();

  BlockPoolResponseProto(const BlockPoolResponseProto& from);

  inline BlockPoolResponseProto& operator=(const BlockPoolResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockPoolResponseProto(BlockPoolResponseProto&& from) noexcept
    : BlockPoolResponseProto() {
    *this = ::std::move(from);
  }

  inline BlockPoolResponseProto& operator=(BlockPoolResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockPoolResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockPoolResponseProto* internal_default_instance() {
    return reinterpret_cast<const BlockPoolResponseProto*>(
               &_BlockPoolResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BlockPoolResponseProto* other);
  friend void swap(BlockPoolResponseProto& a, BlockPoolResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockPoolResponseProto* New() const final {
    return CreateMaybeMessage<BlockPoolResponseProto>(NULL);
  }

  BlockPoolResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockPoolResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockPoolResponseProto& from);
  void MergeFrom(const BlockPoolResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockPoolResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string blockPoolId = 1;
  bool has_blockpoolid() const;
  void clear_blockpoolid();
  static const int kBlockPoolIdFieldNumber = 1;
  const ::std::string& blockpoolid() const;
  void set_blockpoolid(const ::std::string& value);
  #if LANG_CXX11
  void set_blockpoolid(::std::string&& value);
  #endif
  void set_blockpoolid(const char* value);
  void set_blockpoolid(const char* value, size_t size);
  ::std::string* mutable_blockpoolid();
  ::std::string* release_blockpoolid();
  void set_allocated_blockpoolid(::std::string* blockpoolid);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.BlockPoolResponseProto)
 private:
  void set_has_blockpoolid();
  void clear_has_blockpoolid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr blockpoolid_;
  friend struct ::protobuf_AliasMapProtocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KeyValueProto

// optional .hadoop.hdfs.BlockProto key = 1;
inline bool KeyValueProto::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValueProto::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValueProto::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::BlockProto& KeyValueProto::_internal_key() const {
  return *key_;
}
inline const ::hadoop::hdfs::BlockProto& KeyValueProto::key() const {
  const ::hadoop::hdfs::BlockProto* p = key_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.KeyValueProto.key)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::BlockProto*>(
      &::hadoop::hdfs::_BlockProto_default_instance_);
}
inline ::hadoop::hdfs::BlockProto* KeyValueProto::release_key() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.KeyValueProto.key)
  clear_has_key();
  ::hadoop::hdfs::BlockProto* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::BlockProto* KeyValueProto::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::BlockProto>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.KeyValueProto.key)
  return key_;
}
inline void KeyValueProto::set_allocated_key(::hadoop::hdfs::BlockProto* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    set_has_key();
  } else {
    clear_has_key();
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.KeyValueProto.key)
}

// optional .hadoop.hdfs.ProvidedStorageLocationProto value = 2;
inline bool KeyValueProto::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValueProto::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValueProto::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hadoop::hdfs::ProvidedStorageLocationProto& KeyValueProto::_internal_value() const {
  return *value_;
}
inline const ::hadoop::hdfs::ProvidedStorageLocationProto& KeyValueProto::value() const {
  const ::hadoop::hdfs::ProvidedStorageLocationProto* p = value_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.KeyValueProto.value)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::ProvidedStorageLocationProto*>(
      &::hadoop::hdfs::_ProvidedStorageLocationProto_default_instance_);
}
inline ::hadoop::hdfs::ProvidedStorageLocationProto* KeyValueProto::release_value() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.KeyValueProto.value)
  clear_has_value();
  ::hadoop::hdfs::ProvidedStorageLocationProto* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::ProvidedStorageLocationProto* KeyValueProto::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::ProvidedStorageLocationProto>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.KeyValueProto.value)
  return value_;
}
inline void KeyValueProto::set_allocated_value(::hadoop::hdfs::ProvidedStorageLocationProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.KeyValueProto.value)
}

// -------------------------------------------------------------------

// WriteRequestProto

// required .hadoop.hdfs.KeyValueProto keyValuePair = 1;
inline bool WriteRequestProto::has_keyvaluepair() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WriteRequestProto::set_has_keyvaluepair() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WriteRequestProto::clear_has_keyvaluepair() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WriteRequestProto::clear_keyvaluepair() {
  if (keyvaluepair_ != NULL) keyvaluepair_->Clear();
  clear_has_keyvaluepair();
}
inline const ::hadoop::hdfs::KeyValueProto& WriteRequestProto::_internal_keyvaluepair() const {
  return *keyvaluepair_;
}
inline const ::hadoop::hdfs::KeyValueProto& WriteRequestProto::keyvaluepair() const {
  const ::hadoop::hdfs::KeyValueProto* p = keyvaluepair_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.WriteRequestProto.keyValuePair)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::KeyValueProto*>(
      &::hadoop::hdfs::_KeyValueProto_default_instance_);
}
inline ::hadoop::hdfs::KeyValueProto* WriteRequestProto::release_keyvaluepair() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.WriteRequestProto.keyValuePair)
  clear_has_keyvaluepair();
  ::hadoop::hdfs::KeyValueProto* temp = keyvaluepair_;
  keyvaluepair_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::KeyValueProto* WriteRequestProto::mutable_keyvaluepair() {
  set_has_keyvaluepair();
  if (keyvaluepair_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::KeyValueProto>(GetArenaNoVirtual());
    keyvaluepair_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.WriteRequestProto.keyValuePair)
  return keyvaluepair_;
}
inline void WriteRequestProto::set_allocated_keyvaluepair(::hadoop::hdfs::KeyValueProto* keyvaluepair) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete keyvaluepair_;
  }
  if (keyvaluepair) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      keyvaluepair = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, keyvaluepair, submessage_arena);
    }
    set_has_keyvaluepair();
  } else {
    clear_has_keyvaluepair();
  }
  keyvaluepair_ = keyvaluepair;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.WriteRequestProto.keyValuePair)
}

// -------------------------------------------------------------------

// WriteResponseProto

// -------------------------------------------------------------------

// ReadRequestProto

// required .hadoop.hdfs.BlockProto key = 1;
inline bool ReadRequestProto::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadRequestProto::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadRequestProto::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::BlockProto& ReadRequestProto::_internal_key() const {
  return *key_;
}
inline const ::hadoop::hdfs::BlockProto& ReadRequestProto::key() const {
  const ::hadoop::hdfs::BlockProto* p = key_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ReadRequestProto.key)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::BlockProto*>(
      &::hadoop::hdfs::_BlockProto_default_instance_);
}
inline ::hadoop::hdfs::BlockProto* ReadRequestProto::release_key() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ReadRequestProto.key)
  clear_has_key();
  ::hadoop::hdfs::BlockProto* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::BlockProto* ReadRequestProto::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::BlockProto>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ReadRequestProto.key)
  return key_;
}
inline void ReadRequestProto::set_allocated_key(::hadoop::hdfs::BlockProto* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    set_has_key();
  } else {
    clear_has_key();
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ReadRequestProto.key)
}

// -------------------------------------------------------------------

// ReadResponseProto

// optional .hadoop.hdfs.ProvidedStorageLocationProto value = 1;
inline bool ReadResponseProto::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadResponseProto::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadResponseProto::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::ProvidedStorageLocationProto& ReadResponseProto::_internal_value() const {
  return *value_;
}
inline const ::hadoop::hdfs::ProvidedStorageLocationProto& ReadResponseProto::value() const {
  const ::hadoop::hdfs::ProvidedStorageLocationProto* p = value_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ReadResponseProto.value)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::ProvidedStorageLocationProto*>(
      &::hadoop::hdfs::_ProvidedStorageLocationProto_default_instance_);
}
inline ::hadoop::hdfs::ProvidedStorageLocationProto* ReadResponseProto::release_value() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ReadResponseProto.value)
  clear_has_value();
  ::hadoop::hdfs::ProvidedStorageLocationProto* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::ProvidedStorageLocationProto* ReadResponseProto::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::ProvidedStorageLocationProto>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ReadResponseProto.value)
  return value_;
}
inline void ReadResponseProto::set_allocated_value(::hadoop::hdfs::ProvidedStorageLocationProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ReadResponseProto.value)
}

// -------------------------------------------------------------------

// ListRequestProto

// optional .hadoop.hdfs.BlockProto marker = 1;
inline bool ListRequestProto::has_marker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListRequestProto::set_has_marker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListRequestProto::clear_has_marker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::BlockProto& ListRequestProto::_internal_marker() const {
  return *marker_;
}
inline const ::hadoop::hdfs::BlockProto& ListRequestProto::marker() const {
  const ::hadoop::hdfs::BlockProto* p = marker_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListRequestProto.marker)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::BlockProto*>(
      &::hadoop::hdfs::_BlockProto_default_instance_);
}
inline ::hadoop::hdfs::BlockProto* ListRequestProto::release_marker() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ListRequestProto.marker)
  clear_has_marker();
  ::hadoop::hdfs::BlockProto* temp = marker_;
  marker_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::BlockProto* ListRequestProto::mutable_marker() {
  set_has_marker();
  if (marker_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::BlockProto>(GetArenaNoVirtual());
    marker_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ListRequestProto.marker)
  return marker_;
}
inline void ListRequestProto::set_allocated_marker(::hadoop::hdfs::BlockProto* marker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(marker_);
  }
  if (marker) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      marker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, marker, submessage_arena);
    }
    set_has_marker();
  } else {
    clear_has_marker();
  }
  marker_ = marker;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ListRequestProto.marker)
}

// -------------------------------------------------------------------

// ListResponseProto

// repeated .hadoop.hdfs.KeyValueProto fileRegions = 1;
inline int ListResponseProto::fileregions_size() const {
  return fileregions_.size();
}
inline void ListResponseProto::clear_fileregions() {
  fileregions_.Clear();
}
inline ::hadoop::hdfs::KeyValueProto* ListResponseProto::mutable_fileregions(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ListResponseProto.fileRegions)
  return fileregions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::KeyValueProto >*
ListResponseProto::mutable_fileregions() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.ListResponseProto.fileRegions)
  return &fileregions_;
}
inline const ::hadoop::hdfs::KeyValueProto& ListResponseProto::fileregions(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListResponseProto.fileRegions)
  return fileregions_.Get(index);
}
inline ::hadoop::hdfs::KeyValueProto* ListResponseProto::add_fileregions() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.ListResponseProto.fileRegions)
  return fileregions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::KeyValueProto >&
ListResponseProto::fileregions() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.ListResponseProto.fileRegions)
  return fileregions_;
}

// optional .hadoop.hdfs.BlockProto nextMarker = 2;
inline bool ListResponseProto::has_nextmarker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListResponseProto::set_has_nextmarker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListResponseProto::clear_has_nextmarker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hadoop::hdfs::BlockProto& ListResponseProto::_internal_nextmarker() const {
  return *nextmarker_;
}
inline const ::hadoop::hdfs::BlockProto& ListResponseProto::nextmarker() const {
  const ::hadoop::hdfs::BlockProto* p = nextmarker_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListResponseProto.nextMarker)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::BlockProto*>(
      &::hadoop::hdfs::_BlockProto_default_instance_);
}
inline ::hadoop::hdfs::BlockProto* ListResponseProto::release_nextmarker() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ListResponseProto.nextMarker)
  clear_has_nextmarker();
  ::hadoop::hdfs::BlockProto* temp = nextmarker_;
  nextmarker_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::BlockProto* ListResponseProto::mutable_nextmarker() {
  set_has_nextmarker();
  if (nextmarker_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::BlockProto>(GetArenaNoVirtual());
    nextmarker_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ListResponseProto.nextMarker)
  return nextmarker_;
}
inline void ListResponseProto::set_allocated_nextmarker(::hadoop::hdfs::BlockProto* nextmarker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(nextmarker_);
  }
  if (nextmarker) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nextmarker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nextmarker, submessage_arena);
    }
    set_has_nextmarker();
  } else {
    clear_has_nextmarker();
  }
  nextmarker_ = nextmarker;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ListResponseProto.nextMarker)
}

// -------------------------------------------------------------------

// BlockPoolRequestProto

// -------------------------------------------------------------------

// BlockPoolResponseProto

// required string blockPoolId = 1;
inline bool BlockPoolResponseProto::has_blockpoolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockPoolResponseProto::set_has_blockpoolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockPoolResponseProto::clear_has_blockpoolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockPoolResponseProto::clear_blockpoolid() {
  blockpoolid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blockpoolid();
}
inline const ::std::string& BlockPoolResponseProto::blockpoolid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
  return blockpoolid_.GetNoArena();
}
inline void BlockPoolResponseProto::set_blockpoolid(const ::std::string& value) {
  set_has_blockpoolid();
  blockpoolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
}
#if LANG_CXX11
inline void BlockPoolResponseProto::set_blockpoolid(::std::string&& value) {
  set_has_blockpoolid();
  blockpoolid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
}
#endif
inline void BlockPoolResponseProto::set_blockpoolid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_blockpoolid();
  blockpoolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
}
inline void BlockPoolResponseProto::set_blockpoolid(const char* value, size_t size) {
  set_has_blockpoolid();
  blockpoolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
}
inline ::std::string* BlockPoolResponseProto::mutable_blockpoolid() {
  set_has_blockpoolid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
  return blockpoolid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockPoolResponseProto::release_blockpoolid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
  if (!has_blockpoolid()) {
    return NULL;
  }
  clear_has_blockpoolid();
  return blockpoolid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockPoolResponseProto::set_allocated_blockpoolid(::std::string* blockpoolid) {
  if (blockpoolid != NULL) {
    set_has_blockpoolid();
  } else {
    clear_has_blockpoolid();
  }
  blockpoolid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockpoolid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.BlockPoolResponseProto.blockPoolId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdfs
}  // namespace hadoop

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_AliasMapProtocol_2eproto
