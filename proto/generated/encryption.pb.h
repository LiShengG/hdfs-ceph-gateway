// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: encryption.proto

#ifndef PROTOBUF_INCLUDED_encryption_2eproto
#define PROTOBUF_INCLUDED_encryption_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "hdfs.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_encryption_2eproto 

namespace protobuf_encryption_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_encryption_2eproto
namespace hadoop {
namespace hdfs {
class CreateEncryptionZoneRequestProto;
class CreateEncryptionZoneRequestProtoDefaultTypeInternal;
extern CreateEncryptionZoneRequestProtoDefaultTypeInternal _CreateEncryptionZoneRequestProto_default_instance_;
class CreateEncryptionZoneResponseProto;
class CreateEncryptionZoneResponseProtoDefaultTypeInternal;
extern CreateEncryptionZoneResponseProtoDefaultTypeInternal _CreateEncryptionZoneResponseProto_default_instance_;
class EncryptionZoneProto;
class EncryptionZoneProtoDefaultTypeInternal;
extern EncryptionZoneProtoDefaultTypeInternal _EncryptionZoneProto_default_instance_;
class GetEZForPathRequestProto;
class GetEZForPathRequestProtoDefaultTypeInternal;
extern GetEZForPathRequestProtoDefaultTypeInternal _GetEZForPathRequestProto_default_instance_;
class GetEZForPathResponseProto;
class GetEZForPathResponseProtoDefaultTypeInternal;
extern GetEZForPathResponseProtoDefaultTypeInternal _GetEZForPathResponseProto_default_instance_;
class ListEncryptionZonesRequestProto;
class ListEncryptionZonesRequestProtoDefaultTypeInternal;
extern ListEncryptionZonesRequestProtoDefaultTypeInternal _ListEncryptionZonesRequestProto_default_instance_;
class ListEncryptionZonesResponseProto;
class ListEncryptionZonesResponseProtoDefaultTypeInternal;
extern ListEncryptionZonesResponseProtoDefaultTypeInternal _ListEncryptionZonesResponseProto_default_instance_;
class ListReencryptionStatusRequestProto;
class ListReencryptionStatusRequestProtoDefaultTypeInternal;
extern ListReencryptionStatusRequestProtoDefaultTypeInternal _ListReencryptionStatusRequestProto_default_instance_;
class ListReencryptionStatusResponseProto;
class ListReencryptionStatusResponseProtoDefaultTypeInternal;
extern ListReencryptionStatusResponseProtoDefaultTypeInternal _ListReencryptionStatusResponseProto_default_instance_;
class ReencryptEncryptionZoneRequestProto;
class ReencryptEncryptionZoneRequestProtoDefaultTypeInternal;
extern ReencryptEncryptionZoneRequestProtoDefaultTypeInternal _ReencryptEncryptionZoneRequestProto_default_instance_;
class ReencryptEncryptionZoneResponseProto;
class ReencryptEncryptionZoneResponseProtoDefaultTypeInternal;
extern ReencryptEncryptionZoneResponseProtoDefaultTypeInternal _ReencryptEncryptionZoneResponseProto_default_instance_;
class ZoneReencryptionStatusProto;
class ZoneReencryptionStatusProtoDefaultTypeInternal;
extern ZoneReencryptionStatusProtoDefaultTypeInternal _ZoneReencryptionStatusProto_default_instance_;
}  // namespace hdfs
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::hdfs::CreateEncryptionZoneRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::CreateEncryptionZoneRequestProto>(Arena*);
template<> ::hadoop::hdfs::CreateEncryptionZoneResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::CreateEncryptionZoneResponseProto>(Arena*);
template<> ::hadoop::hdfs::EncryptionZoneProto* Arena::CreateMaybeMessage<::hadoop::hdfs::EncryptionZoneProto>(Arena*);
template<> ::hadoop::hdfs::GetEZForPathRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetEZForPathRequestProto>(Arena*);
template<> ::hadoop::hdfs::GetEZForPathResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::GetEZForPathResponseProto>(Arena*);
template<> ::hadoop::hdfs::ListEncryptionZonesRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ListEncryptionZonesRequestProto>(Arena*);
template<> ::hadoop::hdfs::ListEncryptionZonesResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ListEncryptionZonesResponseProto>(Arena*);
template<> ::hadoop::hdfs::ListReencryptionStatusRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ListReencryptionStatusRequestProto>(Arena*);
template<> ::hadoop::hdfs::ListReencryptionStatusResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ListReencryptionStatusResponseProto>(Arena*);
template<> ::hadoop::hdfs::ReencryptEncryptionZoneRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ReencryptEncryptionZoneRequestProto>(Arena*);
template<> ::hadoop::hdfs::ReencryptEncryptionZoneResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ReencryptEncryptionZoneResponseProto>(Arena*);
template<> ::hadoop::hdfs::ZoneReencryptionStatusProto* Arena::CreateMaybeMessage<::hadoop::hdfs::ZoneReencryptionStatusProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace hdfs {

enum ReencryptActionProto {
  CANCEL_REENCRYPT = 1,
  START_REENCRYPT = 2
};
bool ReencryptActionProto_IsValid(int value);
const ReencryptActionProto ReencryptActionProto_MIN = CANCEL_REENCRYPT;
const ReencryptActionProto ReencryptActionProto_MAX = START_REENCRYPT;
const int ReencryptActionProto_ARRAYSIZE = ReencryptActionProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReencryptActionProto_descriptor();
inline const ::std::string& ReencryptActionProto_Name(ReencryptActionProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReencryptActionProto_descriptor(), value);
}
inline bool ReencryptActionProto_Parse(
    const ::std::string& name, ReencryptActionProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReencryptActionProto>(
    ReencryptActionProto_descriptor(), name, value);
}
enum ReencryptionStateProto {
  SUBMITTED = 1,
  PROCESSING = 2,
  COMPLETED = 3
};
bool ReencryptionStateProto_IsValid(int value);
const ReencryptionStateProto ReencryptionStateProto_MIN = SUBMITTED;
const ReencryptionStateProto ReencryptionStateProto_MAX = COMPLETED;
const int ReencryptionStateProto_ARRAYSIZE = ReencryptionStateProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReencryptionStateProto_descriptor();
inline const ::std::string& ReencryptionStateProto_Name(ReencryptionStateProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReencryptionStateProto_descriptor(), value);
}
inline bool ReencryptionStateProto_Parse(
    const ::std::string& name, ReencryptionStateProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReencryptionStateProto>(
    ReencryptionStateProto_descriptor(), name, value);
}
// ===================================================================

class CreateEncryptionZoneRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.CreateEncryptionZoneRequestProto) */ {
 public:
  CreateEncryptionZoneRequestProto();
  virtual ~CreateEncryptionZoneRequestProto();

  CreateEncryptionZoneRequestProto(const CreateEncryptionZoneRequestProto& from);

  inline CreateEncryptionZoneRequestProto& operator=(const CreateEncryptionZoneRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateEncryptionZoneRequestProto(CreateEncryptionZoneRequestProto&& from) noexcept
    : CreateEncryptionZoneRequestProto() {
    *this = ::std::move(from);
  }

  inline CreateEncryptionZoneRequestProto& operator=(CreateEncryptionZoneRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateEncryptionZoneRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateEncryptionZoneRequestProto* internal_default_instance() {
    return reinterpret_cast<const CreateEncryptionZoneRequestProto*>(
               &_CreateEncryptionZoneRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CreateEncryptionZoneRequestProto* other);
  friend void swap(CreateEncryptionZoneRequestProto& a, CreateEncryptionZoneRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateEncryptionZoneRequestProto* New() const final {
    return CreateMaybeMessage<CreateEncryptionZoneRequestProto>(NULL);
  }

  CreateEncryptionZoneRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateEncryptionZoneRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateEncryptionZoneRequestProto& from);
  void MergeFrom(const CreateEncryptionZoneRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEncryptionZoneRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // optional string keyName = 2;
  bool has_keyname() const;
  void clear_keyname();
  static const int kKeyNameFieldNumber = 2;
  const ::std::string& keyname() const;
  void set_keyname(const ::std::string& value);
  #if LANG_CXX11
  void set_keyname(::std::string&& value);
  #endif
  void set_keyname(const char* value);
  void set_keyname(const char* value, size_t size);
  ::std::string* mutable_keyname();
  ::std::string* release_keyname();
  void set_allocated_keyname(::std::string* keyname);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.CreateEncryptionZoneRequestProto)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_keyname();
  void clear_has_keyname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  ::google::protobuf::internal::ArenaStringPtr keyname_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateEncryptionZoneResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.CreateEncryptionZoneResponseProto) */ {
 public:
  CreateEncryptionZoneResponseProto();
  virtual ~CreateEncryptionZoneResponseProto();

  CreateEncryptionZoneResponseProto(const CreateEncryptionZoneResponseProto& from);

  inline CreateEncryptionZoneResponseProto& operator=(const CreateEncryptionZoneResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateEncryptionZoneResponseProto(CreateEncryptionZoneResponseProto&& from) noexcept
    : CreateEncryptionZoneResponseProto() {
    *this = ::std::move(from);
  }

  inline CreateEncryptionZoneResponseProto& operator=(CreateEncryptionZoneResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateEncryptionZoneResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateEncryptionZoneResponseProto* internal_default_instance() {
    return reinterpret_cast<const CreateEncryptionZoneResponseProto*>(
               &_CreateEncryptionZoneResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CreateEncryptionZoneResponseProto* other);
  friend void swap(CreateEncryptionZoneResponseProto& a, CreateEncryptionZoneResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateEncryptionZoneResponseProto* New() const final {
    return CreateMaybeMessage<CreateEncryptionZoneResponseProto>(NULL);
  }

  CreateEncryptionZoneResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateEncryptionZoneResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateEncryptionZoneResponseProto& from);
  void MergeFrom(const CreateEncryptionZoneResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEncryptionZoneResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.CreateEncryptionZoneResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListEncryptionZonesRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ListEncryptionZonesRequestProto) */ {
 public:
  ListEncryptionZonesRequestProto();
  virtual ~ListEncryptionZonesRequestProto();

  ListEncryptionZonesRequestProto(const ListEncryptionZonesRequestProto& from);

  inline ListEncryptionZonesRequestProto& operator=(const ListEncryptionZonesRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListEncryptionZonesRequestProto(ListEncryptionZonesRequestProto&& from) noexcept
    : ListEncryptionZonesRequestProto() {
    *this = ::std::move(from);
  }

  inline ListEncryptionZonesRequestProto& operator=(ListEncryptionZonesRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListEncryptionZonesRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListEncryptionZonesRequestProto* internal_default_instance() {
    return reinterpret_cast<const ListEncryptionZonesRequestProto*>(
               &_ListEncryptionZonesRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ListEncryptionZonesRequestProto* other);
  friend void swap(ListEncryptionZonesRequestProto& a, ListEncryptionZonesRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListEncryptionZonesRequestProto* New() const final {
    return CreateMaybeMessage<ListEncryptionZonesRequestProto>(NULL);
  }

  ListEncryptionZonesRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListEncryptionZonesRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListEncryptionZonesRequestProto& from);
  void MergeFrom(const ListEncryptionZonesRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEncryptionZonesRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ListEncryptionZonesRequestProto)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 id_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EncryptionZoneProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.EncryptionZoneProto) */ {
 public:
  EncryptionZoneProto();
  virtual ~EncryptionZoneProto();

  EncryptionZoneProto(const EncryptionZoneProto& from);

  inline EncryptionZoneProto& operator=(const EncryptionZoneProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EncryptionZoneProto(EncryptionZoneProto&& from) noexcept
    : EncryptionZoneProto() {
    *this = ::std::move(from);
  }

  inline EncryptionZoneProto& operator=(EncryptionZoneProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptionZoneProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EncryptionZoneProto* internal_default_instance() {
    return reinterpret_cast<const EncryptionZoneProto*>(
               &_EncryptionZoneProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(EncryptionZoneProto* other);
  friend void swap(EncryptionZoneProto& a, EncryptionZoneProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EncryptionZoneProto* New() const final {
    return CreateMaybeMessage<EncryptionZoneProto>(NULL);
  }

  EncryptionZoneProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EncryptionZoneProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EncryptionZoneProto& from);
  void MergeFrom(const EncryptionZoneProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncryptionZoneProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required string keyName = 5;
  bool has_keyname() const;
  void clear_keyname();
  static const int kKeyNameFieldNumber = 5;
  const ::std::string& keyname() const;
  void set_keyname(const ::std::string& value);
  #if LANG_CXX11
  void set_keyname(::std::string&& value);
  #endif
  void set_keyname(const char* value);
  void set_keyname(const char* value, size_t size);
  ::std::string* mutable_keyname();
  ::std::string* release_keyname();
  void set_allocated_keyname(::std::string* keyname);

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // required .hadoop.hdfs.CipherSuiteProto suite = 3;
  bool has_suite() const;
  void clear_suite();
  static const int kSuiteFieldNumber = 3;
  ::hadoop::hdfs::CipherSuiteProto suite() const;
  void set_suite(::hadoop::hdfs::CipherSuiteProto value);

  // required .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 4;
  bool has_cryptoprotocolversion() const;
  void clear_cryptoprotocolversion();
  static const int kCryptoProtocolVersionFieldNumber = 4;
  ::hadoop::hdfs::CryptoProtocolVersionProto cryptoprotocolversion() const;
  void set_cryptoprotocolversion(::hadoop::hdfs::CryptoProtocolVersionProto value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.EncryptionZoneProto)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_path();
  void clear_has_path();
  void set_has_suite();
  void clear_has_suite();
  void set_has_cryptoprotocolversion();
  void clear_has_cryptoprotocolversion();
  void set_has_keyname();
  void clear_has_keyname();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr keyname_;
  ::google::protobuf::int64 id_;
  int suite_;
  int cryptoprotocolversion_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListEncryptionZonesResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ListEncryptionZonesResponseProto) */ {
 public:
  ListEncryptionZonesResponseProto();
  virtual ~ListEncryptionZonesResponseProto();

  ListEncryptionZonesResponseProto(const ListEncryptionZonesResponseProto& from);

  inline ListEncryptionZonesResponseProto& operator=(const ListEncryptionZonesResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListEncryptionZonesResponseProto(ListEncryptionZonesResponseProto&& from) noexcept
    : ListEncryptionZonesResponseProto() {
    *this = ::std::move(from);
  }

  inline ListEncryptionZonesResponseProto& operator=(ListEncryptionZonesResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListEncryptionZonesResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListEncryptionZonesResponseProto* internal_default_instance() {
    return reinterpret_cast<const ListEncryptionZonesResponseProto*>(
               &_ListEncryptionZonesResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ListEncryptionZonesResponseProto* other);
  friend void swap(ListEncryptionZonesResponseProto& a, ListEncryptionZonesResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListEncryptionZonesResponseProto* New() const final {
    return CreateMaybeMessage<ListEncryptionZonesResponseProto>(NULL);
  }

  ListEncryptionZonesResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListEncryptionZonesResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListEncryptionZonesResponseProto& from);
  void MergeFrom(const ListEncryptionZonesResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEncryptionZonesResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.EncryptionZoneProto zones = 1;
  int zones_size() const;
  void clear_zones();
  static const int kZonesFieldNumber = 1;
  ::hadoop::hdfs::EncryptionZoneProto* mutable_zones(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EncryptionZoneProto >*
      mutable_zones();
  const ::hadoop::hdfs::EncryptionZoneProto& zones(int index) const;
  ::hadoop::hdfs::EncryptionZoneProto* add_zones();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EncryptionZoneProto >&
      zones() const;

  // required bool hasMore = 2;
  bool has_hasmore() const;
  void clear_hasmore();
  static const int kHasMoreFieldNumber = 2;
  bool hasmore() const;
  void set_hasmore(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ListEncryptionZonesResponseProto)
 private:
  void set_has_hasmore();
  void clear_has_hasmore();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EncryptionZoneProto > zones_;
  bool hasmore_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReencryptEncryptionZoneRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ReencryptEncryptionZoneRequestProto) */ {
 public:
  ReencryptEncryptionZoneRequestProto();
  virtual ~ReencryptEncryptionZoneRequestProto();

  ReencryptEncryptionZoneRequestProto(const ReencryptEncryptionZoneRequestProto& from);

  inline ReencryptEncryptionZoneRequestProto& operator=(const ReencryptEncryptionZoneRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReencryptEncryptionZoneRequestProto(ReencryptEncryptionZoneRequestProto&& from) noexcept
    : ReencryptEncryptionZoneRequestProto() {
    *this = ::std::move(from);
  }

  inline ReencryptEncryptionZoneRequestProto& operator=(ReencryptEncryptionZoneRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReencryptEncryptionZoneRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReencryptEncryptionZoneRequestProto* internal_default_instance() {
    return reinterpret_cast<const ReencryptEncryptionZoneRequestProto*>(
               &_ReencryptEncryptionZoneRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ReencryptEncryptionZoneRequestProto* other);
  friend void swap(ReencryptEncryptionZoneRequestProto& a, ReencryptEncryptionZoneRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReencryptEncryptionZoneRequestProto* New() const final {
    return CreateMaybeMessage<ReencryptEncryptionZoneRequestProto>(NULL);
  }

  ReencryptEncryptionZoneRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReencryptEncryptionZoneRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReencryptEncryptionZoneRequestProto& from);
  void MergeFrom(const ReencryptEncryptionZoneRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReencryptEncryptionZoneRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string zone = 2;
  bool has_zone() const;
  void clear_zone();
  static const int kZoneFieldNumber = 2;
  const ::std::string& zone() const;
  void set_zone(const ::std::string& value);
  #if LANG_CXX11
  void set_zone(::std::string&& value);
  #endif
  void set_zone(const char* value);
  void set_zone(const char* value, size_t size);
  ::std::string* mutable_zone();
  ::std::string* release_zone();
  void set_allocated_zone(::std::string* zone);

  // required .hadoop.hdfs.ReencryptActionProto action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::hadoop::hdfs::ReencryptActionProto action() const;
  void set_action(::hadoop::hdfs::ReencryptActionProto value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ReencryptEncryptionZoneRequestProto)
 private:
  void set_has_action();
  void clear_has_action();
  void set_has_zone();
  void clear_has_zone();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr zone_;
  int action_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReencryptEncryptionZoneResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ReencryptEncryptionZoneResponseProto) */ {
 public:
  ReencryptEncryptionZoneResponseProto();
  virtual ~ReencryptEncryptionZoneResponseProto();

  ReencryptEncryptionZoneResponseProto(const ReencryptEncryptionZoneResponseProto& from);

  inline ReencryptEncryptionZoneResponseProto& operator=(const ReencryptEncryptionZoneResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReencryptEncryptionZoneResponseProto(ReencryptEncryptionZoneResponseProto&& from) noexcept
    : ReencryptEncryptionZoneResponseProto() {
    *this = ::std::move(from);
  }

  inline ReencryptEncryptionZoneResponseProto& operator=(ReencryptEncryptionZoneResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReencryptEncryptionZoneResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReencryptEncryptionZoneResponseProto* internal_default_instance() {
    return reinterpret_cast<const ReencryptEncryptionZoneResponseProto*>(
               &_ReencryptEncryptionZoneResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ReencryptEncryptionZoneResponseProto* other);
  friend void swap(ReencryptEncryptionZoneResponseProto& a, ReencryptEncryptionZoneResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReencryptEncryptionZoneResponseProto* New() const final {
    return CreateMaybeMessage<ReencryptEncryptionZoneResponseProto>(NULL);
  }

  ReencryptEncryptionZoneResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReencryptEncryptionZoneResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReencryptEncryptionZoneResponseProto& from);
  void MergeFrom(const ReencryptEncryptionZoneResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReencryptEncryptionZoneResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ReencryptEncryptionZoneResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListReencryptionStatusRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ListReencryptionStatusRequestProto) */ {
 public:
  ListReencryptionStatusRequestProto();
  virtual ~ListReencryptionStatusRequestProto();

  ListReencryptionStatusRequestProto(const ListReencryptionStatusRequestProto& from);

  inline ListReencryptionStatusRequestProto& operator=(const ListReencryptionStatusRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListReencryptionStatusRequestProto(ListReencryptionStatusRequestProto&& from) noexcept
    : ListReencryptionStatusRequestProto() {
    *this = ::std::move(from);
  }

  inline ListReencryptionStatusRequestProto& operator=(ListReencryptionStatusRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListReencryptionStatusRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListReencryptionStatusRequestProto* internal_default_instance() {
    return reinterpret_cast<const ListReencryptionStatusRequestProto*>(
               &_ListReencryptionStatusRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ListReencryptionStatusRequestProto* other);
  friend void swap(ListReencryptionStatusRequestProto& a, ListReencryptionStatusRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListReencryptionStatusRequestProto* New() const final {
    return CreateMaybeMessage<ListReencryptionStatusRequestProto>(NULL);
  }

  ListReencryptionStatusRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListReencryptionStatusRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListReencryptionStatusRequestProto& from);
  void MergeFrom(const ListReencryptionStatusRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListReencryptionStatusRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ListReencryptionStatusRequestProto)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 id_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ZoneReencryptionStatusProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ZoneReencryptionStatusProto) */ {
 public:
  ZoneReencryptionStatusProto();
  virtual ~ZoneReencryptionStatusProto();

  ZoneReencryptionStatusProto(const ZoneReencryptionStatusProto& from);

  inline ZoneReencryptionStatusProto& operator=(const ZoneReencryptionStatusProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZoneReencryptionStatusProto(ZoneReencryptionStatusProto&& from) noexcept
    : ZoneReencryptionStatusProto() {
    *this = ::std::move(from);
  }

  inline ZoneReencryptionStatusProto& operator=(ZoneReencryptionStatusProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZoneReencryptionStatusProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZoneReencryptionStatusProto* internal_default_instance() {
    return reinterpret_cast<const ZoneReencryptionStatusProto*>(
               &_ZoneReencryptionStatusProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ZoneReencryptionStatusProto* other);
  friend void swap(ZoneReencryptionStatusProto& a, ZoneReencryptionStatusProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZoneReencryptionStatusProto* New() const final {
    return CreateMaybeMessage<ZoneReencryptionStatusProto>(NULL);
  }

  ZoneReencryptionStatusProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ZoneReencryptionStatusProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ZoneReencryptionStatusProto& from);
  void MergeFrom(const ZoneReencryptionStatusProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoneReencryptionStatusProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required string ezKeyVersionName = 4;
  bool has_ezkeyversionname() const;
  void clear_ezkeyversionname();
  static const int kEzKeyVersionNameFieldNumber = 4;
  const ::std::string& ezkeyversionname() const;
  void set_ezkeyversionname(const ::std::string& value);
  #if LANG_CXX11
  void set_ezkeyversionname(::std::string&& value);
  #endif
  void set_ezkeyversionname(const char* value);
  void set_ezkeyversionname(const char* value, size_t size);
  ::std::string* mutable_ezkeyversionname();
  ::std::string* release_ezkeyversionname();
  void set_allocated_ezkeyversionname(::std::string* ezkeyversionname);

  // optional string lastFile = 10;
  bool has_lastfile() const;
  void clear_lastfile();
  static const int kLastFileFieldNumber = 10;
  const ::std::string& lastfile() const;
  void set_lastfile(const ::std::string& value);
  #if LANG_CXX11
  void set_lastfile(::std::string&& value);
  #endif
  void set_lastfile(const char* value);
  void set_lastfile(const char* value, size_t size);
  ::std::string* mutable_lastfile();
  ::std::string* release_lastfile();
  void set_allocated_lastfile(::std::string* lastfile);

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // required int64 submissionTime = 5;
  bool has_submissiontime() const;
  void clear_submissiontime();
  static const int kSubmissionTimeFieldNumber = 5;
  ::google::protobuf::int64 submissiontime() const;
  void set_submissiontime(::google::protobuf::int64 value);

  // required int64 numReencrypted = 7;
  bool has_numreencrypted() const;
  void clear_numreencrypted();
  static const int kNumReencryptedFieldNumber = 7;
  ::google::protobuf::int64 numreencrypted() const;
  void set_numreencrypted(::google::protobuf::int64 value);

  // required int64 numFailures = 8;
  bool has_numfailures() const;
  void clear_numfailures();
  static const int kNumFailuresFieldNumber = 8;
  ::google::protobuf::int64 numfailures() const;
  void set_numfailures(::google::protobuf::int64 value);

  // optional int64 completionTime = 9;
  bool has_completiontime() const;
  void clear_completiontime();
  static const int kCompletionTimeFieldNumber = 9;
  ::google::protobuf::int64 completiontime() const;
  void set_completiontime(::google::protobuf::int64 value);

  // required bool canceled = 6;
  bool has_canceled() const;
  void clear_canceled();
  static const int kCanceledFieldNumber = 6;
  bool canceled() const;
  void set_canceled(bool value);

  // required .hadoop.hdfs.ReencryptionStateProto state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::hadoop::hdfs::ReencryptionStateProto state() const;
  void set_state(::hadoop::hdfs::ReencryptionStateProto value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ZoneReencryptionStatusProto)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_path();
  void clear_has_path();
  void set_has_state();
  void clear_has_state();
  void set_has_ezkeyversionname();
  void clear_has_ezkeyversionname();
  void set_has_submissiontime();
  void clear_has_submissiontime();
  void set_has_canceled();
  void clear_has_canceled();
  void set_has_numreencrypted();
  void clear_has_numreencrypted();
  void set_has_numfailures();
  void clear_has_numfailures();
  void set_has_completiontime();
  void clear_has_completiontime();
  void set_has_lastfile();
  void clear_has_lastfile();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr ezkeyversionname_;
  ::google::protobuf::internal::ArenaStringPtr lastfile_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 submissiontime_;
  ::google::protobuf::int64 numreencrypted_;
  ::google::protobuf::int64 numfailures_;
  ::google::protobuf::int64 completiontime_;
  bool canceled_;
  int state_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListReencryptionStatusResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.ListReencryptionStatusResponseProto) */ {
 public:
  ListReencryptionStatusResponseProto();
  virtual ~ListReencryptionStatusResponseProto();

  ListReencryptionStatusResponseProto(const ListReencryptionStatusResponseProto& from);

  inline ListReencryptionStatusResponseProto& operator=(const ListReencryptionStatusResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListReencryptionStatusResponseProto(ListReencryptionStatusResponseProto&& from) noexcept
    : ListReencryptionStatusResponseProto() {
    *this = ::std::move(from);
  }

  inline ListReencryptionStatusResponseProto& operator=(ListReencryptionStatusResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListReencryptionStatusResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListReencryptionStatusResponseProto* internal_default_instance() {
    return reinterpret_cast<const ListReencryptionStatusResponseProto*>(
               &_ListReencryptionStatusResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ListReencryptionStatusResponseProto* other);
  friend void swap(ListReencryptionStatusResponseProto& a, ListReencryptionStatusResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListReencryptionStatusResponseProto* New() const final {
    return CreateMaybeMessage<ListReencryptionStatusResponseProto>(NULL);
  }

  ListReencryptionStatusResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListReencryptionStatusResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListReencryptionStatusResponseProto& from);
  void MergeFrom(const ListReencryptionStatusResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListReencryptionStatusResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.ZoneReencryptionStatusProto statuses = 1;
  int statuses_size() const;
  void clear_statuses();
  static const int kStatusesFieldNumber = 1;
  ::hadoop::hdfs::ZoneReencryptionStatusProto* mutable_statuses(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ZoneReencryptionStatusProto >*
      mutable_statuses();
  const ::hadoop::hdfs::ZoneReencryptionStatusProto& statuses(int index) const;
  ::hadoop::hdfs::ZoneReencryptionStatusProto* add_statuses();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ZoneReencryptionStatusProto >&
      statuses() const;

  // required bool hasMore = 2;
  bool has_hasmore() const;
  void clear_hasmore();
  static const int kHasMoreFieldNumber = 2;
  bool hasmore() const;
  void set_hasmore(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.ListReencryptionStatusResponseProto)
 private:
  void set_has_hasmore();
  void clear_has_hasmore();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ZoneReencryptionStatusProto > statuses_;
  bool hasmore_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEZForPathRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetEZForPathRequestProto) */ {
 public:
  GetEZForPathRequestProto();
  virtual ~GetEZForPathRequestProto();

  GetEZForPathRequestProto(const GetEZForPathRequestProto& from);

  inline GetEZForPathRequestProto& operator=(const GetEZForPathRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetEZForPathRequestProto(GetEZForPathRequestProto&& from) noexcept
    : GetEZForPathRequestProto() {
    *this = ::std::move(from);
  }

  inline GetEZForPathRequestProto& operator=(GetEZForPathRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEZForPathRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEZForPathRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetEZForPathRequestProto*>(
               &_GetEZForPathRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetEZForPathRequestProto* other);
  friend void swap(GetEZForPathRequestProto& a, GetEZForPathRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEZForPathRequestProto* New() const final {
    return CreateMaybeMessage<GetEZForPathRequestProto>(NULL);
  }

  GetEZForPathRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetEZForPathRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetEZForPathRequestProto& from);
  void MergeFrom(const GetEZForPathRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEZForPathRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetEZForPathRequestProto)
 private:
  void set_has_src();
  void clear_has_src();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEZForPathResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.GetEZForPathResponseProto) */ {
 public:
  GetEZForPathResponseProto();
  virtual ~GetEZForPathResponseProto();

  GetEZForPathResponseProto(const GetEZForPathResponseProto& from);

  inline GetEZForPathResponseProto& operator=(const GetEZForPathResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetEZForPathResponseProto(GetEZForPathResponseProto&& from) noexcept
    : GetEZForPathResponseProto() {
    *this = ::std::move(from);
  }

  inline GetEZForPathResponseProto& operator=(GetEZForPathResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEZForPathResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEZForPathResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetEZForPathResponseProto*>(
               &_GetEZForPathResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetEZForPathResponseProto* other);
  friend void swap(GetEZForPathResponseProto& a, GetEZForPathResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEZForPathResponseProto* New() const final {
    return CreateMaybeMessage<GetEZForPathResponseProto>(NULL);
  }

  GetEZForPathResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetEZForPathResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetEZForPathResponseProto& from);
  void MergeFrom(const GetEZForPathResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEZForPathResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hadoop.hdfs.EncryptionZoneProto zone = 1;
  bool has_zone() const;
  void clear_zone();
  static const int kZoneFieldNumber = 1;
  private:
  const ::hadoop::hdfs::EncryptionZoneProto& _internal_zone() const;
  public:
  const ::hadoop::hdfs::EncryptionZoneProto& zone() const;
  ::hadoop::hdfs::EncryptionZoneProto* release_zone();
  ::hadoop::hdfs::EncryptionZoneProto* mutable_zone();
  void set_allocated_zone(::hadoop::hdfs::EncryptionZoneProto* zone);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.GetEZForPathResponseProto)
 private:
  void set_has_zone();
  void clear_has_zone();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::EncryptionZoneProto* zone_;
  friend struct ::protobuf_encryption_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateEncryptionZoneRequestProto

// required string src = 1;
inline bool CreateEncryptionZoneRequestProto::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateEncryptionZoneRequestProto::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateEncryptionZoneRequestProto::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateEncryptionZoneRequestProto::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src();
}
inline const ::std::string& CreateEncryptionZoneRequestProto::src() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
  return src_.GetNoArena();
}
inline void CreateEncryptionZoneRequestProto::set_src(const ::std::string& value) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
}
#if LANG_CXX11
inline void CreateEncryptionZoneRequestProto::set_src(::std::string&& value) {
  set_has_src();
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
}
#endif
inline void CreateEncryptionZoneRequestProto::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
}
inline void CreateEncryptionZoneRequestProto::set_src(const char* value, size_t size) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
}
inline ::std::string* CreateEncryptionZoneRequestProto::mutable_src() {
  set_has_src();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateEncryptionZoneRequestProto::release_src() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
  if (!has_src()) {
    return NULL;
  }
  clear_has_src();
  return src_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateEncryptionZoneRequestProto::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    set_has_src();
  } else {
    clear_has_src();
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CreateEncryptionZoneRequestProto.src)
}

// optional string keyName = 2;
inline bool CreateEncryptionZoneRequestProto::has_keyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateEncryptionZoneRequestProto::set_has_keyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateEncryptionZoneRequestProto::clear_has_keyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateEncryptionZoneRequestProto::clear_keyname() {
  keyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyname();
}
inline const ::std::string& CreateEncryptionZoneRequestProto::keyname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
  return keyname_.GetNoArena();
}
inline void CreateEncryptionZoneRequestProto::set_keyname(const ::std::string& value) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
}
#if LANG_CXX11
inline void CreateEncryptionZoneRequestProto::set_keyname(::std::string&& value) {
  set_has_keyname();
  keyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
}
#endif
inline void CreateEncryptionZoneRequestProto::set_keyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
}
inline void CreateEncryptionZoneRequestProto::set_keyname(const char* value, size_t size) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
}
inline ::std::string* CreateEncryptionZoneRequestProto::mutable_keyname() {
  set_has_keyname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
  return keyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateEncryptionZoneRequestProto::release_keyname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
  if (!has_keyname()) {
    return NULL;
  }
  clear_has_keyname();
  return keyname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateEncryptionZoneRequestProto::set_allocated_keyname(::std::string* keyname) {
  if (keyname != NULL) {
    set_has_keyname();
  } else {
    clear_has_keyname();
  }
  keyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CreateEncryptionZoneRequestProto.keyName)
}

// -------------------------------------------------------------------

// CreateEncryptionZoneResponseProto

// -------------------------------------------------------------------

// ListEncryptionZonesRequestProto

// required int64 id = 1;
inline bool ListEncryptionZonesRequestProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListEncryptionZonesRequestProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListEncryptionZonesRequestProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListEncryptionZonesRequestProto::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ListEncryptionZonesRequestProto::id() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListEncryptionZonesRequestProto.id)
  return id_;
}
inline void ListEncryptionZonesRequestProto::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ListEncryptionZonesRequestProto.id)
}

// -------------------------------------------------------------------

// EncryptionZoneProto

// required int64 id = 1;
inline bool EncryptionZoneProto::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptionZoneProto::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptionZoneProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptionZoneProto::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 EncryptionZoneProto::id() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EncryptionZoneProto.id)
  return id_;
}
inline void EncryptionZoneProto::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EncryptionZoneProto.id)
}

// required string path = 2;
inline bool EncryptionZoneProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptionZoneProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptionZoneProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptionZoneProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& EncryptionZoneProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EncryptionZoneProto.path)
  return path_.GetNoArena();
}
inline void EncryptionZoneProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EncryptionZoneProto.path)
}
#if LANG_CXX11
inline void EncryptionZoneProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.EncryptionZoneProto.path)
}
#endif
inline void EncryptionZoneProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.EncryptionZoneProto.path)
}
inline void EncryptionZoneProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.EncryptionZoneProto.path)
}
inline ::std::string* EncryptionZoneProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.EncryptionZoneProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptionZoneProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.EncryptionZoneProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptionZoneProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.EncryptionZoneProto.path)
}

// required .hadoop.hdfs.CipherSuiteProto suite = 3;
inline bool EncryptionZoneProto::has_suite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EncryptionZoneProto::set_has_suite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EncryptionZoneProto::clear_has_suite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EncryptionZoneProto::clear_suite() {
  suite_ = 1;
  clear_has_suite();
}
inline ::hadoop::hdfs::CipherSuiteProto EncryptionZoneProto::suite() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EncryptionZoneProto.suite)
  return static_cast< ::hadoop::hdfs::CipherSuiteProto >(suite_);
}
inline void EncryptionZoneProto::set_suite(::hadoop::hdfs::CipherSuiteProto value) {
  assert(::hadoop::hdfs::CipherSuiteProto_IsValid(value));
  set_has_suite();
  suite_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EncryptionZoneProto.suite)
}

// required .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 4;
inline bool EncryptionZoneProto::has_cryptoprotocolversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EncryptionZoneProto::set_has_cryptoprotocolversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EncryptionZoneProto::clear_has_cryptoprotocolversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EncryptionZoneProto::clear_cryptoprotocolversion() {
  cryptoprotocolversion_ = 1;
  clear_has_cryptoprotocolversion();
}
inline ::hadoop::hdfs::CryptoProtocolVersionProto EncryptionZoneProto::cryptoprotocolversion() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EncryptionZoneProto.cryptoProtocolVersion)
  return static_cast< ::hadoop::hdfs::CryptoProtocolVersionProto >(cryptoprotocolversion_);
}
inline void EncryptionZoneProto::set_cryptoprotocolversion(::hadoop::hdfs::CryptoProtocolVersionProto value) {
  assert(::hadoop::hdfs::CryptoProtocolVersionProto_IsValid(value));
  set_has_cryptoprotocolversion();
  cryptoprotocolversion_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EncryptionZoneProto.cryptoProtocolVersion)
}

// required string keyName = 5;
inline bool EncryptionZoneProto::has_keyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptionZoneProto::set_has_keyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptionZoneProto::clear_has_keyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptionZoneProto::clear_keyname() {
  keyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyname();
}
inline const ::std::string& EncryptionZoneProto::keyname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EncryptionZoneProto.keyName)
  return keyname_.GetNoArena();
}
inline void EncryptionZoneProto::set_keyname(const ::std::string& value) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EncryptionZoneProto.keyName)
}
#if LANG_CXX11
inline void EncryptionZoneProto::set_keyname(::std::string&& value) {
  set_has_keyname();
  keyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.EncryptionZoneProto.keyName)
}
#endif
inline void EncryptionZoneProto::set_keyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.EncryptionZoneProto.keyName)
}
inline void EncryptionZoneProto::set_keyname(const char* value, size_t size) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.EncryptionZoneProto.keyName)
}
inline ::std::string* EncryptionZoneProto::mutable_keyname() {
  set_has_keyname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.EncryptionZoneProto.keyName)
  return keyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptionZoneProto::release_keyname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.EncryptionZoneProto.keyName)
  if (!has_keyname()) {
    return NULL;
  }
  clear_has_keyname();
  return keyname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptionZoneProto::set_allocated_keyname(::std::string* keyname) {
  if (keyname != NULL) {
    set_has_keyname();
  } else {
    clear_has_keyname();
  }
  keyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.EncryptionZoneProto.keyName)
}

// -------------------------------------------------------------------

// ListEncryptionZonesResponseProto

// repeated .hadoop.hdfs.EncryptionZoneProto zones = 1;
inline int ListEncryptionZonesResponseProto::zones_size() const {
  return zones_.size();
}
inline void ListEncryptionZonesResponseProto::clear_zones() {
  zones_.Clear();
}
inline ::hadoop::hdfs::EncryptionZoneProto* ListEncryptionZonesResponseProto::mutable_zones(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ListEncryptionZonesResponseProto.zones)
  return zones_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EncryptionZoneProto >*
ListEncryptionZonesResponseProto::mutable_zones() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.ListEncryptionZonesResponseProto.zones)
  return &zones_;
}
inline const ::hadoop::hdfs::EncryptionZoneProto& ListEncryptionZonesResponseProto::zones(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListEncryptionZonesResponseProto.zones)
  return zones_.Get(index);
}
inline ::hadoop::hdfs::EncryptionZoneProto* ListEncryptionZonesResponseProto::add_zones() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.ListEncryptionZonesResponseProto.zones)
  return zones_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EncryptionZoneProto >&
ListEncryptionZonesResponseProto::zones() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.ListEncryptionZonesResponseProto.zones)
  return zones_;
}

// required bool hasMore = 2;
inline bool ListEncryptionZonesResponseProto::has_hasmore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListEncryptionZonesResponseProto::set_has_hasmore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListEncryptionZonesResponseProto::clear_has_hasmore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListEncryptionZonesResponseProto::clear_hasmore() {
  hasmore_ = false;
  clear_has_hasmore();
}
inline bool ListEncryptionZonesResponseProto::hasmore() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListEncryptionZonesResponseProto.hasMore)
  return hasmore_;
}
inline void ListEncryptionZonesResponseProto::set_hasmore(bool value) {
  set_has_hasmore();
  hasmore_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ListEncryptionZonesResponseProto.hasMore)
}

// -------------------------------------------------------------------

// ReencryptEncryptionZoneRequestProto

// required .hadoop.hdfs.ReencryptActionProto action = 1;
inline bool ReencryptEncryptionZoneRequestProto::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReencryptEncryptionZoneRequestProto::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReencryptEncryptionZoneRequestProto::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReencryptEncryptionZoneRequestProto::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::hadoop::hdfs::ReencryptActionProto ReencryptEncryptionZoneRequestProto::action() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.action)
  return static_cast< ::hadoop::hdfs::ReencryptActionProto >(action_);
}
inline void ReencryptEncryptionZoneRequestProto::set_action(::hadoop::hdfs::ReencryptActionProto value) {
  assert(::hadoop::hdfs::ReencryptActionProto_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.action)
}

// required string zone = 2;
inline bool ReencryptEncryptionZoneRequestProto::has_zone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReencryptEncryptionZoneRequestProto::set_has_zone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReencryptEncryptionZoneRequestProto::clear_has_zone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReencryptEncryptionZoneRequestProto::clear_zone() {
  zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_zone();
}
inline const ::std::string& ReencryptEncryptionZoneRequestProto::zone() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
  return zone_.GetNoArena();
}
inline void ReencryptEncryptionZoneRequestProto::set_zone(const ::std::string& value) {
  set_has_zone();
  zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
}
#if LANG_CXX11
inline void ReencryptEncryptionZoneRequestProto::set_zone(::std::string&& value) {
  set_has_zone();
  zone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
}
#endif
inline void ReencryptEncryptionZoneRequestProto::set_zone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_zone();
  zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
}
inline void ReencryptEncryptionZoneRequestProto::set_zone(const char* value, size_t size) {
  set_has_zone();
  zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
}
inline ::std::string* ReencryptEncryptionZoneRequestProto::mutable_zone() {
  set_has_zone();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
  return zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReencryptEncryptionZoneRequestProto::release_zone() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
  if (!has_zone()) {
    return NULL;
  }
  clear_has_zone();
  return zone_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReencryptEncryptionZoneRequestProto::set_allocated_zone(::std::string* zone) {
  if (zone != NULL) {
    set_has_zone();
  } else {
    clear_has_zone();
  }
  zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), zone);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ReencryptEncryptionZoneRequestProto.zone)
}

// -------------------------------------------------------------------

// ReencryptEncryptionZoneResponseProto

// -------------------------------------------------------------------

// ListReencryptionStatusRequestProto

// required int64 id = 1;
inline bool ListReencryptionStatusRequestProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListReencryptionStatusRequestProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListReencryptionStatusRequestProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListReencryptionStatusRequestProto::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ListReencryptionStatusRequestProto::id() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListReencryptionStatusRequestProto.id)
  return id_;
}
inline void ListReencryptionStatusRequestProto::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ListReencryptionStatusRequestProto.id)
}

// -------------------------------------------------------------------

// ZoneReencryptionStatusProto

// required int64 id = 1;
inline bool ZoneReencryptionStatusProto::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZoneReencryptionStatusProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZoneReencryptionStatusProto::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ZoneReencryptionStatusProto::id() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.id)
  return id_;
}
inline void ZoneReencryptionStatusProto::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.id)
}

// required string path = 2;
inline bool ZoneReencryptionStatusProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZoneReencryptionStatusProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZoneReencryptionStatusProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& ZoneReencryptionStatusProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.path)
  return path_.GetNoArena();
}
inline void ZoneReencryptionStatusProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.path)
}
#if LANG_CXX11
inline void ZoneReencryptionStatusProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.ZoneReencryptionStatusProto.path)
}
#endif
inline void ZoneReencryptionStatusProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.ZoneReencryptionStatusProto.path)
}
inline void ZoneReencryptionStatusProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.ZoneReencryptionStatusProto.path)
}
inline ::std::string* ZoneReencryptionStatusProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ZoneReencryptionStatusProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ZoneReencryptionStatusProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ZoneReencryptionStatusProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ZoneReencryptionStatusProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ZoneReencryptionStatusProto.path)
}

// required .hadoop.hdfs.ReencryptionStateProto state = 3;
inline bool ZoneReencryptionStatusProto::has_state() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_state() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ZoneReencryptionStatusProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ZoneReencryptionStatusProto::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::hadoop::hdfs::ReencryptionStateProto ZoneReencryptionStatusProto::state() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.state)
  return static_cast< ::hadoop::hdfs::ReencryptionStateProto >(state_);
}
inline void ZoneReencryptionStatusProto::set_state(::hadoop::hdfs::ReencryptionStateProto value) {
  assert(::hadoop::hdfs::ReencryptionStateProto_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.state)
}

// required string ezKeyVersionName = 4;
inline bool ZoneReencryptionStatusProto::has_ezkeyversionname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_ezkeyversionname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZoneReencryptionStatusProto::clear_has_ezkeyversionname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZoneReencryptionStatusProto::clear_ezkeyversionname() {
  ezkeyversionname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ezkeyversionname();
}
inline const ::std::string& ZoneReencryptionStatusProto::ezkeyversionname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
  return ezkeyversionname_.GetNoArena();
}
inline void ZoneReencryptionStatusProto::set_ezkeyversionname(const ::std::string& value) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
}
#if LANG_CXX11
inline void ZoneReencryptionStatusProto::set_ezkeyversionname(::std::string&& value) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
}
#endif
inline void ZoneReencryptionStatusProto::set_ezkeyversionname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
}
inline void ZoneReencryptionStatusProto::set_ezkeyversionname(const char* value, size_t size) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
}
inline ::std::string* ZoneReencryptionStatusProto::mutable_ezkeyversionname() {
  set_has_ezkeyversionname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
  return ezkeyversionname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ZoneReencryptionStatusProto::release_ezkeyversionname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
  if (!has_ezkeyversionname()) {
    return NULL;
  }
  clear_has_ezkeyversionname();
  return ezkeyversionname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ZoneReencryptionStatusProto::set_allocated_ezkeyversionname(::std::string* ezkeyversionname) {
  if (ezkeyversionname != NULL) {
    set_has_ezkeyversionname();
  } else {
    clear_has_ezkeyversionname();
  }
  ezkeyversionname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ezkeyversionname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ZoneReencryptionStatusProto.ezKeyVersionName)
}

// required int64 submissionTime = 5;
inline bool ZoneReencryptionStatusProto::has_submissiontime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_submissiontime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ZoneReencryptionStatusProto::clear_has_submissiontime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ZoneReencryptionStatusProto::clear_submissiontime() {
  submissiontime_ = GOOGLE_LONGLONG(0);
  clear_has_submissiontime();
}
inline ::google::protobuf::int64 ZoneReencryptionStatusProto::submissiontime() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.submissionTime)
  return submissiontime_;
}
inline void ZoneReencryptionStatusProto::set_submissiontime(::google::protobuf::int64 value) {
  set_has_submissiontime();
  submissiontime_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.submissionTime)
}

// required bool canceled = 6;
inline bool ZoneReencryptionStatusProto::has_canceled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_canceled() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ZoneReencryptionStatusProto::clear_has_canceled() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ZoneReencryptionStatusProto::clear_canceled() {
  canceled_ = false;
  clear_has_canceled();
}
inline bool ZoneReencryptionStatusProto::canceled() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.canceled)
  return canceled_;
}
inline void ZoneReencryptionStatusProto::set_canceled(bool value) {
  set_has_canceled();
  canceled_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.canceled)
}

// required int64 numReencrypted = 7;
inline bool ZoneReencryptionStatusProto::has_numreencrypted() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_numreencrypted() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ZoneReencryptionStatusProto::clear_has_numreencrypted() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ZoneReencryptionStatusProto::clear_numreencrypted() {
  numreencrypted_ = GOOGLE_LONGLONG(0);
  clear_has_numreencrypted();
}
inline ::google::protobuf::int64 ZoneReencryptionStatusProto::numreencrypted() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.numReencrypted)
  return numreencrypted_;
}
inline void ZoneReencryptionStatusProto::set_numreencrypted(::google::protobuf::int64 value) {
  set_has_numreencrypted();
  numreencrypted_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.numReencrypted)
}

// required int64 numFailures = 8;
inline bool ZoneReencryptionStatusProto::has_numfailures() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_numfailures() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ZoneReencryptionStatusProto::clear_has_numfailures() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ZoneReencryptionStatusProto::clear_numfailures() {
  numfailures_ = GOOGLE_LONGLONG(0);
  clear_has_numfailures();
}
inline ::google::protobuf::int64 ZoneReencryptionStatusProto::numfailures() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.numFailures)
  return numfailures_;
}
inline void ZoneReencryptionStatusProto::set_numfailures(::google::protobuf::int64 value) {
  set_has_numfailures();
  numfailures_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.numFailures)
}

// optional int64 completionTime = 9;
inline bool ZoneReencryptionStatusProto::has_completiontime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_completiontime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ZoneReencryptionStatusProto::clear_has_completiontime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ZoneReencryptionStatusProto::clear_completiontime() {
  completiontime_ = GOOGLE_LONGLONG(0);
  clear_has_completiontime();
}
inline ::google::protobuf::int64 ZoneReencryptionStatusProto::completiontime() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.completionTime)
  return completiontime_;
}
inline void ZoneReencryptionStatusProto::set_completiontime(::google::protobuf::int64 value) {
  set_has_completiontime();
  completiontime_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.completionTime)
}

// optional string lastFile = 10;
inline bool ZoneReencryptionStatusProto::has_lastfile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZoneReencryptionStatusProto::set_has_lastfile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZoneReencryptionStatusProto::clear_has_lastfile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZoneReencryptionStatusProto::clear_lastfile() {
  lastfile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lastfile();
}
inline const ::std::string& ZoneReencryptionStatusProto::lastfile() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
  return lastfile_.GetNoArena();
}
inline void ZoneReencryptionStatusProto::set_lastfile(const ::std::string& value) {
  set_has_lastfile();
  lastfile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
}
#if LANG_CXX11
inline void ZoneReencryptionStatusProto::set_lastfile(::std::string&& value) {
  set_has_lastfile();
  lastfile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
}
#endif
inline void ZoneReencryptionStatusProto::set_lastfile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lastfile();
  lastfile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
}
inline void ZoneReencryptionStatusProto::set_lastfile(const char* value, size_t size) {
  set_has_lastfile();
  lastfile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
}
inline ::std::string* ZoneReencryptionStatusProto::mutable_lastfile() {
  set_has_lastfile();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
  return lastfile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ZoneReencryptionStatusProto::release_lastfile() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
  if (!has_lastfile()) {
    return NULL;
  }
  clear_has_lastfile();
  return lastfile_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ZoneReencryptionStatusProto::set_allocated_lastfile(::std::string* lastfile) {
  if (lastfile != NULL) {
    set_has_lastfile();
  } else {
    clear_has_lastfile();
  }
  lastfile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lastfile);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.ZoneReencryptionStatusProto.lastFile)
}

// -------------------------------------------------------------------

// ListReencryptionStatusResponseProto

// repeated .hadoop.hdfs.ZoneReencryptionStatusProto statuses = 1;
inline int ListReencryptionStatusResponseProto::statuses_size() const {
  return statuses_.size();
}
inline void ListReencryptionStatusResponseProto::clear_statuses() {
  statuses_.Clear();
}
inline ::hadoop::hdfs::ZoneReencryptionStatusProto* ListReencryptionStatusResponseProto::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.ListReencryptionStatusResponseProto.statuses)
  return statuses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ZoneReencryptionStatusProto >*
ListReencryptionStatusResponseProto::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.ListReencryptionStatusResponseProto.statuses)
  return &statuses_;
}
inline const ::hadoop::hdfs::ZoneReencryptionStatusProto& ListReencryptionStatusResponseProto::statuses(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListReencryptionStatusResponseProto.statuses)
  return statuses_.Get(index);
}
inline ::hadoop::hdfs::ZoneReencryptionStatusProto* ListReencryptionStatusResponseProto::add_statuses() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.ListReencryptionStatusResponseProto.statuses)
  return statuses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::ZoneReencryptionStatusProto >&
ListReencryptionStatusResponseProto::statuses() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.ListReencryptionStatusResponseProto.statuses)
  return statuses_;
}

// required bool hasMore = 2;
inline bool ListReencryptionStatusResponseProto::has_hasmore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListReencryptionStatusResponseProto::set_has_hasmore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListReencryptionStatusResponseProto::clear_has_hasmore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListReencryptionStatusResponseProto::clear_hasmore() {
  hasmore_ = false;
  clear_has_hasmore();
}
inline bool ListReencryptionStatusResponseProto::hasmore() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.ListReencryptionStatusResponseProto.hasMore)
  return hasmore_;
}
inline void ListReencryptionStatusResponseProto::set_hasmore(bool value) {
  set_has_hasmore();
  hasmore_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.ListReencryptionStatusResponseProto.hasMore)
}

// -------------------------------------------------------------------

// GetEZForPathRequestProto

// required string src = 1;
inline bool GetEZForPathRequestProto::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEZForPathRequestProto::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEZForPathRequestProto::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEZForPathRequestProto::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src();
}
inline const ::std::string& GetEZForPathRequestProto::src() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetEZForPathRequestProto.src)
  return src_.GetNoArena();
}
inline void GetEZForPathRequestProto::set_src(const ::std::string& value) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.GetEZForPathRequestProto.src)
}
#if LANG_CXX11
inline void GetEZForPathRequestProto::set_src(::std::string&& value) {
  set_has_src();
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.GetEZForPathRequestProto.src)
}
#endif
inline void GetEZForPathRequestProto::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.GetEZForPathRequestProto.src)
}
inline void GetEZForPathRequestProto::set_src(const char* value, size_t size) {
  set_has_src();
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.GetEZForPathRequestProto.src)
}
inline ::std::string* GetEZForPathRequestProto::mutable_src() {
  set_has_src();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetEZForPathRequestProto.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEZForPathRequestProto::release_src() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.GetEZForPathRequestProto.src)
  if (!has_src()) {
    return NULL;
  }
  clear_has_src();
  return src_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEZForPathRequestProto::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    set_has_src();
  } else {
    clear_has_src();
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.GetEZForPathRequestProto.src)
}

// -------------------------------------------------------------------

// GetEZForPathResponseProto

// optional .hadoop.hdfs.EncryptionZoneProto zone = 1;
inline bool GetEZForPathResponseProto::has_zone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEZForPathResponseProto::set_has_zone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEZForPathResponseProto::clear_has_zone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEZForPathResponseProto::clear_zone() {
  if (zone_ != NULL) zone_->Clear();
  clear_has_zone();
}
inline const ::hadoop::hdfs::EncryptionZoneProto& GetEZForPathResponseProto::_internal_zone() const {
  return *zone_;
}
inline const ::hadoop::hdfs::EncryptionZoneProto& GetEZForPathResponseProto::zone() const {
  const ::hadoop::hdfs::EncryptionZoneProto* p = zone_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.GetEZForPathResponseProto.zone)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::EncryptionZoneProto*>(
      &::hadoop::hdfs::_EncryptionZoneProto_default_instance_);
}
inline ::hadoop::hdfs::EncryptionZoneProto* GetEZForPathResponseProto::release_zone() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.GetEZForPathResponseProto.zone)
  clear_has_zone();
  ::hadoop::hdfs::EncryptionZoneProto* temp = zone_;
  zone_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::EncryptionZoneProto* GetEZForPathResponseProto::mutable_zone() {
  set_has_zone();
  if (zone_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::EncryptionZoneProto>(GetArenaNoVirtual());
    zone_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.GetEZForPathResponseProto.zone)
  return zone_;
}
inline void GetEZForPathResponseProto::set_allocated_zone(::hadoop::hdfs::EncryptionZoneProto* zone) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zone_;
  }
  if (zone) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zone = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zone, submessage_arena);
    }
    set_has_zone();
  } else {
    clear_has_zone();
  }
  zone_ = zone;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.GetEZForPathResponseProto.zone)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdfs
}  // namespace hadoop

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hadoop::hdfs::ReencryptActionProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::hdfs::ReencryptActionProto>() {
  return ::hadoop::hdfs::ReencryptActionProto_descriptor();
}
template <> struct is_proto_enum< ::hadoop::hdfs::ReencryptionStateProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::hdfs::ReencryptionStateProto>() {
  return ::hadoop::hdfs::ReencryptionStateProto_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_encryption_2eproto
