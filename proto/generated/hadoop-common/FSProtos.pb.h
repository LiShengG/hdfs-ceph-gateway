// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hadoop-common/FSProtos.proto

#ifndef PROTOBUF_INCLUDED_hadoop_2dcommon_2fFSProtos_2eproto
#define PROTOBUF_INCLUDED_hadoop_2dcommon_2fFSProtos_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_hadoop_2dcommon_2fFSProtos_2eproto 

namespace protobuf_hadoop_2dcommon_2fFSProtos_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_hadoop_2dcommon_2fFSProtos_2eproto
namespace hadoop {
namespace fs {
class FileStatusProto;
class FileStatusProtoDefaultTypeInternal;
extern FileStatusProtoDefaultTypeInternal _FileStatusProto_default_instance_;
class FsPermissionProto;
class FsPermissionProtoDefaultTypeInternal;
extern FsPermissionProtoDefaultTypeInternal _FsPermissionProto_default_instance_;
class LocalFileSystemPathHandleProto;
class LocalFileSystemPathHandleProtoDefaultTypeInternal;
extern LocalFileSystemPathHandleProtoDefaultTypeInternal _LocalFileSystemPathHandleProto_default_instance_;
}  // namespace fs
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::fs::FileStatusProto* Arena::CreateMaybeMessage<::hadoop::fs::FileStatusProto>(Arena*);
template<> ::hadoop::fs::FsPermissionProto* Arena::CreateMaybeMessage<::hadoop::fs::FsPermissionProto>(Arena*);
template<> ::hadoop::fs::LocalFileSystemPathHandleProto* Arena::CreateMaybeMessage<::hadoop::fs::LocalFileSystemPathHandleProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace fs {

enum FileStatusProto_FileType {
  FileStatusProto_FileType_FT_DIR = 1,
  FileStatusProto_FileType_FT_FILE = 2,
  FileStatusProto_FileType_FT_SYMLINK = 3
};
bool FileStatusProto_FileType_IsValid(int value);
const FileStatusProto_FileType FileStatusProto_FileType_FileType_MIN = FileStatusProto_FileType_FT_DIR;
const FileStatusProto_FileType FileStatusProto_FileType_FileType_MAX = FileStatusProto_FileType_FT_SYMLINK;
const int FileStatusProto_FileType_FileType_ARRAYSIZE = FileStatusProto_FileType_FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileStatusProto_FileType_descriptor();
inline const ::std::string& FileStatusProto_FileType_Name(FileStatusProto_FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileStatusProto_FileType_descriptor(), value);
}
inline bool FileStatusProto_FileType_Parse(
    const ::std::string& name, FileStatusProto_FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileStatusProto_FileType>(
    FileStatusProto_FileType_descriptor(), name, value);
}
enum FileStatusProto_Flags {
  FileStatusProto_Flags_HAS_ACL = 1,
  FileStatusProto_Flags_HAS_CRYPT = 2,
  FileStatusProto_Flags_HAS_EC = 4,
  FileStatusProto_Flags_SNAPSHOT_ENABLED = 8
};
bool FileStatusProto_Flags_IsValid(int value);
const FileStatusProto_Flags FileStatusProto_Flags_Flags_MIN = FileStatusProto_Flags_HAS_ACL;
const FileStatusProto_Flags FileStatusProto_Flags_Flags_MAX = FileStatusProto_Flags_SNAPSHOT_ENABLED;
const int FileStatusProto_Flags_Flags_ARRAYSIZE = FileStatusProto_Flags_Flags_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileStatusProto_Flags_descriptor();
inline const ::std::string& FileStatusProto_Flags_Name(FileStatusProto_Flags value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileStatusProto_Flags_descriptor(), value);
}
inline bool FileStatusProto_Flags_Parse(
    const ::std::string& name, FileStatusProto_Flags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileStatusProto_Flags>(
    FileStatusProto_Flags_descriptor(), name, value);
}
// ===================================================================

class FsPermissionProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.fs.FsPermissionProto) */ {
 public:
  FsPermissionProto();
  virtual ~FsPermissionProto();

  FsPermissionProto(const FsPermissionProto& from);

  inline FsPermissionProto& operator=(const FsPermissionProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FsPermissionProto(FsPermissionProto&& from) noexcept
    : FsPermissionProto() {
    *this = ::std::move(from);
  }

  inline FsPermissionProto& operator=(FsPermissionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FsPermissionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FsPermissionProto* internal_default_instance() {
    return reinterpret_cast<const FsPermissionProto*>(
               &_FsPermissionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FsPermissionProto* other);
  friend void swap(FsPermissionProto& a, FsPermissionProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FsPermissionProto* New() const final {
    return CreateMaybeMessage<FsPermissionProto>(NULL);
  }

  FsPermissionProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FsPermissionProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FsPermissionProto& from);
  void MergeFrom(const FsPermissionProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsPermissionProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 perm = 1;
  bool has_perm() const;
  void clear_perm();
  static const int kPermFieldNumber = 1;
  ::google::protobuf::uint32 perm() const;
  void set_perm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hadoop.fs.FsPermissionProto)
 private:
  void set_has_perm();
  void clear_has_perm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 perm_;
  friend struct ::protobuf_hadoop_2dcommon_2fFSProtos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileStatusProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.fs.FileStatusProto) */ {
 public:
  FileStatusProto();
  virtual ~FileStatusProto();

  FileStatusProto(const FileStatusProto& from);

  inline FileStatusProto& operator=(const FileStatusProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileStatusProto(FileStatusProto&& from) noexcept
    : FileStatusProto() {
    *this = ::std::move(from);
  }

  inline FileStatusProto& operator=(FileStatusProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileStatusProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileStatusProto* internal_default_instance() {
    return reinterpret_cast<const FileStatusProto*>(
               &_FileStatusProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FileStatusProto* other);
  friend void swap(FileStatusProto& a, FileStatusProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileStatusProto* New() const final {
    return CreateMaybeMessage<FileStatusProto>(NULL);
  }

  FileStatusProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileStatusProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileStatusProto& from);
  void MergeFrom(const FileStatusProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileStatusProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FileStatusProto_FileType FileType;
  static const FileType FT_DIR =
    FileStatusProto_FileType_FT_DIR;
  static const FileType FT_FILE =
    FileStatusProto_FileType_FT_FILE;
  static const FileType FT_SYMLINK =
    FileStatusProto_FileType_FT_SYMLINK;
  static inline bool FileType_IsValid(int value) {
    return FileStatusProto_FileType_IsValid(value);
  }
  static const FileType FileType_MIN =
    FileStatusProto_FileType_FileType_MIN;
  static const FileType FileType_MAX =
    FileStatusProto_FileType_FileType_MAX;
  static const int FileType_ARRAYSIZE =
    FileStatusProto_FileType_FileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FileType_descriptor() {
    return FileStatusProto_FileType_descriptor();
  }
  static inline const ::std::string& FileType_Name(FileType value) {
    return FileStatusProto_FileType_Name(value);
  }
  static inline bool FileType_Parse(const ::std::string& name,
      FileType* value) {
    return FileStatusProto_FileType_Parse(name, value);
  }

  typedef FileStatusProto_Flags Flags;
  static const Flags HAS_ACL =
    FileStatusProto_Flags_HAS_ACL;
  static const Flags HAS_CRYPT =
    FileStatusProto_Flags_HAS_CRYPT;
  static const Flags HAS_EC =
    FileStatusProto_Flags_HAS_EC;
  static const Flags SNAPSHOT_ENABLED =
    FileStatusProto_Flags_SNAPSHOT_ENABLED;
  static inline bool Flags_IsValid(int value) {
    return FileStatusProto_Flags_IsValid(value);
  }
  static const Flags Flags_MIN =
    FileStatusProto_Flags_Flags_MIN;
  static const Flags Flags_MAX =
    FileStatusProto_Flags_Flags_MAX;
  static const int Flags_ARRAYSIZE =
    FileStatusProto_Flags_Flags_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Flags_descriptor() {
    return FileStatusProto_Flags_descriptor();
  }
  static inline const ::std::string& Flags_Name(Flags value) {
    return FileStatusProto_Flags_Name(value);
  }
  static inline bool Flags_Parse(const ::std::string& name,
      Flags* value) {
    return FileStatusProto_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional string owner = 5;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 5;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // optional string group = 6;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 6;
  const ::std::string& group() const;
  void set_group(const ::std::string& value);
  #if LANG_CXX11
  void set_group(::std::string&& value);
  #endif
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  ::std::string* mutable_group();
  ::std::string* release_group();
  void set_allocated_group(::std::string* group);

  // optional string symlink = 9;
  bool has_symlink() const;
  void clear_symlink();
  static const int kSymlinkFieldNumber = 9;
  const ::std::string& symlink() const;
  void set_symlink(const ::std::string& value);
  #if LANG_CXX11
  void set_symlink(::std::string&& value);
  #endif
  void set_symlink(const char* value);
  void set_symlink(const char* value, size_t size);
  ::std::string* mutable_symlink();
  ::std::string* release_symlink();
  void set_allocated_symlink(::std::string* symlink);

  // optional bytes encryption_data = 15;
  bool has_encryption_data() const;
  void clear_encryption_data();
  static const int kEncryptionDataFieldNumber = 15;
  const ::std::string& encryption_data() const;
  void set_encryption_data(const ::std::string& value);
  #if LANG_CXX11
  void set_encryption_data(::std::string&& value);
  #endif
  void set_encryption_data(const char* value);
  void set_encryption_data(const void* value, size_t size);
  ::std::string* mutable_encryption_data();
  ::std::string* release_encryption_data();
  void set_allocated_encryption_data(::std::string* encryption_data);

  // optional bytes ec_data = 17;
  bool has_ec_data() const;
  void clear_ec_data();
  static const int kEcDataFieldNumber = 17;
  const ::std::string& ec_data() const;
  void set_ec_data(const ::std::string& value);
  #if LANG_CXX11
  void set_ec_data(::std::string&& value);
  #endif
  void set_ec_data(const char* value);
  void set_ec_data(const void* value, size_t size);
  ::std::string* mutable_ec_data();
  ::std::string* release_ec_data();
  void set_allocated_ec_data(::std::string* ec_data);

  // optional .hadoop.fs.FsPermissionProto permission = 4;
  bool has_permission() const;
  void clear_permission();
  static const int kPermissionFieldNumber = 4;
  private:
  const ::hadoop::fs::FsPermissionProto& _internal_permission() const;
  public:
  const ::hadoop::fs::FsPermissionProto& permission() const;
  ::hadoop::fs::FsPermissionProto* release_permission();
  ::hadoop::fs::FsPermissionProto* mutable_permission();
  void set_allocated_permission(::hadoop::fs::FsPermissionProto* permission);

  // optional uint64 length = 3;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::uint64 length() const;
  void set_length(::google::protobuf::uint64 value);

  // optional uint64 modification_time = 7;
  bool has_modification_time() const;
  void clear_modification_time();
  static const int kModificationTimeFieldNumber = 7;
  ::google::protobuf::uint64 modification_time() const;
  void set_modification_time(::google::protobuf::uint64 value);

  // optional uint64 access_time = 8;
  bool has_access_time() const;
  void clear_access_time();
  static const int kAccessTimeFieldNumber = 8;
  ::google::protobuf::uint64 access_time() const;
  void set_access_time(::google::protobuf::uint64 value);

  // optional uint64 block_size = 11;
  bool has_block_size() const;
  void clear_block_size();
  static const int kBlockSizeFieldNumber = 11;
  ::google::protobuf::uint64 block_size() const;
  void set_block_size(::google::protobuf::uint64 value);

  // optional uint32 block_replication = 10;
  bool has_block_replication() const;
  void clear_block_replication();
  static const int kBlockReplicationFieldNumber = 10;
  ::google::protobuf::uint32 block_replication() const;
  void set_block_replication(::google::protobuf::uint32 value);

  // optional uint32 flags = 18 [default = 0];
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 18;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // required .hadoop.fs.FileStatusProto.FileType fileType = 1;
  bool has_filetype() const;
  void clear_filetype();
  static const int kFileTypeFieldNumber = 1;
  ::hadoop::fs::FileStatusProto_FileType filetype() const;
  void set_filetype(::hadoop::fs::FileStatusProto_FileType value);

  // @@protoc_insertion_point(class_scope:hadoop.fs.FileStatusProto)
 private:
  void set_has_filetype();
  void clear_has_filetype();
  void set_has_path();
  void clear_has_path();
  void set_has_length();
  void clear_has_length();
  void set_has_permission();
  void clear_has_permission();
  void set_has_owner();
  void clear_has_owner();
  void set_has_group();
  void clear_has_group();
  void set_has_modification_time();
  void clear_has_modification_time();
  void set_has_access_time();
  void clear_has_access_time();
  void set_has_symlink();
  void clear_has_symlink();
  void set_has_block_replication();
  void clear_has_block_replication();
  void set_has_block_size();
  void clear_has_block_size();
  void set_has_encryption_data();
  void clear_has_encryption_data();
  void set_has_ec_data();
  void clear_has_ec_data();
  void set_has_flags();
  void clear_has_flags();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  ::google::protobuf::internal::ArenaStringPtr symlink_;
  ::google::protobuf::internal::ArenaStringPtr encryption_data_;
  ::google::protobuf::internal::ArenaStringPtr ec_data_;
  ::hadoop::fs::FsPermissionProto* permission_;
  ::google::protobuf::uint64 length_;
  ::google::protobuf::uint64 modification_time_;
  ::google::protobuf::uint64 access_time_;
  ::google::protobuf::uint64 block_size_;
  ::google::protobuf::uint32 block_replication_;
  ::google::protobuf::uint32 flags_;
  int filetype_;
  friend struct ::protobuf_hadoop_2dcommon_2fFSProtos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalFileSystemPathHandleProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.fs.LocalFileSystemPathHandleProto) */ {
 public:
  LocalFileSystemPathHandleProto();
  virtual ~LocalFileSystemPathHandleProto();

  LocalFileSystemPathHandleProto(const LocalFileSystemPathHandleProto& from);

  inline LocalFileSystemPathHandleProto& operator=(const LocalFileSystemPathHandleProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalFileSystemPathHandleProto(LocalFileSystemPathHandleProto&& from) noexcept
    : LocalFileSystemPathHandleProto() {
    *this = ::std::move(from);
  }

  inline LocalFileSystemPathHandleProto& operator=(LocalFileSystemPathHandleProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalFileSystemPathHandleProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalFileSystemPathHandleProto* internal_default_instance() {
    return reinterpret_cast<const LocalFileSystemPathHandleProto*>(
               &_LocalFileSystemPathHandleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LocalFileSystemPathHandleProto* other);
  friend void swap(LocalFileSystemPathHandleProto& a, LocalFileSystemPathHandleProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalFileSystemPathHandleProto* New() const final {
    return CreateMaybeMessage<LocalFileSystemPathHandleProto>(NULL);
  }

  LocalFileSystemPathHandleProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocalFileSystemPathHandleProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocalFileSystemPathHandleProto& from);
  void MergeFrom(const LocalFileSystemPathHandleProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalFileSystemPathHandleProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional uint64 mtime = 1;
  bool has_mtime() const;
  void clear_mtime();
  static const int kMtimeFieldNumber = 1;
  ::google::protobuf::uint64 mtime() const;
  void set_mtime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.fs.LocalFileSystemPathHandleProto)
 private:
  void set_has_mtime();
  void clear_has_mtime();
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint64 mtime_;
  friend struct ::protobuf_hadoop_2dcommon_2fFSProtos_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FsPermissionProto

// required uint32 perm = 1;
inline bool FsPermissionProto::has_perm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FsPermissionProto::set_has_perm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FsPermissionProto::clear_has_perm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FsPermissionProto::clear_perm() {
  perm_ = 0u;
  clear_has_perm();
}
inline ::google::protobuf::uint32 FsPermissionProto::perm() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FsPermissionProto.perm)
  return perm_;
}
inline void FsPermissionProto::set_perm(::google::protobuf::uint32 value) {
  set_has_perm();
  perm_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FsPermissionProto.perm)
}

// -------------------------------------------------------------------

// FileStatusProto

// required .hadoop.fs.FileStatusProto.FileType fileType = 1;
inline bool FileStatusProto::has_filetype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FileStatusProto::set_has_filetype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FileStatusProto::clear_has_filetype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FileStatusProto::clear_filetype() {
  filetype_ = 1;
  clear_has_filetype();
}
inline ::hadoop::fs::FileStatusProto_FileType FileStatusProto::filetype() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.fileType)
  return static_cast< ::hadoop::fs::FileStatusProto_FileType >(filetype_);
}
inline void FileStatusProto::set_filetype(::hadoop::fs::FileStatusProto_FileType value) {
  assert(::hadoop::fs::FileStatusProto_FileType_IsValid(value));
  set_has_filetype();
  filetype_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.fileType)
}

// required string path = 2;
inline bool FileStatusProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileStatusProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileStatusProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileStatusProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& FileStatusProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.path)
  return path_.GetNoArena();
}
inline void FileStatusProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.path)
}
#if LANG_CXX11
inline void FileStatusProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.fs.FileStatusProto.path)
}
#endif
inline void FileStatusProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.fs.FileStatusProto.path)
}
inline void FileStatusProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.fs.FileStatusProto.path)
}
inline ::std::string* FileStatusProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.fs.FileStatusProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileStatusProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.fs.FileStatusProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileStatusProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.FileStatusProto.path)
}

// optional uint64 length = 3;
inline bool FileStatusProto::has_length() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FileStatusProto::set_has_length() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FileStatusProto::clear_has_length() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FileStatusProto::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 FileStatusProto::length() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.length)
  return length_;
}
inline void FileStatusProto::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.length)
}

// optional .hadoop.fs.FsPermissionProto permission = 4;
inline bool FileStatusProto::has_permission() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FileStatusProto::set_has_permission() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FileStatusProto::clear_has_permission() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FileStatusProto::clear_permission() {
  if (permission_ != NULL) permission_->Clear();
  clear_has_permission();
}
inline const ::hadoop::fs::FsPermissionProto& FileStatusProto::_internal_permission() const {
  return *permission_;
}
inline const ::hadoop::fs::FsPermissionProto& FileStatusProto::permission() const {
  const ::hadoop::fs::FsPermissionProto* p = permission_;
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.permission)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::fs::FsPermissionProto*>(
      &::hadoop::fs::_FsPermissionProto_default_instance_);
}
inline ::hadoop::fs::FsPermissionProto* FileStatusProto::release_permission() {
  // @@protoc_insertion_point(field_release:hadoop.fs.FileStatusProto.permission)
  clear_has_permission();
  ::hadoop::fs::FsPermissionProto* temp = permission_;
  permission_ = NULL;
  return temp;
}
inline ::hadoop::fs::FsPermissionProto* FileStatusProto::mutable_permission() {
  set_has_permission();
  if (permission_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::fs::FsPermissionProto>(GetArenaNoVirtual());
    permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.fs.FileStatusProto.permission)
  return permission_;
}
inline void FileStatusProto::set_allocated_permission(::hadoop::fs::FsPermissionProto* permission) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete permission_;
  }
  if (permission) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      permission = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    set_has_permission();
  } else {
    clear_has_permission();
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.FileStatusProto.permission)
}

// optional string owner = 5;
inline bool FileStatusProto::has_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileStatusProto::set_has_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileStatusProto::clear_has_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileStatusProto::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_owner();
}
inline const ::std::string& FileStatusProto::owner() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.owner)
  return owner_.GetNoArena();
}
inline void FileStatusProto::set_owner(const ::std::string& value) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.owner)
}
#if LANG_CXX11
inline void FileStatusProto::set_owner(::std::string&& value) {
  set_has_owner();
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.fs.FileStatusProto.owner)
}
#endif
inline void FileStatusProto::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.fs.FileStatusProto.owner)
}
inline void FileStatusProto::set_owner(const char* value, size_t size) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.fs.FileStatusProto.owner)
}
inline ::std::string* FileStatusProto::mutable_owner() {
  set_has_owner();
  // @@protoc_insertion_point(field_mutable:hadoop.fs.FileStatusProto.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileStatusProto::release_owner() {
  // @@protoc_insertion_point(field_release:hadoop.fs.FileStatusProto.owner)
  if (!has_owner()) {
    return NULL;
  }
  clear_has_owner();
  return owner_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileStatusProto::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.FileStatusProto.owner)
}

// optional string group = 6;
inline bool FileStatusProto::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileStatusProto::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileStatusProto::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileStatusProto::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_group();
}
inline const ::std::string& FileStatusProto::group() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.group)
  return group_.GetNoArena();
}
inline void FileStatusProto::set_group(const ::std::string& value) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.group)
}
#if LANG_CXX11
inline void FileStatusProto::set_group(::std::string&& value) {
  set_has_group();
  group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.fs.FileStatusProto.group)
}
#endif
inline void FileStatusProto::set_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.fs.FileStatusProto.group)
}
inline void FileStatusProto::set_group(const char* value, size_t size) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.fs.FileStatusProto.group)
}
inline ::std::string* FileStatusProto::mutable_group() {
  set_has_group();
  // @@protoc_insertion_point(field_mutable:hadoop.fs.FileStatusProto.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileStatusProto::release_group() {
  // @@protoc_insertion_point(field_release:hadoop.fs.FileStatusProto.group)
  if (!has_group()) {
    return NULL;
  }
  clear_has_group();
  return group_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileStatusProto::set_allocated_group(::std::string* group) {
  if (group != NULL) {
    set_has_group();
  } else {
    clear_has_group();
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.FileStatusProto.group)
}

// optional uint64 modification_time = 7;
inline bool FileStatusProto::has_modification_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FileStatusProto::set_has_modification_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FileStatusProto::clear_has_modification_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FileStatusProto::clear_modification_time() {
  modification_time_ = GOOGLE_ULONGLONG(0);
  clear_has_modification_time();
}
inline ::google::protobuf::uint64 FileStatusProto::modification_time() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.modification_time)
  return modification_time_;
}
inline void FileStatusProto::set_modification_time(::google::protobuf::uint64 value) {
  set_has_modification_time();
  modification_time_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.modification_time)
}

// optional uint64 access_time = 8;
inline bool FileStatusProto::has_access_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FileStatusProto::set_has_access_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FileStatusProto::clear_has_access_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FileStatusProto::clear_access_time() {
  access_time_ = GOOGLE_ULONGLONG(0);
  clear_has_access_time();
}
inline ::google::protobuf::uint64 FileStatusProto::access_time() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.access_time)
  return access_time_;
}
inline void FileStatusProto::set_access_time(::google::protobuf::uint64 value) {
  set_has_access_time();
  access_time_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.access_time)
}

// optional string symlink = 9;
inline bool FileStatusProto::has_symlink() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileStatusProto::set_has_symlink() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileStatusProto::clear_has_symlink() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileStatusProto::clear_symlink() {
  symlink_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symlink();
}
inline const ::std::string& FileStatusProto::symlink() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.symlink)
  return symlink_.GetNoArena();
}
inline void FileStatusProto::set_symlink(const ::std::string& value) {
  set_has_symlink();
  symlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.symlink)
}
#if LANG_CXX11
inline void FileStatusProto::set_symlink(::std::string&& value) {
  set_has_symlink();
  symlink_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.fs.FileStatusProto.symlink)
}
#endif
inline void FileStatusProto::set_symlink(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symlink();
  symlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.fs.FileStatusProto.symlink)
}
inline void FileStatusProto::set_symlink(const char* value, size_t size) {
  set_has_symlink();
  symlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.fs.FileStatusProto.symlink)
}
inline ::std::string* FileStatusProto::mutable_symlink() {
  set_has_symlink();
  // @@protoc_insertion_point(field_mutable:hadoop.fs.FileStatusProto.symlink)
  return symlink_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileStatusProto::release_symlink() {
  // @@protoc_insertion_point(field_release:hadoop.fs.FileStatusProto.symlink)
  if (!has_symlink()) {
    return NULL;
  }
  clear_has_symlink();
  return symlink_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileStatusProto::set_allocated_symlink(::std::string* symlink) {
  if (symlink != NULL) {
    set_has_symlink();
  } else {
    clear_has_symlink();
  }
  symlink_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symlink);
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.FileStatusProto.symlink)
}

// optional uint32 block_replication = 10;
inline bool FileStatusProto::has_block_replication() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FileStatusProto::set_has_block_replication() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FileStatusProto::clear_has_block_replication() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FileStatusProto::clear_block_replication() {
  block_replication_ = 0u;
  clear_has_block_replication();
}
inline ::google::protobuf::uint32 FileStatusProto::block_replication() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.block_replication)
  return block_replication_;
}
inline void FileStatusProto::set_block_replication(::google::protobuf::uint32 value) {
  set_has_block_replication();
  block_replication_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.block_replication)
}

// optional uint64 block_size = 11;
inline bool FileStatusProto::has_block_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FileStatusProto::set_has_block_size() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FileStatusProto::clear_has_block_size() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FileStatusProto::clear_block_size() {
  block_size_ = GOOGLE_ULONGLONG(0);
  clear_has_block_size();
}
inline ::google::protobuf::uint64 FileStatusProto::block_size() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.block_size)
  return block_size_;
}
inline void FileStatusProto::set_block_size(::google::protobuf::uint64 value) {
  set_has_block_size();
  block_size_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.block_size)
}

// optional bytes encryption_data = 15;
inline bool FileStatusProto::has_encryption_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileStatusProto::set_has_encryption_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileStatusProto::clear_has_encryption_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileStatusProto::clear_encryption_data() {
  encryption_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encryption_data();
}
inline const ::std::string& FileStatusProto::encryption_data() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.encryption_data)
  return encryption_data_.GetNoArena();
}
inline void FileStatusProto::set_encryption_data(const ::std::string& value) {
  set_has_encryption_data();
  encryption_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.encryption_data)
}
#if LANG_CXX11
inline void FileStatusProto::set_encryption_data(::std::string&& value) {
  set_has_encryption_data();
  encryption_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.fs.FileStatusProto.encryption_data)
}
#endif
inline void FileStatusProto::set_encryption_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_encryption_data();
  encryption_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.fs.FileStatusProto.encryption_data)
}
inline void FileStatusProto::set_encryption_data(const void* value, size_t size) {
  set_has_encryption_data();
  encryption_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.fs.FileStatusProto.encryption_data)
}
inline ::std::string* FileStatusProto::mutable_encryption_data() {
  set_has_encryption_data();
  // @@protoc_insertion_point(field_mutable:hadoop.fs.FileStatusProto.encryption_data)
  return encryption_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileStatusProto::release_encryption_data() {
  // @@protoc_insertion_point(field_release:hadoop.fs.FileStatusProto.encryption_data)
  if (!has_encryption_data()) {
    return NULL;
  }
  clear_has_encryption_data();
  return encryption_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileStatusProto::set_allocated_encryption_data(::std::string* encryption_data) {
  if (encryption_data != NULL) {
    set_has_encryption_data();
  } else {
    clear_has_encryption_data();
  }
  encryption_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encryption_data);
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.FileStatusProto.encryption_data)
}

// optional bytes ec_data = 17;
inline bool FileStatusProto::has_ec_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileStatusProto::set_has_ec_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileStatusProto::clear_has_ec_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileStatusProto::clear_ec_data() {
  ec_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ec_data();
}
inline const ::std::string& FileStatusProto::ec_data() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.ec_data)
  return ec_data_.GetNoArena();
}
inline void FileStatusProto::set_ec_data(const ::std::string& value) {
  set_has_ec_data();
  ec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.ec_data)
}
#if LANG_CXX11
inline void FileStatusProto::set_ec_data(::std::string&& value) {
  set_has_ec_data();
  ec_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.fs.FileStatusProto.ec_data)
}
#endif
inline void FileStatusProto::set_ec_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ec_data();
  ec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.fs.FileStatusProto.ec_data)
}
inline void FileStatusProto::set_ec_data(const void* value, size_t size) {
  set_has_ec_data();
  ec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.fs.FileStatusProto.ec_data)
}
inline ::std::string* FileStatusProto::mutable_ec_data() {
  set_has_ec_data();
  // @@protoc_insertion_point(field_mutable:hadoop.fs.FileStatusProto.ec_data)
  return ec_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileStatusProto::release_ec_data() {
  // @@protoc_insertion_point(field_release:hadoop.fs.FileStatusProto.ec_data)
  if (!has_ec_data()) {
    return NULL;
  }
  clear_has_ec_data();
  return ec_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileStatusProto::set_allocated_ec_data(::std::string* ec_data) {
  if (ec_data != NULL) {
    set_has_ec_data();
  } else {
    clear_has_ec_data();
  }
  ec_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ec_data);
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.FileStatusProto.ec_data)
}

// optional uint32 flags = 18 [default = 0];
inline bool FileStatusProto::has_flags() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FileStatusProto::set_has_flags() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FileStatusProto::clear_has_flags() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FileStatusProto::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 FileStatusProto::flags() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.FileStatusProto.flags)
  return flags_;
}
inline void FileStatusProto::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.FileStatusProto.flags)
}

// -------------------------------------------------------------------

// LocalFileSystemPathHandleProto

// optional uint64 mtime = 1;
inline bool LocalFileSystemPathHandleProto::has_mtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalFileSystemPathHandleProto::set_has_mtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalFileSystemPathHandleProto::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalFileSystemPathHandleProto::clear_mtime() {
  mtime_ = GOOGLE_ULONGLONG(0);
  clear_has_mtime();
}
inline ::google::protobuf::uint64 LocalFileSystemPathHandleProto::mtime() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.LocalFileSystemPathHandleProto.mtime)
  return mtime_;
}
inline void LocalFileSystemPathHandleProto::set_mtime(::google::protobuf::uint64 value) {
  set_has_mtime();
  mtime_ = value;
  // @@protoc_insertion_point(field_set:hadoop.fs.LocalFileSystemPathHandleProto.mtime)
}

// optional string path = 2;
inline bool LocalFileSystemPathHandleProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalFileSystemPathHandleProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalFileSystemPathHandleProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalFileSystemPathHandleProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& LocalFileSystemPathHandleProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.fs.LocalFileSystemPathHandleProto.path)
  return path_.GetNoArena();
}
inline void LocalFileSystemPathHandleProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.fs.LocalFileSystemPathHandleProto.path)
}
#if LANG_CXX11
inline void LocalFileSystemPathHandleProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.fs.LocalFileSystemPathHandleProto.path)
}
#endif
inline void LocalFileSystemPathHandleProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.fs.LocalFileSystemPathHandleProto.path)
}
inline void LocalFileSystemPathHandleProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.fs.LocalFileSystemPathHandleProto.path)
}
inline ::std::string* LocalFileSystemPathHandleProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.fs.LocalFileSystemPathHandleProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalFileSystemPathHandleProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.fs.LocalFileSystemPathHandleProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalFileSystemPathHandleProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.fs.LocalFileSystemPathHandleProto.path)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fs
}  // namespace hadoop

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hadoop::fs::FileStatusProto_FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::fs::FileStatusProto_FileType>() {
  return ::hadoop::fs::FileStatusProto_FileType_descriptor();
}
template <> struct is_proto_enum< ::hadoop::fs::FileStatusProto_Flags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::fs::FileStatusProto_Flags>() {
  return ::hadoop::fs::FileStatusProto_Flags_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_hadoop_2dcommon_2fFSProtos_2eproto
