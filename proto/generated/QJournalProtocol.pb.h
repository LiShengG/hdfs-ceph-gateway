// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: QJournalProtocol.proto

#ifndef PROTOBUF_INCLUDED_QJournalProtocol_2eproto
#define PROTOBUF_INCLUDED_QJournalProtocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "hdfs.pb.h"
#include "HdfsServer.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_QJournalProtocol_2eproto 

namespace protobuf_QJournalProtocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[44];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_QJournalProtocol_2eproto
namespace hadoop {
namespace hdfs {
namespace qjournal {
class AcceptRecoveryRequestProto;
class AcceptRecoveryRequestProtoDefaultTypeInternal;
extern AcceptRecoveryRequestProtoDefaultTypeInternal _AcceptRecoveryRequestProto_default_instance_;
class AcceptRecoveryResponseProto;
class AcceptRecoveryResponseProtoDefaultTypeInternal;
extern AcceptRecoveryResponseProtoDefaultTypeInternal _AcceptRecoveryResponseProto_default_instance_;
class CanRollBackRequestProto;
class CanRollBackRequestProtoDefaultTypeInternal;
extern CanRollBackRequestProtoDefaultTypeInternal _CanRollBackRequestProto_default_instance_;
class CanRollBackResponseProto;
class CanRollBackResponseProtoDefaultTypeInternal;
extern CanRollBackResponseProtoDefaultTypeInternal _CanRollBackResponseProto_default_instance_;
class DiscardSegmentsRequestProto;
class DiscardSegmentsRequestProtoDefaultTypeInternal;
extern DiscardSegmentsRequestProtoDefaultTypeInternal _DiscardSegmentsRequestProto_default_instance_;
class DiscardSegmentsResponseProto;
class DiscardSegmentsResponseProtoDefaultTypeInternal;
extern DiscardSegmentsResponseProtoDefaultTypeInternal _DiscardSegmentsResponseProto_default_instance_;
class DoFinalizeRequestProto;
class DoFinalizeRequestProtoDefaultTypeInternal;
extern DoFinalizeRequestProtoDefaultTypeInternal _DoFinalizeRequestProto_default_instance_;
class DoFinalizeResponseProto;
class DoFinalizeResponseProtoDefaultTypeInternal;
extern DoFinalizeResponseProtoDefaultTypeInternal _DoFinalizeResponseProto_default_instance_;
class DoPreUpgradeRequestProto;
class DoPreUpgradeRequestProtoDefaultTypeInternal;
extern DoPreUpgradeRequestProtoDefaultTypeInternal _DoPreUpgradeRequestProto_default_instance_;
class DoPreUpgradeResponseProto;
class DoPreUpgradeResponseProtoDefaultTypeInternal;
extern DoPreUpgradeResponseProtoDefaultTypeInternal _DoPreUpgradeResponseProto_default_instance_;
class DoRollbackRequestProto;
class DoRollbackRequestProtoDefaultTypeInternal;
extern DoRollbackRequestProtoDefaultTypeInternal _DoRollbackRequestProto_default_instance_;
class DoRollbackResponseProto;
class DoRollbackResponseProtoDefaultTypeInternal;
extern DoRollbackResponseProtoDefaultTypeInternal _DoRollbackResponseProto_default_instance_;
class DoUpgradeRequestProto;
class DoUpgradeRequestProtoDefaultTypeInternal;
extern DoUpgradeRequestProtoDefaultTypeInternal _DoUpgradeRequestProto_default_instance_;
class DoUpgradeResponseProto;
class DoUpgradeResponseProtoDefaultTypeInternal;
extern DoUpgradeResponseProtoDefaultTypeInternal _DoUpgradeResponseProto_default_instance_;
class FinalizeLogSegmentRequestProto;
class FinalizeLogSegmentRequestProtoDefaultTypeInternal;
extern FinalizeLogSegmentRequestProtoDefaultTypeInternal _FinalizeLogSegmentRequestProto_default_instance_;
class FinalizeLogSegmentResponseProto;
class FinalizeLogSegmentResponseProtoDefaultTypeInternal;
extern FinalizeLogSegmentResponseProtoDefaultTypeInternal _FinalizeLogSegmentResponseProto_default_instance_;
class FormatRequestProto;
class FormatRequestProtoDefaultTypeInternal;
extern FormatRequestProtoDefaultTypeInternal _FormatRequestProto_default_instance_;
class FormatResponseProto;
class FormatResponseProtoDefaultTypeInternal;
extern FormatResponseProtoDefaultTypeInternal _FormatResponseProto_default_instance_;
class GetEditLogManifestRequestProto;
class GetEditLogManifestRequestProtoDefaultTypeInternal;
extern GetEditLogManifestRequestProtoDefaultTypeInternal _GetEditLogManifestRequestProto_default_instance_;
class GetEditLogManifestResponseProto;
class GetEditLogManifestResponseProtoDefaultTypeInternal;
extern GetEditLogManifestResponseProtoDefaultTypeInternal _GetEditLogManifestResponseProto_default_instance_;
class GetJournalCTimeRequestProto;
class GetJournalCTimeRequestProtoDefaultTypeInternal;
extern GetJournalCTimeRequestProtoDefaultTypeInternal _GetJournalCTimeRequestProto_default_instance_;
class GetJournalCTimeResponseProto;
class GetJournalCTimeResponseProtoDefaultTypeInternal;
extern GetJournalCTimeResponseProtoDefaultTypeInternal _GetJournalCTimeResponseProto_default_instance_;
class GetJournalStateRequestProto;
class GetJournalStateRequestProtoDefaultTypeInternal;
extern GetJournalStateRequestProtoDefaultTypeInternal _GetJournalStateRequestProto_default_instance_;
class GetJournalStateResponseProto;
class GetJournalStateResponseProtoDefaultTypeInternal;
extern GetJournalStateResponseProtoDefaultTypeInternal _GetJournalStateResponseProto_default_instance_;
class GetJournaledEditsRequestProto;
class GetJournaledEditsRequestProtoDefaultTypeInternal;
extern GetJournaledEditsRequestProtoDefaultTypeInternal _GetJournaledEditsRequestProto_default_instance_;
class GetJournaledEditsResponseProto;
class GetJournaledEditsResponseProtoDefaultTypeInternal;
extern GetJournaledEditsResponseProtoDefaultTypeInternal _GetJournaledEditsResponseProto_default_instance_;
class HeartbeatRequestProto;
class HeartbeatRequestProtoDefaultTypeInternal;
extern HeartbeatRequestProtoDefaultTypeInternal _HeartbeatRequestProto_default_instance_;
class HeartbeatResponseProto;
class HeartbeatResponseProtoDefaultTypeInternal;
extern HeartbeatResponseProtoDefaultTypeInternal _HeartbeatResponseProto_default_instance_;
class IsFormattedRequestProto;
class IsFormattedRequestProtoDefaultTypeInternal;
extern IsFormattedRequestProtoDefaultTypeInternal _IsFormattedRequestProto_default_instance_;
class IsFormattedResponseProto;
class IsFormattedResponseProtoDefaultTypeInternal;
extern IsFormattedResponseProtoDefaultTypeInternal _IsFormattedResponseProto_default_instance_;
class JournalIdProto;
class JournalIdProtoDefaultTypeInternal;
extern JournalIdProtoDefaultTypeInternal _JournalIdProto_default_instance_;
class JournalRequestProto;
class JournalRequestProtoDefaultTypeInternal;
extern JournalRequestProtoDefaultTypeInternal _JournalRequestProto_default_instance_;
class JournalResponseProto;
class JournalResponseProtoDefaultTypeInternal;
extern JournalResponseProtoDefaultTypeInternal _JournalResponseProto_default_instance_;
class NewEpochRequestProto;
class NewEpochRequestProtoDefaultTypeInternal;
extern NewEpochRequestProtoDefaultTypeInternal _NewEpochRequestProto_default_instance_;
class NewEpochResponseProto;
class NewEpochResponseProtoDefaultTypeInternal;
extern NewEpochResponseProtoDefaultTypeInternal _NewEpochResponseProto_default_instance_;
class PersistedRecoveryPaxosData;
class PersistedRecoveryPaxosDataDefaultTypeInternal;
extern PersistedRecoveryPaxosDataDefaultTypeInternal _PersistedRecoveryPaxosData_default_instance_;
class PrepareRecoveryRequestProto;
class PrepareRecoveryRequestProtoDefaultTypeInternal;
extern PrepareRecoveryRequestProtoDefaultTypeInternal _PrepareRecoveryRequestProto_default_instance_;
class PrepareRecoveryResponseProto;
class PrepareRecoveryResponseProtoDefaultTypeInternal;
extern PrepareRecoveryResponseProtoDefaultTypeInternal _PrepareRecoveryResponseProto_default_instance_;
class PurgeLogsRequestProto;
class PurgeLogsRequestProtoDefaultTypeInternal;
extern PurgeLogsRequestProtoDefaultTypeInternal _PurgeLogsRequestProto_default_instance_;
class PurgeLogsResponseProto;
class PurgeLogsResponseProtoDefaultTypeInternal;
extern PurgeLogsResponseProtoDefaultTypeInternal _PurgeLogsResponseProto_default_instance_;
class RequestInfoProto;
class RequestInfoProtoDefaultTypeInternal;
extern RequestInfoProtoDefaultTypeInternal _RequestInfoProto_default_instance_;
class SegmentStateProto;
class SegmentStateProtoDefaultTypeInternal;
extern SegmentStateProtoDefaultTypeInternal _SegmentStateProto_default_instance_;
class StartLogSegmentRequestProto;
class StartLogSegmentRequestProtoDefaultTypeInternal;
extern StartLogSegmentRequestProtoDefaultTypeInternal _StartLogSegmentRequestProto_default_instance_;
class StartLogSegmentResponseProto;
class StartLogSegmentResponseProtoDefaultTypeInternal;
extern StartLogSegmentResponseProtoDefaultTypeInternal _StartLogSegmentResponseProto_default_instance_;
}  // namespace qjournal
}  // namespace hdfs
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::hdfs::qjournal::AcceptRecoveryRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::AcceptRecoveryRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::AcceptRecoveryResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::AcceptRecoveryResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::CanRollBackRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::CanRollBackRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::CanRollBackResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::CanRollBackResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DiscardSegmentsRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DiscardSegmentsRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DiscardSegmentsResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DiscardSegmentsResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoFinalizeRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoFinalizeRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoFinalizeResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoFinalizeResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoPreUpgradeRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoPreUpgradeRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoPreUpgradeResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoPreUpgradeResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoRollbackRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoRollbackRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoRollbackResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoRollbackResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoUpgradeRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoUpgradeRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::DoUpgradeResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::DoUpgradeResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::FinalizeLogSegmentRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::FinalizeLogSegmentRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::FinalizeLogSegmentResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::FinalizeLogSegmentResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::FormatRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::FormatRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::FormatResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::FormatResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetEditLogManifestRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetEditLogManifestRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetEditLogManifestResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetEditLogManifestResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetJournalCTimeRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetJournalCTimeRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetJournalCTimeResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetJournalCTimeResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetJournalStateRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetJournalStateRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetJournalStateResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetJournalStateResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetJournaledEditsRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetJournaledEditsRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::GetJournaledEditsResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::GetJournaledEditsResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::HeartbeatRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::HeartbeatRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::HeartbeatResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::HeartbeatResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::IsFormattedRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::IsFormattedRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::IsFormattedResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::IsFormattedResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::JournalIdProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::JournalRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::JournalResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::NewEpochRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::NewEpochRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::NewEpochResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::NewEpochResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::PersistedRecoveryPaxosData* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::PersistedRecoveryPaxosData>(Arena*);
template<> ::hadoop::hdfs::qjournal::PrepareRecoveryRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::PrepareRecoveryRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::PrepareRecoveryResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::PrepareRecoveryResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::PurgeLogsRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::PurgeLogsRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::PurgeLogsResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::PurgeLogsResponseProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::RequestInfoProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::SegmentStateProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::SegmentStateProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::StartLogSegmentRequestProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::StartLogSegmentRequestProto>(Arena*);
template<> ::hadoop::hdfs::qjournal::StartLogSegmentResponseProto* Arena::CreateMaybeMessage<::hadoop::hdfs::qjournal::StartLogSegmentResponseProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace hdfs {
namespace qjournal {

// ===================================================================

class JournalIdProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.JournalIdProto) */ {
 public:
  JournalIdProto();
  virtual ~JournalIdProto();

  JournalIdProto(const JournalIdProto& from);

  inline JournalIdProto& operator=(const JournalIdProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JournalIdProto(JournalIdProto&& from) noexcept
    : JournalIdProto() {
    *this = ::std::move(from);
  }

  inline JournalIdProto& operator=(JournalIdProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JournalIdProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JournalIdProto* internal_default_instance() {
    return reinterpret_cast<const JournalIdProto*>(
               &_JournalIdProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(JournalIdProto* other);
  friend void swap(JournalIdProto& a, JournalIdProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JournalIdProto* New() const final {
    return CreateMaybeMessage<JournalIdProto>(NULL);
  }

  JournalIdProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JournalIdProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JournalIdProto& from);
  void MergeFrom(const JournalIdProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JournalIdProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  #if LANG_CXX11
  void set_identifier(::std::string&& value);
  #endif
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.JournalIdProto)
 private:
  void set_has_identifier();
  void clear_has_identifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.RequestInfoProto) */ {
 public:
  RequestInfoProto();
  virtual ~RequestInfoProto();

  RequestInfoProto(const RequestInfoProto& from);

  inline RequestInfoProto& operator=(const RequestInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestInfoProto(RequestInfoProto&& from) noexcept
    : RequestInfoProto() {
    *this = ::std::move(from);
  }

  inline RequestInfoProto& operator=(RequestInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestInfoProto* internal_default_instance() {
    return reinterpret_cast<const RequestInfoProto*>(
               &_RequestInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RequestInfoProto* other);
  friend void swap(RequestInfoProto& a, RequestInfoProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestInfoProto* New() const final {
    return CreateMaybeMessage<RequestInfoProto>(NULL);
  }

  RequestInfoProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestInfoProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestInfoProto& from);
  void MergeFrom(const RequestInfoProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 5;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 5;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto journalId = 1;
  bool has_journalid() const;
  void clear_journalid();
  static const int kJournalIdFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_journalid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& journalid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_journalid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_journalid();
  void set_allocated_journalid(::hadoop::hdfs::qjournal::JournalIdProto* journalid);

  // required uint64 epoch = 2;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 2;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // required uint64 ipcSerialNumber = 3;
  bool has_ipcserialnumber() const;
  void clear_ipcserialnumber();
  static const int kIpcSerialNumberFieldNumber = 3;
  ::google::protobuf::uint64 ipcserialnumber() const;
  void set_ipcserialnumber(::google::protobuf::uint64 value);

  // optional uint64 committedTxId = 4;
  bool has_committedtxid() const;
  void clear_committedtxid();
  static const int kCommittedTxIdFieldNumber = 4;
  ::google::protobuf::uint64 committedtxid() const;
  void set_committedtxid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.RequestInfoProto)
 private:
  void set_has_journalid();
  void clear_has_journalid();
  void set_has_epoch();
  void clear_has_epoch();
  void set_has_ipcserialnumber();
  void clear_has_ipcserialnumber();
  void set_has_committedtxid();
  void clear_has_committedtxid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* journalid_;
  ::google::protobuf::uint64 epoch_;
  ::google::protobuf::uint64 ipcserialnumber_;
  ::google::protobuf::uint64 committedtxid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SegmentStateProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.SegmentStateProto) */ {
 public:
  SegmentStateProto();
  virtual ~SegmentStateProto();

  SegmentStateProto(const SegmentStateProto& from);

  inline SegmentStateProto& operator=(const SegmentStateProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SegmentStateProto(SegmentStateProto&& from) noexcept
    : SegmentStateProto() {
    *this = ::std::move(from);
  }

  inline SegmentStateProto& operator=(SegmentStateProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentStateProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentStateProto* internal_default_instance() {
    return reinterpret_cast<const SegmentStateProto*>(
               &_SegmentStateProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SegmentStateProto* other);
  friend void swap(SegmentStateProto& a, SegmentStateProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SegmentStateProto* New() const final {
    return CreateMaybeMessage<SegmentStateProto>(NULL);
  }

  SegmentStateProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SegmentStateProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SegmentStateProto& from);
  void MergeFrom(const SegmentStateProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentStateProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 startTxId = 1;
  bool has_starttxid() const;
  void clear_starttxid();
  static const int kStartTxIdFieldNumber = 1;
  ::google::protobuf::uint64 starttxid() const;
  void set_starttxid(::google::protobuf::uint64 value);

  // required uint64 endTxId = 2;
  bool has_endtxid() const;
  void clear_endtxid();
  static const int kEndTxIdFieldNumber = 2;
  ::google::protobuf::uint64 endtxid() const;
  void set_endtxid(::google::protobuf::uint64 value);

  // required bool isInProgress = 3;
  bool has_isinprogress() const;
  void clear_isinprogress();
  static const int kIsInProgressFieldNumber = 3;
  bool isinprogress() const;
  void set_isinprogress(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.SegmentStateProto)
 private:
  void set_has_starttxid();
  void clear_has_starttxid();
  void set_has_endtxid();
  void clear_has_endtxid();
  void set_has_isinprogress();
  void clear_has_isinprogress();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 starttxid_;
  ::google::protobuf::uint64 endtxid_;
  bool isinprogress_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PersistedRecoveryPaxosData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData) */ {
 public:
  PersistedRecoveryPaxosData();
  virtual ~PersistedRecoveryPaxosData();

  PersistedRecoveryPaxosData(const PersistedRecoveryPaxosData& from);

  inline PersistedRecoveryPaxosData& operator=(const PersistedRecoveryPaxosData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PersistedRecoveryPaxosData(PersistedRecoveryPaxosData&& from) noexcept
    : PersistedRecoveryPaxosData() {
    *this = ::std::move(from);
  }

  inline PersistedRecoveryPaxosData& operator=(PersistedRecoveryPaxosData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PersistedRecoveryPaxosData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PersistedRecoveryPaxosData* internal_default_instance() {
    return reinterpret_cast<const PersistedRecoveryPaxosData*>(
               &_PersistedRecoveryPaxosData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PersistedRecoveryPaxosData* other);
  friend void swap(PersistedRecoveryPaxosData& a, PersistedRecoveryPaxosData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PersistedRecoveryPaxosData* New() const final {
    return CreateMaybeMessage<PersistedRecoveryPaxosData>(NULL);
  }

  PersistedRecoveryPaxosData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PersistedRecoveryPaxosData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PersistedRecoveryPaxosData& from);
  void MergeFrom(const PersistedRecoveryPaxosData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PersistedRecoveryPaxosData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.SegmentStateProto segmentState = 1;
  bool has_segmentstate() const;
  void clear_segmentstate();
  static const int kSegmentStateFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::SegmentStateProto& _internal_segmentstate() const;
  public:
  const ::hadoop::hdfs::qjournal::SegmentStateProto& segmentstate() const;
  ::hadoop::hdfs::qjournal::SegmentStateProto* release_segmentstate();
  ::hadoop::hdfs::qjournal::SegmentStateProto* mutable_segmentstate();
  void set_allocated_segmentstate(::hadoop::hdfs::qjournal::SegmentStateProto* segmentstate);

  // required uint64 acceptedInEpoch = 2;
  bool has_acceptedinepoch() const;
  void clear_acceptedinepoch();
  static const int kAcceptedInEpochFieldNumber = 2;
  ::google::protobuf::uint64 acceptedinepoch() const;
  void set_acceptedinepoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData)
 private:
  void set_has_segmentstate();
  void clear_has_segmentstate();
  void set_has_acceptedinepoch();
  void clear_has_acceptedinepoch();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::SegmentStateProto* segmentstate_;
  ::google::protobuf::uint64 acceptedinepoch_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JournalRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.JournalRequestProto) */ {
 public:
  JournalRequestProto();
  virtual ~JournalRequestProto();

  JournalRequestProto(const JournalRequestProto& from);

  inline JournalRequestProto& operator=(const JournalRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JournalRequestProto(JournalRequestProto&& from) noexcept
    : JournalRequestProto() {
    *this = ::std::move(from);
  }

  inline JournalRequestProto& operator=(JournalRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JournalRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JournalRequestProto* internal_default_instance() {
    return reinterpret_cast<const JournalRequestProto*>(
               &_JournalRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(JournalRequestProto* other);
  friend void swap(JournalRequestProto& a, JournalRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JournalRequestProto* New() const final {
    return CreateMaybeMessage<JournalRequestProto>(NULL);
  }

  JournalRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JournalRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JournalRequestProto& from);
  void MergeFrom(const JournalRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JournalRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes records = 4;
  bool has_records() const;
  void clear_records();
  static const int kRecordsFieldNumber = 4;
  const ::std::string& records() const;
  void set_records(const ::std::string& value);
  #if LANG_CXX11
  void set_records(::std::string&& value);
  #endif
  void set_records(const char* value);
  void set_records(const void* value, size_t size);
  ::std::string* mutable_records();
  ::std::string* release_records();
  void set_allocated_records(::std::string* records);

  // optional string nameServiceId = 6;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 6;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
  bool has_reqinfo() const;
  void clear_reqinfo();
  static const int kReqInfoFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& _internal_reqinfo() const;
  public:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& reqinfo() const;
  ::hadoop::hdfs::qjournal::RequestInfoProto* release_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* mutable_reqinfo();
  void set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo);

  // required uint64 firstTxnId = 2;
  bool has_firsttxnid() const;
  void clear_firsttxnid();
  static const int kFirstTxnIdFieldNumber = 2;
  ::google::protobuf::uint64 firsttxnid() const;
  void set_firsttxnid(::google::protobuf::uint64 value);

  // required uint64 segmentTxnId = 5;
  bool has_segmenttxnid() const;
  void clear_segmenttxnid();
  static const int kSegmentTxnIdFieldNumber = 5;
  ::google::protobuf::uint64 segmenttxnid() const;
  void set_segmenttxnid(::google::protobuf::uint64 value);

  // required uint32 numTxns = 3;
  bool has_numtxns() const;
  void clear_numtxns();
  static const int kNumTxnsFieldNumber = 3;
  ::google::protobuf::uint32 numtxns() const;
  void set_numtxns(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.JournalRequestProto)
 private:
  void set_has_reqinfo();
  void clear_has_reqinfo();
  void set_has_firsttxnid();
  void clear_has_firsttxnid();
  void set_has_numtxns();
  void clear_has_numtxns();
  void set_has_records();
  void clear_has_records();
  void set_has_segmenttxnid();
  void clear_has_segmenttxnid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr records_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo_;
  ::google::protobuf::uint64 firsttxnid_;
  ::google::protobuf::uint64 segmenttxnid_;
  ::google::protobuf::uint32 numtxns_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JournalResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.JournalResponseProto) */ {
 public:
  JournalResponseProto();
  virtual ~JournalResponseProto();

  JournalResponseProto(const JournalResponseProto& from);

  inline JournalResponseProto& operator=(const JournalResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JournalResponseProto(JournalResponseProto&& from) noexcept
    : JournalResponseProto() {
    *this = ::std::move(from);
  }

  inline JournalResponseProto& operator=(JournalResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JournalResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JournalResponseProto* internal_default_instance() {
    return reinterpret_cast<const JournalResponseProto*>(
               &_JournalResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(JournalResponseProto* other);
  friend void swap(JournalResponseProto& a, JournalResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JournalResponseProto* New() const final {
    return CreateMaybeMessage<JournalResponseProto>(NULL);
  }

  JournalResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JournalResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JournalResponseProto& from);
  void MergeFrom(const JournalResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JournalResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.JournalResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.HeartbeatRequestProto) */ {
 public:
  HeartbeatRequestProto();
  virtual ~HeartbeatRequestProto();

  HeartbeatRequestProto(const HeartbeatRequestProto& from);

  inline HeartbeatRequestProto& operator=(const HeartbeatRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatRequestProto(HeartbeatRequestProto&& from) noexcept
    : HeartbeatRequestProto() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequestProto& operator=(HeartbeatRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatRequestProto* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequestProto*>(
               &_HeartbeatRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(HeartbeatRequestProto* other);
  friend void swap(HeartbeatRequestProto& a, HeartbeatRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatRequestProto* New() const final {
    return CreateMaybeMessage<HeartbeatRequestProto>(NULL);
  }

  HeartbeatRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatRequestProto& from);
  void MergeFrom(const HeartbeatRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
  bool has_reqinfo() const;
  void clear_reqinfo();
  static const int kReqInfoFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& _internal_reqinfo() const;
  public:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& reqinfo() const;
  ::hadoop::hdfs::qjournal::RequestInfoProto* release_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* mutable_reqinfo();
  void set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.HeartbeatRequestProto)
 private:
  void set_has_reqinfo();
  void clear_has_reqinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.HeartbeatResponseProto) */ {
 public:
  HeartbeatResponseProto();
  virtual ~HeartbeatResponseProto();

  HeartbeatResponseProto(const HeartbeatResponseProto& from);

  inline HeartbeatResponseProto& operator=(const HeartbeatResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatResponseProto(HeartbeatResponseProto&& from) noexcept
    : HeartbeatResponseProto() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponseProto& operator=(HeartbeatResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatResponseProto* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponseProto*>(
               &_HeartbeatResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(HeartbeatResponseProto* other);
  friend void swap(HeartbeatResponseProto& a, HeartbeatResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatResponseProto* New() const final {
    return CreateMaybeMessage<HeartbeatResponseProto>(NULL);
  }

  HeartbeatResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatResponseProto& from);
  void MergeFrom(const HeartbeatResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.HeartbeatResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartLogSegmentRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.StartLogSegmentRequestProto) */ {
 public:
  StartLogSegmentRequestProto();
  virtual ~StartLogSegmentRequestProto();

  StartLogSegmentRequestProto(const StartLogSegmentRequestProto& from);

  inline StartLogSegmentRequestProto& operator=(const StartLogSegmentRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartLogSegmentRequestProto(StartLogSegmentRequestProto&& from) noexcept
    : StartLogSegmentRequestProto() {
    *this = ::std::move(from);
  }

  inline StartLogSegmentRequestProto& operator=(StartLogSegmentRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartLogSegmentRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartLogSegmentRequestProto* internal_default_instance() {
    return reinterpret_cast<const StartLogSegmentRequestProto*>(
               &_StartLogSegmentRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(StartLogSegmentRequestProto* other);
  friend void swap(StartLogSegmentRequestProto& a, StartLogSegmentRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartLogSegmentRequestProto* New() const final {
    return CreateMaybeMessage<StartLogSegmentRequestProto>(NULL);
  }

  StartLogSegmentRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartLogSegmentRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartLogSegmentRequestProto& from);
  void MergeFrom(const StartLogSegmentRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartLogSegmentRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
  bool has_reqinfo() const;
  void clear_reqinfo();
  static const int kReqInfoFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& _internal_reqinfo() const;
  public:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& reqinfo() const;
  ::hadoop::hdfs::qjournal::RequestInfoProto* release_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* mutable_reqinfo();
  void set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo);

  // required uint64 txid = 2;
  bool has_txid() const;
  void clear_txid();
  static const int kTxidFieldNumber = 2;
  ::google::protobuf::uint64 txid() const;
  void set_txid(::google::protobuf::uint64 value);

  // optional sint32 layoutVersion = 3;
  bool has_layoutversion() const;
  void clear_layoutversion();
  static const int kLayoutVersionFieldNumber = 3;
  ::google::protobuf::int32 layoutversion() const;
  void set_layoutversion(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.StartLogSegmentRequestProto)
 private:
  void set_has_reqinfo();
  void clear_has_reqinfo();
  void set_has_txid();
  void clear_has_txid();
  void set_has_layoutversion();
  void clear_has_layoutversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo_;
  ::google::protobuf::uint64 txid_;
  ::google::protobuf::int32 layoutversion_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartLogSegmentResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.StartLogSegmentResponseProto) */ {
 public:
  StartLogSegmentResponseProto();
  virtual ~StartLogSegmentResponseProto();

  StartLogSegmentResponseProto(const StartLogSegmentResponseProto& from);

  inline StartLogSegmentResponseProto& operator=(const StartLogSegmentResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartLogSegmentResponseProto(StartLogSegmentResponseProto&& from) noexcept
    : StartLogSegmentResponseProto() {
    *this = ::std::move(from);
  }

  inline StartLogSegmentResponseProto& operator=(StartLogSegmentResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartLogSegmentResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartLogSegmentResponseProto* internal_default_instance() {
    return reinterpret_cast<const StartLogSegmentResponseProto*>(
               &_StartLogSegmentResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(StartLogSegmentResponseProto* other);
  friend void swap(StartLogSegmentResponseProto& a, StartLogSegmentResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartLogSegmentResponseProto* New() const final {
    return CreateMaybeMessage<StartLogSegmentResponseProto>(NULL);
  }

  StartLogSegmentResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartLogSegmentResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartLogSegmentResponseProto& from);
  void MergeFrom(const StartLogSegmentResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartLogSegmentResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.StartLogSegmentResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FinalizeLogSegmentRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto) */ {
 public:
  FinalizeLogSegmentRequestProto();
  virtual ~FinalizeLogSegmentRequestProto();

  FinalizeLogSegmentRequestProto(const FinalizeLogSegmentRequestProto& from);

  inline FinalizeLogSegmentRequestProto& operator=(const FinalizeLogSegmentRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FinalizeLogSegmentRequestProto(FinalizeLogSegmentRequestProto&& from) noexcept
    : FinalizeLogSegmentRequestProto() {
    *this = ::std::move(from);
  }

  inline FinalizeLogSegmentRequestProto& operator=(FinalizeLogSegmentRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinalizeLogSegmentRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinalizeLogSegmentRequestProto* internal_default_instance() {
    return reinterpret_cast<const FinalizeLogSegmentRequestProto*>(
               &_FinalizeLogSegmentRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(FinalizeLogSegmentRequestProto* other);
  friend void swap(FinalizeLogSegmentRequestProto& a, FinalizeLogSegmentRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinalizeLogSegmentRequestProto* New() const final {
    return CreateMaybeMessage<FinalizeLogSegmentRequestProto>(NULL);
  }

  FinalizeLogSegmentRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FinalizeLogSegmentRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FinalizeLogSegmentRequestProto& from);
  void MergeFrom(const FinalizeLogSegmentRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinalizeLogSegmentRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
  bool has_reqinfo() const;
  void clear_reqinfo();
  static const int kReqInfoFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& _internal_reqinfo() const;
  public:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& reqinfo() const;
  ::hadoop::hdfs::qjournal::RequestInfoProto* release_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* mutable_reqinfo();
  void set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo);

  // required uint64 startTxId = 2;
  bool has_starttxid() const;
  void clear_starttxid();
  static const int kStartTxIdFieldNumber = 2;
  ::google::protobuf::uint64 starttxid() const;
  void set_starttxid(::google::protobuf::uint64 value);

  // required uint64 endTxId = 3;
  bool has_endtxid() const;
  void clear_endtxid();
  static const int kEndTxIdFieldNumber = 3;
  ::google::protobuf::uint64 endtxid() const;
  void set_endtxid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto)
 private:
  void set_has_reqinfo();
  void clear_has_reqinfo();
  void set_has_starttxid();
  void clear_has_starttxid();
  void set_has_endtxid();
  void clear_has_endtxid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo_;
  ::google::protobuf::uint64 starttxid_;
  ::google::protobuf::uint64 endtxid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FinalizeLogSegmentResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.FinalizeLogSegmentResponseProto) */ {
 public:
  FinalizeLogSegmentResponseProto();
  virtual ~FinalizeLogSegmentResponseProto();

  FinalizeLogSegmentResponseProto(const FinalizeLogSegmentResponseProto& from);

  inline FinalizeLogSegmentResponseProto& operator=(const FinalizeLogSegmentResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FinalizeLogSegmentResponseProto(FinalizeLogSegmentResponseProto&& from) noexcept
    : FinalizeLogSegmentResponseProto() {
    *this = ::std::move(from);
  }

  inline FinalizeLogSegmentResponseProto& operator=(FinalizeLogSegmentResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinalizeLogSegmentResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinalizeLogSegmentResponseProto* internal_default_instance() {
    return reinterpret_cast<const FinalizeLogSegmentResponseProto*>(
               &_FinalizeLogSegmentResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FinalizeLogSegmentResponseProto* other);
  friend void swap(FinalizeLogSegmentResponseProto& a, FinalizeLogSegmentResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinalizeLogSegmentResponseProto* New() const final {
    return CreateMaybeMessage<FinalizeLogSegmentResponseProto>(NULL);
  }

  FinalizeLogSegmentResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FinalizeLogSegmentResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FinalizeLogSegmentResponseProto& from);
  void MergeFrom(const FinalizeLogSegmentResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinalizeLogSegmentResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.FinalizeLogSegmentResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PurgeLogsRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.PurgeLogsRequestProto) */ {
 public:
  PurgeLogsRequestProto();
  virtual ~PurgeLogsRequestProto();

  PurgeLogsRequestProto(const PurgeLogsRequestProto& from);

  inline PurgeLogsRequestProto& operator=(const PurgeLogsRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PurgeLogsRequestProto(PurgeLogsRequestProto&& from) noexcept
    : PurgeLogsRequestProto() {
    *this = ::std::move(from);
  }

  inline PurgeLogsRequestProto& operator=(PurgeLogsRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PurgeLogsRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PurgeLogsRequestProto* internal_default_instance() {
    return reinterpret_cast<const PurgeLogsRequestProto*>(
               &_PurgeLogsRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PurgeLogsRequestProto* other);
  friend void swap(PurgeLogsRequestProto& a, PurgeLogsRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PurgeLogsRequestProto* New() const final {
    return CreateMaybeMessage<PurgeLogsRequestProto>(NULL);
  }

  PurgeLogsRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PurgeLogsRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PurgeLogsRequestProto& from);
  void MergeFrom(const PurgeLogsRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurgeLogsRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
  bool has_reqinfo() const;
  void clear_reqinfo();
  static const int kReqInfoFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& _internal_reqinfo() const;
  public:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& reqinfo() const;
  ::hadoop::hdfs::qjournal::RequestInfoProto* release_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* mutable_reqinfo();
  void set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo);

  // required uint64 minTxIdToKeep = 2;
  bool has_mintxidtokeep() const;
  void clear_mintxidtokeep();
  static const int kMinTxIdToKeepFieldNumber = 2;
  ::google::protobuf::uint64 mintxidtokeep() const;
  void set_mintxidtokeep(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.PurgeLogsRequestProto)
 private:
  void set_has_reqinfo();
  void clear_has_reqinfo();
  void set_has_mintxidtokeep();
  void clear_has_mintxidtokeep();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo_;
  ::google::protobuf::uint64 mintxidtokeep_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PurgeLogsResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.PurgeLogsResponseProto) */ {
 public:
  PurgeLogsResponseProto();
  virtual ~PurgeLogsResponseProto();

  PurgeLogsResponseProto(const PurgeLogsResponseProto& from);

  inline PurgeLogsResponseProto& operator=(const PurgeLogsResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PurgeLogsResponseProto(PurgeLogsResponseProto&& from) noexcept
    : PurgeLogsResponseProto() {
    *this = ::std::move(from);
  }

  inline PurgeLogsResponseProto& operator=(PurgeLogsResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PurgeLogsResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PurgeLogsResponseProto* internal_default_instance() {
    return reinterpret_cast<const PurgeLogsResponseProto*>(
               &_PurgeLogsResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(PurgeLogsResponseProto* other);
  friend void swap(PurgeLogsResponseProto& a, PurgeLogsResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PurgeLogsResponseProto* New() const final {
    return CreateMaybeMessage<PurgeLogsResponseProto>(NULL);
  }

  PurgeLogsResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PurgeLogsResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PurgeLogsResponseProto& from);
  void MergeFrom(const PurgeLogsResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurgeLogsResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.PurgeLogsResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsFormattedRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.IsFormattedRequestProto) */ {
 public:
  IsFormattedRequestProto();
  virtual ~IsFormattedRequestProto();

  IsFormattedRequestProto(const IsFormattedRequestProto& from);

  inline IsFormattedRequestProto& operator=(const IsFormattedRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsFormattedRequestProto(IsFormattedRequestProto&& from) noexcept
    : IsFormattedRequestProto() {
    *this = ::std::move(from);
  }

  inline IsFormattedRequestProto& operator=(IsFormattedRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsFormattedRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsFormattedRequestProto* internal_default_instance() {
    return reinterpret_cast<const IsFormattedRequestProto*>(
               &_IsFormattedRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(IsFormattedRequestProto* other);
  friend void swap(IsFormattedRequestProto& a, IsFormattedRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsFormattedRequestProto* New() const final {
    return CreateMaybeMessage<IsFormattedRequestProto>(NULL);
  }

  IsFormattedRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsFormattedRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsFormattedRequestProto& from);
  void MergeFrom(const IsFormattedRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsFormattedRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 2;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 2;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.IsFormattedRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsFormattedResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.IsFormattedResponseProto) */ {
 public:
  IsFormattedResponseProto();
  virtual ~IsFormattedResponseProto();

  IsFormattedResponseProto(const IsFormattedResponseProto& from);

  inline IsFormattedResponseProto& operator=(const IsFormattedResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsFormattedResponseProto(IsFormattedResponseProto&& from) noexcept
    : IsFormattedResponseProto() {
    *this = ::std::move(from);
  }

  inline IsFormattedResponseProto& operator=(IsFormattedResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsFormattedResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsFormattedResponseProto* internal_default_instance() {
    return reinterpret_cast<const IsFormattedResponseProto*>(
               &_IsFormattedResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(IsFormattedResponseProto* other);
  friend void swap(IsFormattedResponseProto& a, IsFormattedResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsFormattedResponseProto* New() const final {
    return CreateMaybeMessage<IsFormattedResponseProto>(NULL);
  }

  IsFormattedResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsFormattedResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsFormattedResponseProto& from);
  void MergeFrom(const IsFormattedResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsFormattedResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isFormatted = 1;
  bool has_isformatted() const;
  void clear_isformatted();
  static const int kIsFormattedFieldNumber = 1;
  bool isformatted() const;
  void set_isformatted(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.IsFormattedResponseProto)
 private:
  void set_has_isformatted();
  void clear_has_isformatted();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool isformatted_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetJournalCTimeRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto) */ {
 public:
  GetJournalCTimeRequestProto();
  virtual ~GetJournalCTimeRequestProto();

  GetJournalCTimeRequestProto(const GetJournalCTimeRequestProto& from);

  inline GetJournalCTimeRequestProto& operator=(const GetJournalCTimeRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetJournalCTimeRequestProto(GetJournalCTimeRequestProto&& from) noexcept
    : GetJournalCTimeRequestProto() {
    *this = ::std::move(from);
  }

  inline GetJournalCTimeRequestProto& operator=(GetJournalCTimeRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJournalCTimeRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJournalCTimeRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetJournalCTimeRequestProto*>(
               &_GetJournalCTimeRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GetJournalCTimeRequestProto* other);
  friend void swap(GetJournalCTimeRequestProto& a, GetJournalCTimeRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetJournalCTimeRequestProto* New() const final {
    return CreateMaybeMessage<GetJournalCTimeRequestProto>(NULL);
  }

  GetJournalCTimeRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetJournalCTimeRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetJournalCTimeRequestProto& from);
  void MergeFrom(const GetJournalCTimeRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJournalCTimeRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 2;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 2;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetJournalCTimeResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetJournalCTimeResponseProto) */ {
 public:
  GetJournalCTimeResponseProto();
  virtual ~GetJournalCTimeResponseProto();

  GetJournalCTimeResponseProto(const GetJournalCTimeResponseProto& from);

  inline GetJournalCTimeResponseProto& operator=(const GetJournalCTimeResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetJournalCTimeResponseProto(GetJournalCTimeResponseProto&& from) noexcept
    : GetJournalCTimeResponseProto() {
    *this = ::std::move(from);
  }

  inline GetJournalCTimeResponseProto& operator=(GetJournalCTimeResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJournalCTimeResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJournalCTimeResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetJournalCTimeResponseProto*>(
               &_GetJournalCTimeResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetJournalCTimeResponseProto* other);
  friend void swap(GetJournalCTimeResponseProto& a, GetJournalCTimeResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetJournalCTimeResponseProto* New() const final {
    return CreateMaybeMessage<GetJournalCTimeResponseProto>(NULL);
  }

  GetJournalCTimeResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetJournalCTimeResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetJournalCTimeResponseProto& from);
  void MergeFrom(const GetJournalCTimeResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJournalCTimeResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 resultCTime = 1;
  bool has_resultctime() const;
  void clear_resultctime();
  static const int kResultCTimeFieldNumber = 1;
  ::google::protobuf::int64 resultctime() const;
  void set_resultctime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetJournalCTimeResponseProto)
 private:
  void set_has_resultctime();
  void clear_has_resultctime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 resultctime_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoPreUpgradeRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoPreUpgradeRequestProto) */ {
 public:
  DoPreUpgradeRequestProto();
  virtual ~DoPreUpgradeRequestProto();

  DoPreUpgradeRequestProto(const DoPreUpgradeRequestProto& from);

  inline DoPreUpgradeRequestProto& operator=(const DoPreUpgradeRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoPreUpgradeRequestProto(DoPreUpgradeRequestProto&& from) noexcept
    : DoPreUpgradeRequestProto() {
    *this = ::std::move(from);
  }

  inline DoPreUpgradeRequestProto& operator=(DoPreUpgradeRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoPreUpgradeRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoPreUpgradeRequestProto* internal_default_instance() {
    return reinterpret_cast<const DoPreUpgradeRequestProto*>(
               &_DoPreUpgradeRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(DoPreUpgradeRequestProto* other);
  friend void swap(DoPreUpgradeRequestProto& a, DoPreUpgradeRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoPreUpgradeRequestProto* New() const final {
    return CreateMaybeMessage<DoPreUpgradeRequestProto>(NULL);
  }

  DoPreUpgradeRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoPreUpgradeRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoPreUpgradeRequestProto& from);
  void MergeFrom(const DoPreUpgradeRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoPreUpgradeRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoPreUpgradeRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoPreUpgradeResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoPreUpgradeResponseProto) */ {
 public:
  DoPreUpgradeResponseProto();
  virtual ~DoPreUpgradeResponseProto();

  DoPreUpgradeResponseProto(const DoPreUpgradeResponseProto& from);

  inline DoPreUpgradeResponseProto& operator=(const DoPreUpgradeResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoPreUpgradeResponseProto(DoPreUpgradeResponseProto&& from) noexcept
    : DoPreUpgradeResponseProto() {
    *this = ::std::move(from);
  }

  inline DoPreUpgradeResponseProto& operator=(DoPreUpgradeResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoPreUpgradeResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoPreUpgradeResponseProto* internal_default_instance() {
    return reinterpret_cast<const DoPreUpgradeResponseProto*>(
               &_DoPreUpgradeResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(DoPreUpgradeResponseProto* other);
  friend void swap(DoPreUpgradeResponseProto& a, DoPreUpgradeResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoPreUpgradeResponseProto* New() const final {
    return CreateMaybeMessage<DoPreUpgradeResponseProto>(NULL);
  }

  DoPreUpgradeResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoPreUpgradeResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoPreUpgradeResponseProto& from);
  void MergeFrom(const DoPreUpgradeResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoPreUpgradeResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoPreUpgradeResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoUpgradeRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoUpgradeRequestProto) */ {
 public:
  DoUpgradeRequestProto();
  virtual ~DoUpgradeRequestProto();

  DoUpgradeRequestProto(const DoUpgradeRequestProto& from);

  inline DoUpgradeRequestProto& operator=(const DoUpgradeRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoUpgradeRequestProto(DoUpgradeRequestProto&& from) noexcept
    : DoUpgradeRequestProto() {
    *this = ::std::move(from);
  }

  inline DoUpgradeRequestProto& operator=(DoUpgradeRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoUpgradeRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoUpgradeRequestProto* internal_default_instance() {
    return reinterpret_cast<const DoUpgradeRequestProto*>(
               &_DoUpgradeRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(DoUpgradeRequestProto* other);
  friend void swap(DoUpgradeRequestProto& a, DoUpgradeRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoUpgradeRequestProto* New() const final {
    return CreateMaybeMessage<DoUpgradeRequestProto>(NULL);
  }

  DoUpgradeRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoUpgradeRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoUpgradeRequestProto& from);
  void MergeFrom(const DoUpgradeRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoUpgradeRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // required .hadoop.hdfs.StorageInfoProto sInfo = 2;
  bool has_sinfo() const;
  void clear_sinfo();
  static const int kSInfoFieldNumber = 2;
  private:
  const ::hadoop::hdfs::StorageInfoProto& _internal_sinfo() const;
  public:
  const ::hadoop::hdfs::StorageInfoProto& sinfo() const;
  ::hadoop::hdfs::StorageInfoProto* release_sinfo();
  ::hadoop::hdfs::StorageInfoProto* mutable_sinfo();
  void set_allocated_sinfo(::hadoop::hdfs::StorageInfoProto* sinfo);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoUpgradeRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_sinfo();
  void clear_has_sinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  ::hadoop::hdfs::StorageInfoProto* sinfo_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoUpgradeResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoUpgradeResponseProto) */ {
 public:
  DoUpgradeResponseProto();
  virtual ~DoUpgradeResponseProto();

  DoUpgradeResponseProto(const DoUpgradeResponseProto& from);

  inline DoUpgradeResponseProto& operator=(const DoUpgradeResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoUpgradeResponseProto(DoUpgradeResponseProto&& from) noexcept
    : DoUpgradeResponseProto() {
    *this = ::std::move(from);
  }

  inline DoUpgradeResponseProto& operator=(DoUpgradeResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoUpgradeResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoUpgradeResponseProto* internal_default_instance() {
    return reinterpret_cast<const DoUpgradeResponseProto*>(
               &_DoUpgradeResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(DoUpgradeResponseProto* other);
  friend void swap(DoUpgradeResponseProto& a, DoUpgradeResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoUpgradeResponseProto* New() const final {
    return CreateMaybeMessage<DoUpgradeResponseProto>(NULL);
  }

  DoUpgradeResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoUpgradeResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoUpgradeResponseProto& from);
  void MergeFrom(const DoUpgradeResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoUpgradeResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoUpgradeResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoFinalizeRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoFinalizeRequestProto) */ {
 public:
  DoFinalizeRequestProto();
  virtual ~DoFinalizeRequestProto();

  DoFinalizeRequestProto(const DoFinalizeRequestProto& from);

  inline DoFinalizeRequestProto& operator=(const DoFinalizeRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoFinalizeRequestProto(DoFinalizeRequestProto&& from) noexcept
    : DoFinalizeRequestProto() {
    *this = ::std::move(from);
  }

  inline DoFinalizeRequestProto& operator=(DoFinalizeRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoFinalizeRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoFinalizeRequestProto* internal_default_instance() {
    return reinterpret_cast<const DoFinalizeRequestProto*>(
               &_DoFinalizeRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(DoFinalizeRequestProto* other);
  friend void swap(DoFinalizeRequestProto& a, DoFinalizeRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoFinalizeRequestProto* New() const final {
    return CreateMaybeMessage<DoFinalizeRequestProto>(NULL);
  }

  DoFinalizeRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoFinalizeRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoFinalizeRequestProto& from);
  void MergeFrom(const DoFinalizeRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoFinalizeRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 2;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 2;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoFinalizeRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoFinalizeResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoFinalizeResponseProto) */ {
 public:
  DoFinalizeResponseProto();
  virtual ~DoFinalizeResponseProto();

  DoFinalizeResponseProto(const DoFinalizeResponseProto& from);

  inline DoFinalizeResponseProto& operator=(const DoFinalizeResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoFinalizeResponseProto(DoFinalizeResponseProto&& from) noexcept
    : DoFinalizeResponseProto() {
    *this = ::std::move(from);
  }

  inline DoFinalizeResponseProto& operator=(DoFinalizeResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoFinalizeResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoFinalizeResponseProto* internal_default_instance() {
    return reinterpret_cast<const DoFinalizeResponseProto*>(
               &_DoFinalizeResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(DoFinalizeResponseProto* other);
  friend void swap(DoFinalizeResponseProto& a, DoFinalizeResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoFinalizeResponseProto* New() const final {
    return CreateMaybeMessage<DoFinalizeResponseProto>(NULL);
  }

  DoFinalizeResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoFinalizeResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoFinalizeResponseProto& from);
  void MergeFrom(const DoFinalizeResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoFinalizeResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoFinalizeResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CanRollBackRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.CanRollBackRequestProto) */ {
 public:
  CanRollBackRequestProto();
  virtual ~CanRollBackRequestProto();

  CanRollBackRequestProto(const CanRollBackRequestProto& from);

  inline CanRollBackRequestProto& operator=(const CanRollBackRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CanRollBackRequestProto(CanRollBackRequestProto&& from) noexcept
    : CanRollBackRequestProto() {
    *this = ::std::move(from);
  }

  inline CanRollBackRequestProto& operator=(CanRollBackRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CanRollBackRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CanRollBackRequestProto* internal_default_instance() {
    return reinterpret_cast<const CanRollBackRequestProto*>(
               &_CanRollBackRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(CanRollBackRequestProto* other);
  friend void swap(CanRollBackRequestProto& a, CanRollBackRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CanRollBackRequestProto* New() const final {
    return CreateMaybeMessage<CanRollBackRequestProto>(NULL);
  }

  CanRollBackRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CanRollBackRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CanRollBackRequestProto& from);
  void MergeFrom(const CanRollBackRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanRollBackRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 5;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 5;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // required .hadoop.hdfs.StorageInfoProto storage = 2;
  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 2;
  private:
  const ::hadoop::hdfs::StorageInfoProto& _internal_storage() const;
  public:
  const ::hadoop::hdfs::StorageInfoProto& storage() const;
  ::hadoop::hdfs::StorageInfoProto* release_storage();
  ::hadoop::hdfs::StorageInfoProto* mutable_storage();
  void set_allocated_storage(::hadoop::hdfs::StorageInfoProto* storage);

  // required .hadoop.hdfs.StorageInfoProto prevStorage = 3;
  bool has_prevstorage() const;
  void clear_prevstorage();
  static const int kPrevStorageFieldNumber = 3;
  private:
  const ::hadoop::hdfs::StorageInfoProto& _internal_prevstorage() const;
  public:
  const ::hadoop::hdfs::StorageInfoProto& prevstorage() const;
  ::hadoop::hdfs::StorageInfoProto* release_prevstorage();
  ::hadoop::hdfs::StorageInfoProto* mutable_prevstorage();
  void set_allocated_prevstorage(::hadoop::hdfs::StorageInfoProto* prevstorage);

  // required int32 targetLayoutVersion = 4;
  bool has_targetlayoutversion() const;
  void clear_targetlayoutversion();
  static const int kTargetLayoutVersionFieldNumber = 4;
  ::google::protobuf::int32 targetlayoutversion() const;
  void set_targetlayoutversion(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.CanRollBackRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_storage();
  void clear_has_storage();
  void set_has_prevstorage();
  void clear_has_prevstorage();
  void set_has_targetlayoutversion();
  void clear_has_targetlayoutversion();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  ::hadoop::hdfs::StorageInfoProto* storage_;
  ::hadoop::hdfs::StorageInfoProto* prevstorage_;
  ::google::protobuf::int32 targetlayoutversion_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CanRollBackResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.CanRollBackResponseProto) */ {
 public:
  CanRollBackResponseProto();
  virtual ~CanRollBackResponseProto();

  CanRollBackResponseProto(const CanRollBackResponseProto& from);

  inline CanRollBackResponseProto& operator=(const CanRollBackResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CanRollBackResponseProto(CanRollBackResponseProto&& from) noexcept
    : CanRollBackResponseProto() {
    *this = ::std::move(from);
  }

  inline CanRollBackResponseProto& operator=(CanRollBackResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CanRollBackResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CanRollBackResponseProto* internal_default_instance() {
    return reinterpret_cast<const CanRollBackResponseProto*>(
               &_CanRollBackResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CanRollBackResponseProto* other);
  friend void swap(CanRollBackResponseProto& a, CanRollBackResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CanRollBackResponseProto* New() const final {
    return CreateMaybeMessage<CanRollBackResponseProto>(NULL);
  }

  CanRollBackResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CanRollBackResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CanRollBackResponseProto& from);
  void MergeFrom(const CanRollBackResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanRollBackResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool canRollBack = 1;
  bool has_canrollback() const;
  void clear_canrollback();
  static const int kCanRollBackFieldNumber = 1;
  bool canrollback() const;
  void set_canrollback(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.CanRollBackResponseProto)
 private:
  void set_has_canrollback();
  void clear_has_canrollback();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool canrollback_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoRollbackRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoRollbackRequestProto) */ {
 public:
  DoRollbackRequestProto();
  virtual ~DoRollbackRequestProto();

  DoRollbackRequestProto(const DoRollbackRequestProto& from);

  inline DoRollbackRequestProto& operator=(const DoRollbackRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoRollbackRequestProto(DoRollbackRequestProto&& from) noexcept
    : DoRollbackRequestProto() {
    *this = ::std::move(from);
  }

  inline DoRollbackRequestProto& operator=(DoRollbackRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoRollbackRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoRollbackRequestProto* internal_default_instance() {
    return reinterpret_cast<const DoRollbackRequestProto*>(
               &_DoRollbackRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(DoRollbackRequestProto* other);
  friend void swap(DoRollbackRequestProto& a, DoRollbackRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoRollbackRequestProto* New() const final {
    return CreateMaybeMessage<DoRollbackRequestProto>(NULL);
  }

  DoRollbackRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoRollbackRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoRollbackRequestProto& from);
  void MergeFrom(const DoRollbackRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoRollbackRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameserviceId = 2;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameserviceIdFieldNumber = 2;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoRollbackRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoRollbackResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DoRollbackResponseProto) */ {
 public:
  DoRollbackResponseProto();
  virtual ~DoRollbackResponseProto();

  DoRollbackResponseProto(const DoRollbackResponseProto& from);

  inline DoRollbackResponseProto& operator=(const DoRollbackResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoRollbackResponseProto(DoRollbackResponseProto&& from) noexcept
    : DoRollbackResponseProto() {
    *this = ::std::move(from);
  }

  inline DoRollbackResponseProto& operator=(DoRollbackResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoRollbackResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoRollbackResponseProto* internal_default_instance() {
    return reinterpret_cast<const DoRollbackResponseProto*>(
               &_DoRollbackResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(DoRollbackResponseProto* other);
  friend void swap(DoRollbackResponseProto& a, DoRollbackResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoRollbackResponseProto* New() const final {
    return CreateMaybeMessage<DoRollbackResponseProto>(NULL);
  }

  DoRollbackResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoRollbackResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoRollbackResponseProto& from);
  void MergeFrom(const DoRollbackResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoRollbackResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DoRollbackResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiscardSegmentsRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto) */ {
 public:
  DiscardSegmentsRequestProto();
  virtual ~DiscardSegmentsRequestProto();

  DiscardSegmentsRequestProto(const DiscardSegmentsRequestProto& from);

  inline DiscardSegmentsRequestProto& operator=(const DiscardSegmentsRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscardSegmentsRequestProto(DiscardSegmentsRequestProto&& from) noexcept
    : DiscardSegmentsRequestProto() {
    *this = ::std::move(from);
  }

  inline DiscardSegmentsRequestProto& operator=(DiscardSegmentsRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscardSegmentsRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscardSegmentsRequestProto* internal_default_instance() {
    return reinterpret_cast<const DiscardSegmentsRequestProto*>(
               &_DiscardSegmentsRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(DiscardSegmentsRequestProto* other);
  friend void swap(DiscardSegmentsRequestProto& a, DiscardSegmentsRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscardSegmentsRequestProto* New() const final {
    return CreateMaybeMessage<DiscardSegmentsRequestProto>(NULL);
  }

  DiscardSegmentsRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscardSegmentsRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscardSegmentsRequestProto& from);
  void MergeFrom(const DiscardSegmentsRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscardSegmentsRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 3;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 3;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // required uint64 startTxId = 2;
  bool has_starttxid() const;
  void clear_starttxid();
  static const int kStartTxIdFieldNumber = 2;
  ::google::protobuf::uint64 starttxid() const;
  void set_starttxid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_starttxid();
  void clear_has_starttxid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  ::google::protobuf::uint64 starttxid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiscardSegmentsResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.DiscardSegmentsResponseProto) */ {
 public:
  DiscardSegmentsResponseProto();
  virtual ~DiscardSegmentsResponseProto();

  DiscardSegmentsResponseProto(const DiscardSegmentsResponseProto& from);

  inline DiscardSegmentsResponseProto& operator=(const DiscardSegmentsResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscardSegmentsResponseProto(DiscardSegmentsResponseProto&& from) noexcept
    : DiscardSegmentsResponseProto() {
    *this = ::std::move(from);
  }

  inline DiscardSegmentsResponseProto& operator=(DiscardSegmentsResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscardSegmentsResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscardSegmentsResponseProto* internal_default_instance() {
    return reinterpret_cast<const DiscardSegmentsResponseProto*>(
               &_DiscardSegmentsResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(DiscardSegmentsResponseProto* other);
  friend void swap(DiscardSegmentsResponseProto& a, DiscardSegmentsResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscardSegmentsResponseProto* New() const final {
    return CreateMaybeMessage<DiscardSegmentsResponseProto>(NULL);
  }

  DiscardSegmentsResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscardSegmentsResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscardSegmentsResponseProto& from);
  void MergeFrom(const DiscardSegmentsResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscardSegmentsResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.DiscardSegmentsResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetJournalStateRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetJournalStateRequestProto) */ {
 public:
  GetJournalStateRequestProto();
  virtual ~GetJournalStateRequestProto();

  GetJournalStateRequestProto(const GetJournalStateRequestProto& from);

  inline GetJournalStateRequestProto& operator=(const GetJournalStateRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetJournalStateRequestProto(GetJournalStateRequestProto&& from) noexcept
    : GetJournalStateRequestProto() {
    *this = ::std::move(from);
  }

  inline GetJournalStateRequestProto& operator=(GetJournalStateRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJournalStateRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJournalStateRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetJournalStateRequestProto*>(
               &_GetJournalStateRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(GetJournalStateRequestProto* other);
  friend void swap(GetJournalStateRequestProto& a, GetJournalStateRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetJournalStateRequestProto* New() const final {
    return CreateMaybeMessage<GetJournalStateRequestProto>(NULL);
  }

  GetJournalStateRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetJournalStateRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetJournalStateRequestProto& from);
  void MergeFrom(const GetJournalStateRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJournalStateRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 2;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 2;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetJournalStateRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetJournalStateResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetJournalStateResponseProto) */ {
 public:
  GetJournalStateResponseProto();
  virtual ~GetJournalStateResponseProto();

  GetJournalStateResponseProto(const GetJournalStateResponseProto& from);

  inline GetJournalStateResponseProto& operator=(const GetJournalStateResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetJournalStateResponseProto(GetJournalStateResponseProto&& from) noexcept
    : GetJournalStateResponseProto() {
    *this = ::std::move(from);
  }

  inline GetJournalStateResponseProto& operator=(GetJournalStateResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJournalStateResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJournalStateResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetJournalStateResponseProto*>(
               &_GetJournalStateResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(GetJournalStateResponseProto* other);
  friend void swap(GetJournalStateResponseProto& a, GetJournalStateResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetJournalStateResponseProto* New() const final {
    return CreateMaybeMessage<GetJournalStateResponseProto>(NULL);
  }

  GetJournalStateResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetJournalStateResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetJournalStateResponseProto& from);
  void MergeFrom(const GetJournalStateResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJournalStateResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fromURL = 3;
  bool has_fromurl() const;
  void clear_fromurl();
  static const int kFromURLFieldNumber = 3;
  const ::std::string& fromurl() const;
  void set_fromurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fromurl(::std::string&& value);
  #endif
  void set_fromurl(const char* value);
  void set_fromurl(const char* value, size_t size);
  ::std::string* mutable_fromurl();
  ::std::string* release_fromurl();
  void set_allocated_fromurl(::std::string* fromurl);

  // required uint64 lastPromisedEpoch = 1;
  bool has_lastpromisedepoch() const;
  void clear_lastpromisedepoch();
  static const int kLastPromisedEpochFieldNumber = 1;
  ::google::protobuf::uint64 lastpromisedepoch() const;
  void set_lastpromisedepoch(::google::protobuf::uint64 value);

  // required uint32 httpPort = 2;
  bool has_httpport() const;
  void clear_httpport();
  static const int kHttpPortFieldNumber = 2;
  ::google::protobuf::uint32 httpport() const;
  void set_httpport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetJournalStateResponseProto)
 private:
  void set_has_lastpromisedepoch();
  void clear_has_lastpromisedepoch();
  void set_has_httpport();
  void clear_has_httpport();
  void set_has_fromurl();
  void clear_has_fromurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fromurl_;
  ::google::protobuf::uint64 lastpromisedepoch_;
  ::google::protobuf::uint32 httpport_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FormatRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.FormatRequestProto) */ {
 public:
  FormatRequestProto();
  virtual ~FormatRequestProto();

  FormatRequestProto(const FormatRequestProto& from);

  inline FormatRequestProto& operator=(const FormatRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FormatRequestProto(FormatRequestProto&& from) noexcept
    : FormatRequestProto() {
    *this = ::std::move(from);
  }

  inline FormatRequestProto& operator=(FormatRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FormatRequestProto* internal_default_instance() {
    return reinterpret_cast<const FormatRequestProto*>(
               &_FormatRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(FormatRequestProto* other);
  friend void swap(FormatRequestProto& a, FormatRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FormatRequestProto* New() const final {
    return CreateMaybeMessage<FormatRequestProto>(NULL);
  }

  FormatRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FormatRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FormatRequestProto& from);
  void MergeFrom(const FormatRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormatRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 3;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 3;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // required .hadoop.hdfs.NamespaceInfoProto nsInfo = 2;
  bool has_nsinfo() const;
  void clear_nsinfo();
  static const int kNsInfoFieldNumber = 2;
  private:
  const ::hadoop::hdfs::NamespaceInfoProto& _internal_nsinfo() const;
  public:
  const ::hadoop::hdfs::NamespaceInfoProto& nsinfo() const;
  ::hadoop::hdfs::NamespaceInfoProto* release_nsinfo();
  ::hadoop::hdfs::NamespaceInfoProto* mutable_nsinfo();
  void set_allocated_nsinfo(::hadoop::hdfs::NamespaceInfoProto* nsinfo);

  // optional bool force = 4 [default = false];
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 4;
  bool force() const;
  void set_force(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.FormatRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_nsinfo();
  void clear_has_nsinfo();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();
  void set_has_force();
  void clear_has_force();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  ::hadoop::hdfs::NamespaceInfoProto* nsinfo_;
  bool force_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FormatResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.FormatResponseProto) */ {
 public:
  FormatResponseProto();
  virtual ~FormatResponseProto();

  FormatResponseProto(const FormatResponseProto& from);

  inline FormatResponseProto& operator=(const FormatResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FormatResponseProto(FormatResponseProto&& from) noexcept
    : FormatResponseProto() {
    *this = ::std::move(from);
  }

  inline FormatResponseProto& operator=(FormatResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FormatResponseProto* internal_default_instance() {
    return reinterpret_cast<const FormatResponseProto*>(
               &_FormatResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(FormatResponseProto* other);
  friend void swap(FormatResponseProto& a, FormatResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FormatResponseProto* New() const final {
    return CreateMaybeMessage<FormatResponseProto>(NULL);
  }

  FormatResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FormatResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FormatResponseProto& from);
  void MergeFrom(const FormatResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormatResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.FormatResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewEpochRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.NewEpochRequestProto) */ {
 public:
  NewEpochRequestProto();
  virtual ~NewEpochRequestProto();

  NewEpochRequestProto(const NewEpochRequestProto& from);

  inline NewEpochRequestProto& operator=(const NewEpochRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewEpochRequestProto(NewEpochRequestProto&& from) noexcept
    : NewEpochRequestProto() {
    *this = ::std::move(from);
  }

  inline NewEpochRequestProto& operator=(NewEpochRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewEpochRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewEpochRequestProto* internal_default_instance() {
    return reinterpret_cast<const NewEpochRequestProto*>(
               &_NewEpochRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(NewEpochRequestProto* other);
  friend void swap(NewEpochRequestProto& a, NewEpochRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewEpochRequestProto* New() const final {
    return CreateMaybeMessage<NewEpochRequestProto>(NULL);
  }

  NewEpochRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewEpochRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewEpochRequestProto& from);
  void MergeFrom(const NewEpochRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewEpochRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 4;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 4;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // required .hadoop.hdfs.NamespaceInfoProto nsInfo = 2;
  bool has_nsinfo() const;
  void clear_nsinfo();
  static const int kNsInfoFieldNumber = 2;
  private:
  const ::hadoop::hdfs::NamespaceInfoProto& _internal_nsinfo() const;
  public:
  const ::hadoop::hdfs::NamespaceInfoProto& nsinfo() const;
  ::hadoop::hdfs::NamespaceInfoProto* release_nsinfo();
  ::hadoop::hdfs::NamespaceInfoProto* mutable_nsinfo();
  void set_allocated_nsinfo(::hadoop::hdfs::NamespaceInfoProto* nsinfo);

  // required uint64 epoch = 3;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 3;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.NewEpochRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_nsinfo();
  void clear_has_nsinfo();
  void set_has_epoch();
  void clear_has_epoch();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  ::hadoop::hdfs::NamespaceInfoProto* nsinfo_;
  ::google::protobuf::uint64 epoch_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewEpochResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.NewEpochResponseProto) */ {
 public:
  NewEpochResponseProto();
  virtual ~NewEpochResponseProto();

  NewEpochResponseProto(const NewEpochResponseProto& from);

  inline NewEpochResponseProto& operator=(const NewEpochResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewEpochResponseProto(NewEpochResponseProto&& from) noexcept
    : NewEpochResponseProto() {
    *this = ::std::move(from);
  }

  inline NewEpochResponseProto& operator=(NewEpochResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewEpochResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewEpochResponseProto* internal_default_instance() {
    return reinterpret_cast<const NewEpochResponseProto*>(
               &_NewEpochResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(NewEpochResponseProto* other);
  friend void swap(NewEpochResponseProto& a, NewEpochResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewEpochResponseProto* New() const final {
    return CreateMaybeMessage<NewEpochResponseProto>(NULL);
  }

  NewEpochResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewEpochResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewEpochResponseProto& from);
  void MergeFrom(const NewEpochResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewEpochResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 lastSegmentTxId = 1;
  bool has_lastsegmenttxid() const;
  void clear_lastsegmenttxid();
  static const int kLastSegmentTxIdFieldNumber = 1;
  ::google::protobuf::uint64 lastsegmenttxid() const;
  void set_lastsegmenttxid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.NewEpochResponseProto)
 private:
  void set_has_lastsegmenttxid();
  void clear_has_lastsegmenttxid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 lastsegmenttxid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEditLogManifestRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto) */ {
 public:
  GetEditLogManifestRequestProto();
  virtual ~GetEditLogManifestRequestProto();

  GetEditLogManifestRequestProto(const GetEditLogManifestRequestProto& from);

  inline GetEditLogManifestRequestProto& operator=(const GetEditLogManifestRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetEditLogManifestRequestProto(GetEditLogManifestRequestProto&& from) noexcept
    : GetEditLogManifestRequestProto() {
    *this = ::std::move(from);
  }

  inline GetEditLogManifestRequestProto& operator=(GetEditLogManifestRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEditLogManifestRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEditLogManifestRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetEditLogManifestRequestProto*>(
               &_GetEditLogManifestRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(GetEditLogManifestRequestProto* other);
  friend void swap(GetEditLogManifestRequestProto& a, GetEditLogManifestRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEditLogManifestRequestProto* New() const final {
    return CreateMaybeMessage<GetEditLogManifestRequestProto>(NULL);
  }

  GetEditLogManifestRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetEditLogManifestRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetEditLogManifestRequestProto& from);
  void MergeFrom(const GetEditLogManifestRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEditLogManifestRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 5;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 5;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // required uint64 sinceTxId = 2;
  bool has_sincetxid() const;
  void clear_sincetxid();
  static const int kSinceTxIdFieldNumber = 2;
  ::google::protobuf::uint64 sincetxid() const;
  void set_sincetxid(::google::protobuf::uint64 value);

  // optional bool inProgressOk = 4 [default = false];
  bool has_inprogressok() const;
  void clear_inprogressok();
  static const int kInProgressOkFieldNumber = 4;
  bool inprogressok() const;
  void set_inprogressok(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_sincetxid();
  void clear_has_sincetxid();
  void set_has_inprogressok();
  void clear_has_inprogressok();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  ::google::protobuf::uint64 sincetxid_;
  bool inprogressok_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEditLogManifestResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto) */ {
 public:
  GetEditLogManifestResponseProto();
  virtual ~GetEditLogManifestResponseProto();

  GetEditLogManifestResponseProto(const GetEditLogManifestResponseProto& from);

  inline GetEditLogManifestResponseProto& operator=(const GetEditLogManifestResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetEditLogManifestResponseProto(GetEditLogManifestResponseProto&& from) noexcept
    : GetEditLogManifestResponseProto() {
    *this = ::std::move(from);
  }

  inline GetEditLogManifestResponseProto& operator=(GetEditLogManifestResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEditLogManifestResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEditLogManifestResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetEditLogManifestResponseProto*>(
               &_GetEditLogManifestResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(GetEditLogManifestResponseProto* other);
  friend void swap(GetEditLogManifestResponseProto& a, GetEditLogManifestResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEditLogManifestResponseProto* New() const final {
    return CreateMaybeMessage<GetEditLogManifestResponseProto>(NULL);
  }

  GetEditLogManifestResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetEditLogManifestResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetEditLogManifestResponseProto& from);
  void MergeFrom(const GetEditLogManifestResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEditLogManifestResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fromURL = 3;
  bool has_fromurl() const;
  void clear_fromurl();
  static const int kFromURLFieldNumber = 3;
  const ::std::string& fromurl() const;
  void set_fromurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fromurl(::std::string&& value);
  #endif
  void set_fromurl(const char* value);
  void set_fromurl(const char* value, size_t size);
  ::std::string* mutable_fromurl();
  ::std::string* release_fromurl();
  void set_allocated_fromurl(::std::string* fromurl);

  // required .hadoop.hdfs.RemoteEditLogManifestProto manifest = 1;
  bool has_manifest() const;
  void clear_manifest();
  static const int kManifestFieldNumber = 1;
  private:
  const ::hadoop::hdfs::RemoteEditLogManifestProto& _internal_manifest() const;
  public:
  const ::hadoop::hdfs::RemoteEditLogManifestProto& manifest() const;
  ::hadoop::hdfs::RemoteEditLogManifestProto* release_manifest();
  ::hadoop::hdfs::RemoteEditLogManifestProto* mutable_manifest();
  void set_allocated_manifest(::hadoop::hdfs::RemoteEditLogManifestProto* manifest);

  // required uint32 httpPort = 2;
  bool has_httpport() const;
  void clear_httpport();
  static const int kHttpPortFieldNumber = 2;
  ::google::protobuf::uint32 httpport() const;
  void set_httpport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto)
 private:
  void set_has_manifest();
  void clear_has_manifest();
  void set_has_httpport();
  void clear_has_httpport();
  void set_has_fromurl();
  void clear_has_fromurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fromurl_;
  ::hadoop::hdfs::RemoteEditLogManifestProto* manifest_;
  ::google::protobuf::uint32 httpport_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetJournaledEditsRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto) */ {
 public:
  GetJournaledEditsRequestProto();
  virtual ~GetJournaledEditsRequestProto();

  GetJournaledEditsRequestProto(const GetJournaledEditsRequestProto& from);

  inline GetJournaledEditsRequestProto& operator=(const GetJournaledEditsRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetJournaledEditsRequestProto(GetJournaledEditsRequestProto&& from) noexcept
    : GetJournaledEditsRequestProto() {
    *this = ::std::move(from);
  }

  inline GetJournaledEditsRequestProto& operator=(GetJournaledEditsRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJournaledEditsRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJournaledEditsRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetJournaledEditsRequestProto*>(
               &_GetJournaledEditsRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(GetJournaledEditsRequestProto* other);
  friend void swap(GetJournaledEditsRequestProto& a, GetJournaledEditsRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetJournaledEditsRequestProto* New() const final {
    return CreateMaybeMessage<GetJournaledEditsRequestProto>(NULL);
  }

  GetJournaledEditsRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetJournaledEditsRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetJournaledEditsRequestProto& from);
  void MergeFrom(const GetJournaledEditsRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJournaledEditsRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nameServiceId = 4;
  bool has_nameserviceid() const;
  void clear_nameserviceid();
  static const int kNameServiceIdFieldNumber = 4;
  const ::std::string& nameserviceid() const;
  void set_nameserviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_nameserviceid(::std::string&& value);
  #endif
  void set_nameserviceid(const char* value);
  void set_nameserviceid(const char* value, size_t size);
  ::std::string* mutable_nameserviceid();
  ::std::string* release_nameserviceid();
  void set_allocated_nameserviceid(::std::string* nameserviceid);

  // required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::JournalIdProto& _internal_jid() const;
  public:
  const ::hadoop::hdfs::qjournal::JournalIdProto& jid() const;
  ::hadoop::hdfs::qjournal::JournalIdProto* release_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* mutable_jid();
  void set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid);

  // required uint64 sinceTxId = 2;
  bool has_sincetxid() const;
  void clear_sincetxid();
  static const int kSinceTxIdFieldNumber = 2;
  ::google::protobuf::uint64 sincetxid() const;
  void set_sincetxid(::google::protobuf::uint64 value);

  // required uint32 maxTxns = 3;
  bool has_maxtxns() const;
  void clear_maxtxns();
  static const int kMaxTxnsFieldNumber = 3;
  ::google::protobuf::uint32 maxtxns() const;
  void set_maxtxns(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto)
 private:
  void set_has_jid();
  void clear_has_jid();
  void set_has_sincetxid();
  void clear_has_sincetxid();
  void set_has_maxtxns();
  void clear_has_maxtxns();
  void set_has_nameserviceid();
  void clear_has_nameserviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nameserviceid_;
  ::hadoop::hdfs::qjournal::JournalIdProto* jid_;
  ::google::protobuf::uint64 sincetxid_;
  ::google::protobuf::uint32 maxtxns_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetJournaledEditsResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto) */ {
 public:
  GetJournaledEditsResponseProto();
  virtual ~GetJournaledEditsResponseProto();

  GetJournaledEditsResponseProto(const GetJournaledEditsResponseProto& from);

  inline GetJournaledEditsResponseProto& operator=(const GetJournaledEditsResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetJournaledEditsResponseProto(GetJournaledEditsResponseProto&& from) noexcept
    : GetJournaledEditsResponseProto() {
    *this = ::std::move(from);
  }

  inline GetJournaledEditsResponseProto& operator=(GetJournaledEditsResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJournaledEditsResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJournaledEditsResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetJournaledEditsResponseProto*>(
               &_GetJournaledEditsResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(GetJournaledEditsResponseProto* other);
  friend void swap(GetJournaledEditsResponseProto& a, GetJournaledEditsResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetJournaledEditsResponseProto* New() const final {
    return CreateMaybeMessage<GetJournaledEditsResponseProto>(NULL);
  }

  GetJournaledEditsResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetJournaledEditsResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetJournaledEditsResponseProto& from);
  void MergeFrom(const GetJournaledEditsResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJournaledEditsResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes editLog = 2;
  bool has_editlog() const;
  void clear_editlog();
  static const int kEditLogFieldNumber = 2;
  const ::std::string& editlog() const;
  void set_editlog(const ::std::string& value);
  #if LANG_CXX11
  void set_editlog(::std::string&& value);
  #endif
  void set_editlog(const char* value);
  void set_editlog(const void* value, size_t size);
  ::std::string* mutable_editlog();
  ::std::string* release_editlog();
  void set_allocated_editlog(::std::string* editlog);

  // required uint32 txnCount = 1;
  bool has_txncount() const;
  void clear_txncount();
  static const int kTxnCountFieldNumber = 1;
  ::google::protobuf::uint32 txncount() const;
  void set_txncount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto)
 private:
  void set_has_txncount();
  void clear_has_txncount();
  void set_has_editlog();
  void clear_has_editlog();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr editlog_;
  ::google::protobuf::uint32 txncount_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrepareRecoveryRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto) */ {
 public:
  PrepareRecoveryRequestProto();
  virtual ~PrepareRecoveryRequestProto();

  PrepareRecoveryRequestProto(const PrepareRecoveryRequestProto& from);

  inline PrepareRecoveryRequestProto& operator=(const PrepareRecoveryRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrepareRecoveryRequestProto(PrepareRecoveryRequestProto&& from) noexcept
    : PrepareRecoveryRequestProto() {
    *this = ::std::move(from);
  }

  inline PrepareRecoveryRequestProto& operator=(PrepareRecoveryRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareRecoveryRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrepareRecoveryRequestProto* internal_default_instance() {
    return reinterpret_cast<const PrepareRecoveryRequestProto*>(
               &_PrepareRecoveryRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(PrepareRecoveryRequestProto* other);
  friend void swap(PrepareRecoveryRequestProto& a, PrepareRecoveryRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrepareRecoveryRequestProto* New() const final {
    return CreateMaybeMessage<PrepareRecoveryRequestProto>(NULL);
  }

  PrepareRecoveryRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PrepareRecoveryRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PrepareRecoveryRequestProto& from);
  void MergeFrom(const PrepareRecoveryRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareRecoveryRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
  bool has_reqinfo() const;
  void clear_reqinfo();
  static const int kReqInfoFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& _internal_reqinfo() const;
  public:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& reqinfo() const;
  ::hadoop::hdfs::qjournal::RequestInfoProto* release_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* mutable_reqinfo();
  void set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo);

  // required uint64 segmentTxId = 2;
  bool has_segmenttxid() const;
  void clear_segmenttxid();
  static const int kSegmentTxIdFieldNumber = 2;
  ::google::protobuf::uint64 segmenttxid() const;
  void set_segmenttxid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto)
 private:
  void set_has_reqinfo();
  void clear_has_reqinfo();
  void set_has_segmenttxid();
  void clear_has_segmenttxid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo_;
  ::google::protobuf::uint64 segmenttxid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrepareRecoveryResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto) */ {
 public:
  PrepareRecoveryResponseProto();
  virtual ~PrepareRecoveryResponseProto();

  PrepareRecoveryResponseProto(const PrepareRecoveryResponseProto& from);

  inline PrepareRecoveryResponseProto& operator=(const PrepareRecoveryResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrepareRecoveryResponseProto(PrepareRecoveryResponseProto&& from) noexcept
    : PrepareRecoveryResponseProto() {
    *this = ::std::move(from);
  }

  inline PrepareRecoveryResponseProto& operator=(PrepareRecoveryResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareRecoveryResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrepareRecoveryResponseProto* internal_default_instance() {
    return reinterpret_cast<const PrepareRecoveryResponseProto*>(
               &_PrepareRecoveryResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(PrepareRecoveryResponseProto* other);
  friend void swap(PrepareRecoveryResponseProto& a, PrepareRecoveryResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrepareRecoveryResponseProto* New() const final {
    return CreateMaybeMessage<PrepareRecoveryResponseProto>(NULL);
  }

  PrepareRecoveryResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PrepareRecoveryResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PrepareRecoveryResponseProto& from);
  void MergeFrom(const PrepareRecoveryResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareRecoveryResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hadoop.hdfs.qjournal.SegmentStateProto segmentState = 1;
  bool has_segmentstate() const;
  void clear_segmentstate();
  static const int kSegmentStateFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::SegmentStateProto& _internal_segmentstate() const;
  public:
  const ::hadoop::hdfs::qjournal::SegmentStateProto& segmentstate() const;
  ::hadoop::hdfs::qjournal::SegmentStateProto* release_segmentstate();
  ::hadoop::hdfs::qjournal::SegmentStateProto* mutable_segmentstate();
  void set_allocated_segmentstate(::hadoop::hdfs::qjournal::SegmentStateProto* segmentstate);

  // optional uint64 acceptedInEpoch = 2;
  bool has_acceptedinepoch() const;
  void clear_acceptedinepoch();
  static const int kAcceptedInEpochFieldNumber = 2;
  ::google::protobuf::uint64 acceptedinepoch() const;
  void set_acceptedinepoch(::google::protobuf::uint64 value);

  // required uint64 lastWriterEpoch = 3;
  bool has_lastwriterepoch() const;
  void clear_lastwriterepoch();
  static const int kLastWriterEpochFieldNumber = 3;
  ::google::protobuf::uint64 lastwriterepoch() const;
  void set_lastwriterepoch(::google::protobuf::uint64 value);

  // optional uint64 lastCommittedTxId = 4;
  bool has_lastcommittedtxid() const;
  void clear_lastcommittedtxid();
  static const int kLastCommittedTxIdFieldNumber = 4;
  ::google::protobuf::uint64 lastcommittedtxid() const;
  void set_lastcommittedtxid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto)
 private:
  void set_has_segmentstate();
  void clear_has_segmentstate();
  void set_has_acceptedinepoch();
  void clear_has_acceptedinepoch();
  void set_has_lastwriterepoch();
  void clear_has_lastwriterepoch();
  void set_has_lastcommittedtxid();
  void clear_has_lastcommittedtxid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hadoop::hdfs::qjournal::SegmentStateProto* segmentstate_;
  ::google::protobuf::uint64 acceptedinepoch_;
  ::google::protobuf::uint64 lastwriterepoch_;
  ::google::protobuf::uint64 lastcommittedtxid_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AcceptRecoveryRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto) */ {
 public:
  AcceptRecoveryRequestProto();
  virtual ~AcceptRecoveryRequestProto();

  AcceptRecoveryRequestProto(const AcceptRecoveryRequestProto& from);

  inline AcceptRecoveryRequestProto& operator=(const AcceptRecoveryRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AcceptRecoveryRequestProto(AcceptRecoveryRequestProto&& from) noexcept
    : AcceptRecoveryRequestProto() {
    *this = ::std::move(from);
  }

  inline AcceptRecoveryRequestProto& operator=(AcceptRecoveryRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptRecoveryRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcceptRecoveryRequestProto* internal_default_instance() {
    return reinterpret_cast<const AcceptRecoveryRequestProto*>(
               &_AcceptRecoveryRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(AcceptRecoveryRequestProto* other);
  friend void swap(AcceptRecoveryRequestProto& a, AcceptRecoveryRequestProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AcceptRecoveryRequestProto* New() const final {
    return CreateMaybeMessage<AcceptRecoveryRequestProto>(NULL);
  }

  AcceptRecoveryRequestProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AcceptRecoveryRequestProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AcceptRecoveryRequestProto& from);
  void MergeFrom(const AcceptRecoveryRequestProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceptRecoveryRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fromURL = 3;
  bool has_fromurl() const;
  void clear_fromurl();
  static const int kFromURLFieldNumber = 3;
  const ::std::string& fromurl() const;
  void set_fromurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fromurl(::std::string&& value);
  #endif
  void set_fromurl(const char* value);
  void set_fromurl(const char* value, size_t size);
  ::std::string* mutable_fromurl();
  ::std::string* release_fromurl();
  void set_allocated_fromurl(::std::string* fromurl);

  // required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
  bool has_reqinfo() const;
  void clear_reqinfo();
  static const int kReqInfoFieldNumber = 1;
  private:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& _internal_reqinfo() const;
  public:
  const ::hadoop::hdfs::qjournal::RequestInfoProto& reqinfo() const;
  ::hadoop::hdfs::qjournal::RequestInfoProto* release_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* mutable_reqinfo();
  void set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo);

  // required .hadoop.hdfs.qjournal.SegmentStateProto stateToAccept = 2;
  bool has_statetoaccept() const;
  void clear_statetoaccept();
  static const int kStateToAcceptFieldNumber = 2;
  private:
  const ::hadoop::hdfs::qjournal::SegmentStateProto& _internal_statetoaccept() const;
  public:
  const ::hadoop::hdfs::qjournal::SegmentStateProto& statetoaccept() const;
  ::hadoop::hdfs::qjournal::SegmentStateProto* release_statetoaccept();
  ::hadoop::hdfs::qjournal::SegmentStateProto* mutable_statetoaccept();
  void set_allocated_statetoaccept(::hadoop::hdfs::qjournal::SegmentStateProto* statetoaccept);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto)
 private:
  void set_has_reqinfo();
  void clear_has_reqinfo();
  void set_has_statetoaccept();
  void clear_has_statetoaccept();
  void set_has_fromurl();
  void clear_has_fromurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fromurl_;
  ::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo_;
  ::hadoop::hdfs::qjournal::SegmentStateProto* statetoaccept_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AcceptRecoveryResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.qjournal.AcceptRecoveryResponseProto) */ {
 public:
  AcceptRecoveryResponseProto();
  virtual ~AcceptRecoveryResponseProto();

  AcceptRecoveryResponseProto(const AcceptRecoveryResponseProto& from);

  inline AcceptRecoveryResponseProto& operator=(const AcceptRecoveryResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AcceptRecoveryResponseProto(AcceptRecoveryResponseProto&& from) noexcept
    : AcceptRecoveryResponseProto() {
    *this = ::std::move(from);
  }

  inline AcceptRecoveryResponseProto& operator=(AcceptRecoveryResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptRecoveryResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcceptRecoveryResponseProto* internal_default_instance() {
    return reinterpret_cast<const AcceptRecoveryResponseProto*>(
               &_AcceptRecoveryResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(AcceptRecoveryResponseProto* other);
  friend void swap(AcceptRecoveryResponseProto& a, AcceptRecoveryResponseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AcceptRecoveryResponseProto* New() const final {
    return CreateMaybeMessage<AcceptRecoveryResponseProto>(NULL);
  }

  AcceptRecoveryResponseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AcceptRecoveryResponseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AcceptRecoveryResponseProto& from);
  void MergeFrom(const AcceptRecoveryResponseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceptRecoveryResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.qjournal.AcceptRecoveryResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QJournalProtocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JournalIdProto

// required string identifier = 1;
inline bool JournalIdProto::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JournalIdProto::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JournalIdProto::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JournalIdProto::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier();
}
inline const ::std::string& JournalIdProto::identifier() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.JournalIdProto.identifier)
  return identifier_.GetNoArena();
}
inline void JournalIdProto::set_identifier(const ::std::string& value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.JournalIdProto.identifier)
}
#if LANG_CXX11
inline void JournalIdProto::set_identifier(::std::string&& value) {
  set_has_identifier();
  identifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.JournalIdProto.identifier)
}
#endif
inline void JournalIdProto::set_identifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.JournalIdProto.identifier)
}
inline void JournalIdProto::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.JournalIdProto.identifier)
}
inline ::std::string* JournalIdProto::mutable_identifier() {
  set_has_identifier();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.JournalIdProto.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JournalIdProto::release_identifier() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.JournalIdProto.identifier)
  if (!has_identifier()) {
    return NULL;
  }
  clear_has_identifier();
  return identifier_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JournalIdProto::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.JournalIdProto.identifier)
}

// -------------------------------------------------------------------

// RequestInfoProto

// required .hadoop.hdfs.qjournal.JournalIdProto journalId = 1;
inline bool RequestInfoProto::has_journalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestInfoProto::set_has_journalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestInfoProto::clear_has_journalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestInfoProto::clear_journalid() {
  if (journalid_ != NULL) journalid_->Clear();
  clear_has_journalid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& RequestInfoProto::_internal_journalid() const {
  return *journalid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& RequestInfoProto::journalid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = journalid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.RequestInfoProto.journalId)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* RequestInfoProto::release_journalid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.RequestInfoProto.journalId)
  clear_has_journalid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = journalid_;
  journalid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* RequestInfoProto::mutable_journalid() {
  set_has_journalid();
  if (journalid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    journalid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.RequestInfoProto.journalId)
  return journalid_;
}
inline void RequestInfoProto::set_allocated_journalid(::hadoop::hdfs::qjournal::JournalIdProto* journalid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete journalid_;
  }
  if (journalid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      journalid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, journalid, submessage_arena);
    }
    set_has_journalid();
  } else {
    clear_has_journalid();
  }
  journalid_ = journalid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.RequestInfoProto.journalId)
}

// required uint64 epoch = 2;
inline bool RequestInfoProto::has_epoch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestInfoProto::set_has_epoch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestInfoProto::clear_has_epoch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestInfoProto::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
  clear_has_epoch();
}
inline ::google::protobuf::uint64 RequestInfoProto::epoch() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.RequestInfoProto.epoch)
  return epoch_;
}
inline void RequestInfoProto::set_epoch(::google::protobuf::uint64 value) {
  set_has_epoch();
  epoch_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.RequestInfoProto.epoch)
}

// required uint64 ipcSerialNumber = 3;
inline bool RequestInfoProto::has_ipcserialnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestInfoProto::set_has_ipcserialnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestInfoProto::clear_has_ipcserialnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestInfoProto::clear_ipcserialnumber() {
  ipcserialnumber_ = GOOGLE_ULONGLONG(0);
  clear_has_ipcserialnumber();
}
inline ::google::protobuf::uint64 RequestInfoProto::ipcserialnumber() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.RequestInfoProto.ipcSerialNumber)
  return ipcserialnumber_;
}
inline void RequestInfoProto::set_ipcserialnumber(::google::protobuf::uint64 value) {
  set_has_ipcserialnumber();
  ipcserialnumber_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.RequestInfoProto.ipcSerialNumber)
}

// optional uint64 committedTxId = 4;
inline bool RequestInfoProto::has_committedtxid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestInfoProto::set_has_committedtxid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestInfoProto::clear_has_committedtxid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestInfoProto::clear_committedtxid() {
  committedtxid_ = GOOGLE_ULONGLONG(0);
  clear_has_committedtxid();
}
inline ::google::protobuf::uint64 RequestInfoProto::committedtxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.RequestInfoProto.committedTxId)
  return committedtxid_;
}
inline void RequestInfoProto::set_committedtxid(::google::protobuf::uint64 value) {
  set_has_committedtxid();
  committedtxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.RequestInfoProto.committedTxId)
}

// optional string nameServiceId = 5;
inline bool RequestInfoProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestInfoProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestInfoProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestInfoProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& RequestInfoProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void RequestInfoProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
}
#if LANG_CXX11
inline void RequestInfoProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
}
#endif
inline void RequestInfoProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
}
inline void RequestInfoProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
}
inline ::std::string* RequestInfoProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInfoProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInfoProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.RequestInfoProto.nameServiceId)
}

// -------------------------------------------------------------------

// SegmentStateProto

// required uint64 startTxId = 1;
inline bool SegmentStateProto::has_starttxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentStateProto::set_has_starttxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentStateProto::clear_has_starttxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentStateProto::clear_starttxid() {
  starttxid_ = GOOGLE_ULONGLONG(0);
  clear_has_starttxid();
}
inline ::google::protobuf::uint64 SegmentStateProto::starttxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.SegmentStateProto.startTxId)
  return starttxid_;
}
inline void SegmentStateProto::set_starttxid(::google::protobuf::uint64 value) {
  set_has_starttxid();
  starttxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.SegmentStateProto.startTxId)
}

// required uint64 endTxId = 2;
inline bool SegmentStateProto::has_endtxid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentStateProto::set_has_endtxid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentStateProto::clear_has_endtxid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentStateProto::clear_endtxid() {
  endtxid_ = GOOGLE_ULONGLONG(0);
  clear_has_endtxid();
}
inline ::google::protobuf::uint64 SegmentStateProto::endtxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.SegmentStateProto.endTxId)
  return endtxid_;
}
inline void SegmentStateProto::set_endtxid(::google::protobuf::uint64 value) {
  set_has_endtxid();
  endtxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.SegmentStateProto.endTxId)
}

// required bool isInProgress = 3;
inline bool SegmentStateProto::has_isinprogress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SegmentStateProto::set_has_isinprogress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SegmentStateProto::clear_has_isinprogress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SegmentStateProto::clear_isinprogress() {
  isinprogress_ = false;
  clear_has_isinprogress();
}
inline bool SegmentStateProto::isinprogress() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.SegmentStateProto.isInProgress)
  return isinprogress_;
}
inline void SegmentStateProto::set_isinprogress(bool value) {
  set_has_isinprogress();
  isinprogress_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.SegmentStateProto.isInProgress)
}

// -------------------------------------------------------------------

// PersistedRecoveryPaxosData

// required .hadoop.hdfs.qjournal.SegmentStateProto segmentState = 1;
inline bool PersistedRecoveryPaxosData::has_segmentstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PersistedRecoveryPaxosData::set_has_segmentstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PersistedRecoveryPaxosData::clear_has_segmentstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PersistedRecoveryPaxosData::clear_segmentstate() {
  if (segmentstate_ != NULL) segmentstate_->Clear();
  clear_has_segmentstate();
}
inline const ::hadoop::hdfs::qjournal::SegmentStateProto& PersistedRecoveryPaxosData::_internal_segmentstate() const {
  return *segmentstate_;
}
inline const ::hadoop::hdfs::qjournal::SegmentStateProto& PersistedRecoveryPaxosData::segmentstate() const {
  const ::hadoop::hdfs::qjournal::SegmentStateProto* p = segmentstate_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData.segmentState)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::SegmentStateProto*>(
      &::hadoop::hdfs::qjournal::_SegmentStateProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::SegmentStateProto* PersistedRecoveryPaxosData::release_segmentstate() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData.segmentState)
  clear_has_segmentstate();
  ::hadoop::hdfs::qjournal::SegmentStateProto* temp = segmentstate_;
  segmentstate_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::SegmentStateProto* PersistedRecoveryPaxosData::mutable_segmentstate() {
  set_has_segmentstate();
  if (segmentstate_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::SegmentStateProto>(GetArenaNoVirtual());
    segmentstate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData.segmentState)
  return segmentstate_;
}
inline void PersistedRecoveryPaxosData::set_allocated_segmentstate(::hadoop::hdfs::qjournal::SegmentStateProto* segmentstate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete segmentstate_;
  }
  if (segmentstate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      segmentstate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, segmentstate, submessage_arena);
    }
    set_has_segmentstate();
  } else {
    clear_has_segmentstate();
  }
  segmentstate_ = segmentstate;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData.segmentState)
}

// required uint64 acceptedInEpoch = 2;
inline bool PersistedRecoveryPaxosData::has_acceptedinepoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PersistedRecoveryPaxosData::set_has_acceptedinepoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PersistedRecoveryPaxosData::clear_has_acceptedinepoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PersistedRecoveryPaxosData::clear_acceptedinepoch() {
  acceptedinepoch_ = GOOGLE_ULONGLONG(0);
  clear_has_acceptedinepoch();
}
inline ::google::protobuf::uint64 PersistedRecoveryPaxosData::acceptedinepoch() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData.acceptedInEpoch)
  return acceptedinepoch_;
}
inline void PersistedRecoveryPaxosData::set_acceptedinepoch(::google::protobuf::uint64 value) {
  set_has_acceptedinepoch();
  acceptedinepoch_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.PersistedRecoveryPaxosData.acceptedInEpoch)
}

// -------------------------------------------------------------------

// JournalRequestProto

// required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
inline bool JournalRequestProto::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JournalRequestProto::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JournalRequestProto::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JournalRequestProto::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->Clear();
  clear_has_reqinfo();
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& JournalRequestProto::_internal_reqinfo() const {
  return *reqinfo_;
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& JournalRequestProto::reqinfo() const {
  const ::hadoop::hdfs::qjournal::RequestInfoProto* p = reqinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.JournalRequestProto.reqInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::RequestInfoProto*>(
      &::hadoop::hdfs::qjournal::_RequestInfoProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* JournalRequestProto::release_reqinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.JournalRequestProto.reqInfo)
  clear_has_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* JournalRequestProto::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(GetArenaNoVirtual());
    reqinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.JournalRequestProto.reqInfo)
  return reqinfo_;
}
inline void JournalRequestProto::set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqinfo_;
  }
  if (reqinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqinfo, submessage_arena);
    }
    set_has_reqinfo();
  } else {
    clear_has_reqinfo();
  }
  reqinfo_ = reqinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.JournalRequestProto.reqInfo)
}

// required uint64 firstTxnId = 2;
inline bool JournalRequestProto::has_firsttxnid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JournalRequestProto::set_has_firsttxnid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JournalRequestProto::clear_has_firsttxnid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JournalRequestProto::clear_firsttxnid() {
  firsttxnid_ = GOOGLE_ULONGLONG(0);
  clear_has_firsttxnid();
}
inline ::google::protobuf::uint64 JournalRequestProto::firsttxnid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.JournalRequestProto.firstTxnId)
  return firsttxnid_;
}
inline void JournalRequestProto::set_firsttxnid(::google::protobuf::uint64 value) {
  set_has_firsttxnid();
  firsttxnid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.JournalRequestProto.firstTxnId)
}

// required uint32 numTxns = 3;
inline bool JournalRequestProto::has_numtxns() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JournalRequestProto::set_has_numtxns() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JournalRequestProto::clear_has_numtxns() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JournalRequestProto::clear_numtxns() {
  numtxns_ = 0u;
  clear_has_numtxns();
}
inline ::google::protobuf::uint32 JournalRequestProto::numtxns() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.JournalRequestProto.numTxns)
  return numtxns_;
}
inline void JournalRequestProto::set_numtxns(::google::protobuf::uint32 value) {
  set_has_numtxns();
  numtxns_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.JournalRequestProto.numTxns)
}

// required bytes records = 4;
inline bool JournalRequestProto::has_records() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JournalRequestProto::set_has_records() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JournalRequestProto::clear_has_records() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JournalRequestProto::clear_records() {
  records_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_records();
}
inline const ::std::string& JournalRequestProto::records() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.JournalRequestProto.records)
  return records_.GetNoArena();
}
inline void JournalRequestProto::set_records(const ::std::string& value) {
  set_has_records();
  records_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.JournalRequestProto.records)
}
#if LANG_CXX11
inline void JournalRequestProto::set_records(::std::string&& value) {
  set_has_records();
  records_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.JournalRequestProto.records)
}
#endif
inline void JournalRequestProto::set_records(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_records();
  records_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.JournalRequestProto.records)
}
inline void JournalRequestProto::set_records(const void* value, size_t size) {
  set_has_records();
  records_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.JournalRequestProto.records)
}
inline ::std::string* JournalRequestProto::mutable_records() {
  set_has_records();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.JournalRequestProto.records)
  return records_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JournalRequestProto::release_records() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.JournalRequestProto.records)
  if (!has_records()) {
    return NULL;
  }
  clear_has_records();
  return records_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JournalRequestProto::set_allocated_records(::std::string* records) {
  if (records != NULL) {
    set_has_records();
  } else {
    clear_has_records();
  }
  records_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), records);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.JournalRequestProto.records)
}

// required uint64 segmentTxnId = 5;
inline bool JournalRequestProto::has_segmenttxnid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JournalRequestProto::set_has_segmenttxnid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JournalRequestProto::clear_has_segmenttxnid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JournalRequestProto::clear_segmenttxnid() {
  segmenttxnid_ = GOOGLE_ULONGLONG(0);
  clear_has_segmenttxnid();
}
inline ::google::protobuf::uint64 JournalRequestProto::segmenttxnid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.JournalRequestProto.segmentTxnId)
  return segmenttxnid_;
}
inline void JournalRequestProto::set_segmenttxnid(::google::protobuf::uint64 value) {
  set_has_segmenttxnid();
  segmenttxnid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.JournalRequestProto.segmentTxnId)
}

// optional string nameServiceId = 6;
inline bool JournalRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JournalRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JournalRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JournalRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& JournalRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void JournalRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void JournalRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
}
#endif
inline void JournalRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
}
inline void JournalRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
}
inline ::std::string* JournalRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JournalRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JournalRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.JournalRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// JournalResponseProto

// -------------------------------------------------------------------

// HeartbeatRequestProto

// required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
inline bool HeartbeatRequestProto::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRequestProto::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRequestProto::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRequestProto::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->Clear();
  clear_has_reqinfo();
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& HeartbeatRequestProto::_internal_reqinfo() const {
  return *reqinfo_;
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& HeartbeatRequestProto::reqinfo() const {
  const ::hadoop::hdfs::qjournal::RequestInfoProto* p = reqinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.HeartbeatRequestProto.reqInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::RequestInfoProto*>(
      &::hadoop::hdfs::qjournal::_RequestInfoProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* HeartbeatRequestProto::release_reqinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.HeartbeatRequestProto.reqInfo)
  clear_has_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* HeartbeatRequestProto::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(GetArenaNoVirtual());
    reqinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.HeartbeatRequestProto.reqInfo)
  return reqinfo_;
}
inline void HeartbeatRequestProto::set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqinfo_;
  }
  if (reqinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqinfo, submessage_arena);
    }
    set_has_reqinfo();
  } else {
    clear_has_reqinfo();
  }
  reqinfo_ = reqinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.HeartbeatRequestProto.reqInfo)
}

// -------------------------------------------------------------------

// HeartbeatResponseProto

// -------------------------------------------------------------------

// StartLogSegmentRequestProto

// required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
inline bool StartLogSegmentRequestProto::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartLogSegmentRequestProto::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartLogSegmentRequestProto::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartLogSegmentRequestProto::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->Clear();
  clear_has_reqinfo();
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& StartLogSegmentRequestProto::_internal_reqinfo() const {
  return *reqinfo_;
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& StartLogSegmentRequestProto::reqinfo() const {
  const ::hadoop::hdfs::qjournal::RequestInfoProto* p = reqinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.reqInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::RequestInfoProto*>(
      &::hadoop::hdfs::qjournal::_RequestInfoProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* StartLogSegmentRequestProto::release_reqinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.reqInfo)
  clear_has_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* StartLogSegmentRequestProto::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(GetArenaNoVirtual());
    reqinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.reqInfo)
  return reqinfo_;
}
inline void StartLogSegmentRequestProto::set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqinfo_;
  }
  if (reqinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqinfo, submessage_arena);
    }
    set_has_reqinfo();
  } else {
    clear_has_reqinfo();
  }
  reqinfo_ = reqinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.reqInfo)
}

// required uint64 txid = 2;
inline bool StartLogSegmentRequestProto::has_txid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartLogSegmentRequestProto::set_has_txid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartLogSegmentRequestProto::clear_has_txid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartLogSegmentRequestProto::clear_txid() {
  txid_ = GOOGLE_ULONGLONG(0);
  clear_has_txid();
}
inline ::google::protobuf::uint64 StartLogSegmentRequestProto::txid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.txid)
  return txid_;
}
inline void StartLogSegmentRequestProto::set_txid(::google::protobuf::uint64 value) {
  set_has_txid();
  txid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.txid)
}

// optional sint32 layoutVersion = 3;
inline bool StartLogSegmentRequestProto::has_layoutversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartLogSegmentRequestProto::set_has_layoutversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartLogSegmentRequestProto::clear_has_layoutversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartLogSegmentRequestProto::clear_layoutversion() {
  layoutversion_ = 0;
  clear_has_layoutversion();
}
inline ::google::protobuf::int32 StartLogSegmentRequestProto::layoutversion() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.layoutVersion)
  return layoutversion_;
}
inline void StartLogSegmentRequestProto::set_layoutversion(::google::protobuf::int32 value) {
  set_has_layoutversion();
  layoutversion_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.StartLogSegmentRequestProto.layoutVersion)
}

// -------------------------------------------------------------------

// StartLogSegmentResponseProto

// -------------------------------------------------------------------

// FinalizeLogSegmentRequestProto

// required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
inline bool FinalizeLogSegmentRequestProto::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinalizeLogSegmentRequestProto::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinalizeLogSegmentRequestProto::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinalizeLogSegmentRequestProto::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->Clear();
  clear_has_reqinfo();
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& FinalizeLogSegmentRequestProto::_internal_reqinfo() const {
  return *reqinfo_;
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& FinalizeLogSegmentRequestProto::reqinfo() const {
  const ::hadoop::hdfs::qjournal::RequestInfoProto* p = reqinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.reqInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::RequestInfoProto*>(
      &::hadoop::hdfs::qjournal::_RequestInfoProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* FinalizeLogSegmentRequestProto::release_reqinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.reqInfo)
  clear_has_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* FinalizeLogSegmentRequestProto::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(GetArenaNoVirtual());
    reqinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.reqInfo)
  return reqinfo_;
}
inline void FinalizeLogSegmentRequestProto::set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqinfo_;
  }
  if (reqinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqinfo, submessage_arena);
    }
    set_has_reqinfo();
  } else {
    clear_has_reqinfo();
  }
  reqinfo_ = reqinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.reqInfo)
}

// required uint64 startTxId = 2;
inline bool FinalizeLogSegmentRequestProto::has_starttxid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinalizeLogSegmentRequestProto::set_has_starttxid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FinalizeLogSegmentRequestProto::clear_has_starttxid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FinalizeLogSegmentRequestProto::clear_starttxid() {
  starttxid_ = GOOGLE_ULONGLONG(0);
  clear_has_starttxid();
}
inline ::google::protobuf::uint64 FinalizeLogSegmentRequestProto::starttxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.startTxId)
  return starttxid_;
}
inline void FinalizeLogSegmentRequestProto::set_starttxid(::google::protobuf::uint64 value) {
  set_has_starttxid();
  starttxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.startTxId)
}

// required uint64 endTxId = 3;
inline bool FinalizeLogSegmentRequestProto::has_endtxid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FinalizeLogSegmentRequestProto::set_has_endtxid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FinalizeLogSegmentRequestProto::clear_has_endtxid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FinalizeLogSegmentRequestProto::clear_endtxid() {
  endtxid_ = GOOGLE_ULONGLONG(0);
  clear_has_endtxid();
}
inline ::google::protobuf::uint64 FinalizeLogSegmentRequestProto::endtxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.endTxId)
  return endtxid_;
}
inline void FinalizeLogSegmentRequestProto::set_endtxid(::google::protobuf::uint64 value) {
  set_has_endtxid();
  endtxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.FinalizeLogSegmentRequestProto.endTxId)
}

// -------------------------------------------------------------------

// FinalizeLogSegmentResponseProto

// -------------------------------------------------------------------

// PurgeLogsRequestProto

// required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
inline bool PurgeLogsRequestProto::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PurgeLogsRequestProto::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PurgeLogsRequestProto::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PurgeLogsRequestProto::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->Clear();
  clear_has_reqinfo();
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& PurgeLogsRequestProto::_internal_reqinfo() const {
  return *reqinfo_;
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& PurgeLogsRequestProto::reqinfo() const {
  const ::hadoop::hdfs::qjournal::RequestInfoProto* p = reqinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PurgeLogsRequestProto.reqInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::RequestInfoProto*>(
      &::hadoop::hdfs::qjournal::_RequestInfoProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* PurgeLogsRequestProto::release_reqinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.PurgeLogsRequestProto.reqInfo)
  clear_has_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* PurgeLogsRequestProto::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(GetArenaNoVirtual());
    reqinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.PurgeLogsRequestProto.reqInfo)
  return reqinfo_;
}
inline void PurgeLogsRequestProto::set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqinfo_;
  }
  if (reqinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqinfo, submessage_arena);
    }
    set_has_reqinfo();
  } else {
    clear_has_reqinfo();
  }
  reqinfo_ = reqinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.PurgeLogsRequestProto.reqInfo)
}

// required uint64 minTxIdToKeep = 2;
inline bool PurgeLogsRequestProto::has_mintxidtokeep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PurgeLogsRequestProto::set_has_mintxidtokeep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PurgeLogsRequestProto::clear_has_mintxidtokeep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PurgeLogsRequestProto::clear_mintxidtokeep() {
  mintxidtokeep_ = GOOGLE_ULONGLONG(0);
  clear_has_mintxidtokeep();
}
inline ::google::protobuf::uint64 PurgeLogsRequestProto::mintxidtokeep() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PurgeLogsRequestProto.minTxIdToKeep)
  return mintxidtokeep_;
}
inline void PurgeLogsRequestProto::set_mintxidtokeep(::google::protobuf::uint64 value) {
  set_has_mintxidtokeep();
  mintxidtokeep_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.PurgeLogsRequestProto.minTxIdToKeep)
}

// -------------------------------------------------------------------

// PurgeLogsResponseProto

// -------------------------------------------------------------------

// IsFormattedRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool IsFormattedRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsFormattedRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsFormattedRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsFormattedRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& IsFormattedRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& IsFormattedRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.IsFormattedRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* IsFormattedRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.IsFormattedRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* IsFormattedRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.IsFormattedRequestProto.jid)
  return jid_;
}
inline void IsFormattedRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.IsFormattedRequestProto.jid)
}

// optional string nameServiceId = 2;
inline bool IsFormattedRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsFormattedRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsFormattedRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsFormattedRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& IsFormattedRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void IsFormattedRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void IsFormattedRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
}
#endif
inline void IsFormattedRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
}
inline void IsFormattedRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
}
inline ::std::string* IsFormattedRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IsFormattedRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IsFormattedRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.IsFormattedRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// IsFormattedResponseProto

// required bool isFormatted = 1;
inline bool IsFormattedResponseProto::has_isformatted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsFormattedResponseProto::set_has_isformatted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsFormattedResponseProto::clear_has_isformatted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsFormattedResponseProto::clear_isformatted() {
  isformatted_ = false;
  clear_has_isformatted();
}
inline bool IsFormattedResponseProto::isformatted() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.IsFormattedResponseProto.isFormatted)
  return isformatted_;
}
inline void IsFormattedResponseProto::set_isformatted(bool value) {
  set_has_isformatted();
  isformatted_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.IsFormattedResponseProto.isFormatted)
}

// -------------------------------------------------------------------

// GetJournalCTimeRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool GetJournalCTimeRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetJournalCTimeRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetJournalCTimeRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetJournalCTimeRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetJournalCTimeRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetJournalCTimeRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetJournalCTimeRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetJournalCTimeRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.jid)
  return jid_;
}
inline void GetJournalCTimeRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.jid)
}

// optional string nameServiceId = 2;
inline bool GetJournalCTimeRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJournalCTimeRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJournalCTimeRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJournalCTimeRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& GetJournalCTimeRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void GetJournalCTimeRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void GetJournalCTimeRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
}
#endif
inline void GetJournalCTimeRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
}
inline void GetJournalCTimeRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
}
inline ::std::string* GetJournalCTimeRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJournalCTimeRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJournalCTimeRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournalCTimeRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// GetJournalCTimeResponseProto

// required int64 resultCTime = 1;
inline bool GetJournalCTimeResponseProto::has_resultctime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJournalCTimeResponseProto::set_has_resultctime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJournalCTimeResponseProto::clear_has_resultctime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJournalCTimeResponseProto::clear_resultctime() {
  resultctime_ = GOOGLE_LONGLONG(0);
  clear_has_resultctime();
}
inline ::google::protobuf::int64 GetJournalCTimeResponseProto::resultctime() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalCTimeResponseProto.resultCTime)
  return resultctime_;
}
inline void GetJournalCTimeResponseProto::set_resultctime(::google::protobuf::int64 value) {
  set_has_resultctime();
  resultctime_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournalCTimeResponseProto.resultCTime)
}

// -------------------------------------------------------------------

// DoPreUpgradeRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool DoPreUpgradeRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoPreUpgradeRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoPreUpgradeRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoPreUpgradeRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoPreUpgradeRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoPreUpgradeRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DoPreUpgradeRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoPreUpgradeRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DoPreUpgradeRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoPreUpgradeRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DoPreUpgradeRequestProto.jid)
  return jid_;
}
inline void DoPreUpgradeRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DoPreUpgradeRequestProto.jid)
}

// -------------------------------------------------------------------

// DoPreUpgradeResponseProto

// -------------------------------------------------------------------

// DoUpgradeRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool DoUpgradeRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoUpgradeRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoUpgradeRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoUpgradeRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoUpgradeRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoUpgradeRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DoUpgradeRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoUpgradeRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DoUpgradeRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoUpgradeRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DoUpgradeRequestProto.jid)
  return jid_;
}
inline void DoUpgradeRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DoUpgradeRequestProto.jid)
}

// required .hadoop.hdfs.StorageInfoProto sInfo = 2;
inline bool DoUpgradeRequestProto::has_sinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoUpgradeRequestProto::set_has_sinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoUpgradeRequestProto::clear_has_sinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hadoop::hdfs::StorageInfoProto& DoUpgradeRequestProto::_internal_sinfo() const {
  return *sinfo_;
}
inline const ::hadoop::hdfs::StorageInfoProto& DoUpgradeRequestProto::sinfo() const {
  const ::hadoop::hdfs::StorageInfoProto* p = sinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DoUpgradeRequestProto.sInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::StorageInfoProto*>(
      &::hadoop::hdfs::_StorageInfoProto_default_instance_);
}
inline ::hadoop::hdfs::StorageInfoProto* DoUpgradeRequestProto::release_sinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DoUpgradeRequestProto.sInfo)
  clear_has_sinfo();
  ::hadoop::hdfs::StorageInfoProto* temp = sinfo_;
  sinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::StorageInfoProto* DoUpgradeRequestProto::mutable_sinfo() {
  set_has_sinfo();
  if (sinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::StorageInfoProto>(GetArenaNoVirtual());
    sinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DoUpgradeRequestProto.sInfo)
  return sinfo_;
}
inline void DoUpgradeRequestProto::set_allocated_sinfo(::hadoop::hdfs::StorageInfoProto* sinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sinfo_);
  }
  if (sinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sinfo, submessage_arena);
    }
    set_has_sinfo();
  } else {
    clear_has_sinfo();
  }
  sinfo_ = sinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DoUpgradeRequestProto.sInfo)
}

// -------------------------------------------------------------------

// DoUpgradeResponseProto

// -------------------------------------------------------------------

// DoFinalizeRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool DoFinalizeRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoFinalizeRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoFinalizeRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoFinalizeRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoFinalizeRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoFinalizeRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DoFinalizeRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoFinalizeRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DoFinalizeRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoFinalizeRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DoFinalizeRequestProto.jid)
  return jid_;
}
inline void DoFinalizeRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DoFinalizeRequestProto.jid)
}

// optional string nameServiceId = 2;
inline bool DoFinalizeRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoFinalizeRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoFinalizeRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoFinalizeRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& DoFinalizeRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void DoFinalizeRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void DoFinalizeRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
}
#endif
inline void DoFinalizeRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
}
inline void DoFinalizeRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
}
inline ::std::string* DoFinalizeRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DoFinalizeRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DoFinalizeRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DoFinalizeRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// DoFinalizeResponseProto

// -------------------------------------------------------------------

// CanRollBackRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool CanRollBackRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CanRollBackRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CanRollBackRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CanRollBackRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& CanRollBackRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& CanRollBackRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.CanRollBackRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* CanRollBackRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.CanRollBackRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* CanRollBackRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.CanRollBackRequestProto.jid)
  return jid_;
}
inline void CanRollBackRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.CanRollBackRequestProto.jid)
}

// required .hadoop.hdfs.StorageInfoProto storage = 2;
inline bool CanRollBackRequestProto::has_storage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CanRollBackRequestProto::set_has_storage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CanRollBackRequestProto::clear_has_storage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hadoop::hdfs::StorageInfoProto& CanRollBackRequestProto::_internal_storage() const {
  return *storage_;
}
inline const ::hadoop::hdfs::StorageInfoProto& CanRollBackRequestProto::storage() const {
  const ::hadoop::hdfs::StorageInfoProto* p = storage_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.CanRollBackRequestProto.storage)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::StorageInfoProto*>(
      &::hadoop::hdfs::_StorageInfoProto_default_instance_);
}
inline ::hadoop::hdfs::StorageInfoProto* CanRollBackRequestProto::release_storage() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.CanRollBackRequestProto.storage)
  clear_has_storage();
  ::hadoop::hdfs::StorageInfoProto* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::StorageInfoProto* CanRollBackRequestProto::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::StorageInfoProto>(GetArenaNoVirtual());
    storage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.CanRollBackRequestProto.storage)
  return storage_;
}
inline void CanRollBackRequestProto::set_allocated_storage(::hadoop::hdfs::StorageInfoProto* storage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(storage_);
  }
  if (storage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    set_has_storage();
  } else {
    clear_has_storage();
  }
  storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.CanRollBackRequestProto.storage)
}

// required .hadoop.hdfs.StorageInfoProto prevStorage = 3;
inline bool CanRollBackRequestProto::has_prevstorage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CanRollBackRequestProto::set_has_prevstorage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CanRollBackRequestProto::clear_has_prevstorage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hadoop::hdfs::StorageInfoProto& CanRollBackRequestProto::_internal_prevstorage() const {
  return *prevstorage_;
}
inline const ::hadoop::hdfs::StorageInfoProto& CanRollBackRequestProto::prevstorage() const {
  const ::hadoop::hdfs::StorageInfoProto* p = prevstorage_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.CanRollBackRequestProto.prevStorage)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::StorageInfoProto*>(
      &::hadoop::hdfs::_StorageInfoProto_default_instance_);
}
inline ::hadoop::hdfs::StorageInfoProto* CanRollBackRequestProto::release_prevstorage() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.CanRollBackRequestProto.prevStorage)
  clear_has_prevstorage();
  ::hadoop::hdfs::StorageInfoProto* temp = prevstorage_;
  prevstorage_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::StorageInfoProto* CanRollBackRequestProto::mutable_prevstorage() {
  set_has_prevstorage();
  if (prevstorage_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::StorageInfoProto>(GetArenaNoVirtual());
    prevstorage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.CanRollBackRequestProto.prevStorage)
  return prevstorage_;
}
inline void CanRollBackRequestProto::set_allocated_prevstorage(::hadoop::hdfs::StorageInfoProto* prevstorage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(prevstorage_);
  }
  if (prevstorage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prevstorage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prevstorage, submessage_arena);
    }
    set_has_prevstorage();
  } else {
    clear_has_prevstorage();
  }
  prevstorage_ = prevstorage;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.CanRollBackRequestProto.prevStorage)
}

// required int32 targetLayoutVersion = 4;
inline bool CanRollBackRequestProto::has_targetlayoutversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CanRollBackRequestProto::set_has_targetlayoutversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CanRollBackRequestProto::clear_has_targetlayoutversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CanRollBackRequestProto::clear_targetlayoutversion() {
  targetlayoutversion_ = 0;
  clear_has_targetlayoutversion();
}
inline ::google::protobuf::int32 CanRollBackRequestProto::targetlayoutversion() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.CanRollBackRequestProto.targetLayoutVersion)
  return targetlayoutversion_;
}
inline void CanRollBackRequestProto::set_targetlayoutversion(::google::protobuf::int32 value) {
  set_has_targetlayoutversion();
  targetlayoutversion_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.CanRollBackRequestProto.targetLayoutVersion)
}

// optional string nameServiceId = 5;
inline bool CanRollBackRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CanRollBackRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CanRollBackRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CanRollBackRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& CanRollBackRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void CanRollBackRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void CanRollBackRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
}
#endif
inline void CanRollBackRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
}
inline void CanRollBackRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
}
inline ::std::string* CanRollBackRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CanRollBackRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CanRollBackRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.CanRollBackRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// CanRollBackResponseProto

// required bool canRollBack = 1;
inline bool CanRollBackResponseProto::has_canrollback() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CanRollBackResponseProto::set_has_canrollback() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CanRollBackResponseProto::clear_has_canrollback() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CanRollBackResponseProto::clear_canrollback() {
  canrollback_ = false;
  clear_has_canrollback();
}
inline bool CanRollBackResponseProto::canrollback() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.CanRollBackResponseProto.canRollBack)
  return canrollback_;
}
inline void CanRollBackResponseProto::set_canrollback(bool value) {
  set_has_canrollback();
  canrollback_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.CanRollBackResponseProto.canRollBack)
}

// -------------------------------------------------------------------

// DoRollbackRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool DoRollbackRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoRollbackRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoRollbackRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoRollbackRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoRollbackRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DoRollbackRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DoRollbackRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoRollbackRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DoRollbackRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DoRollbackRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DoRollbackRequestProto.jid)
  return jid_;
}
inline void DoRollbackRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DoRollbackRequestProto.jid)
}

// optional string nameserviceId = 2;
inline bool DoRollbackRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoRollbackRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoRollbackRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoRollbackRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& DoRollbackRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
  return nameserviceid_.GetNoArena();
}
inline void DoRollbackRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
}
#if LANG_CXX11
inline void DoRollbackRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
}
#endif
inline void DoRollbackRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
}
inline void DoRollbackRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
}
inline ::std::string* DoRollbackRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DoRollbackRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DoRollbackRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DoRollbackRequestProto.nameserviceId)
}

// -------------------------------------------------------------------

// DoRollbackResponseProto

// -------------------------------------------------------------------

// DiscardSegmentsRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool DiscardSegmentsRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscardSegmentsRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscardSegmentsRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscardSegmentsRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DiscardSegmentsRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& DiscardSegmentsRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DiscardSegmentsRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* DiscardSegmentsRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.jid)
  return jid_;
}
inline void DiscardSegmentsRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.jid)
}

// required uint64 startTxId = 2;
inline bool DiscardSegmentsRequestProto::has_starttxid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscardSegmentsRequestProto::set_has_starttxid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscardSegmentsRequestProto::clear_has_starttxid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscardSegmentsRequestProto::clear_starttxid() {
  starttxid_ = GOOGLE_ULONGLONG(0);
  clear_has_starttxid();
}
inline ::google::protobuf::uint64 DiscardSegmentsRequestProto::starttxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.startTxId)
  return starttxid_;
}
inline void DiscardSegmentsRequestProto::set_starttxid(::google::protobuf::uint64 value) {
  set_has_starttxid();
  starttxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.startTxId)
}

// optional string nameServiceId = 3;
inline bool DiscardSegmentsRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscardSegmentsRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscardSegmentsRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscardSegmentsRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& DiscardSegmentsRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void DiscardSegmentsRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void DiscardSegmentsRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
}
#endif
inline void DiscardSegmentsRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
}
inline void DiscardSegmentsRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
}
inline ::std::string* DiscardSegmentsRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscardSegmentsRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscardSegmentsRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.DiscardSegmentsRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// DiscardSegmentsResponseProto

// -------------------------------------------------------------------

// GetJournalStateRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool GetJournalStateRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetJournalStateRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetJournalStateRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetJournalStateRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetJournalStateRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetJournalStateRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalStateRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetJournalStateRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournalStateRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetJournalStateRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournalStateRequestProto.jid)
  return jid_;
}
inline void GetJournalStateRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournalStateRequestProto.jid)
}

// optional string nameServiceId = 2;
inline bool GetJournalStateRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJournalStateRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJournalStateRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJournalStateRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& GetJournalStateRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void GetJournalStateRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void GetJournalStateRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
}
#endif
inline void GetJournalStateRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
}
inline void GetJournalStateRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
}
inline ::std::string* GetJournalStateRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJournalStateRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJournalStateRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournalStateRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// GetJournalStateResponseProto

// required uint64 lastPromisedEpoch = 1;
inline bool GetJournalStateResponseProto::has_lastpromisedepoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetJournalStateResponseProto::set_has_lastpromisedepoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetJournalStateResponseProto::clear_has_lastpromisedepoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetJournalStateResponseProto::clear_lastpromisedepoch() {
  lastpromisedepoch_ = GOOGLE_ULONGLONG(0);
  clear_has_lastpromisedepoch();
}
inline ::google::protobuf::uint64 GetJournalStateResponseProto::lastpromisedepoch() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalStateResponseProto.lastPromisedEpoch)
  return lastpromisedepoch_;
}
inline void GetJournalStateResponseProto::set_lastpromisedepoch(::google::protobuf::uint64 value) {
  set_has_lastpromisedepoch();
  lastpromisedepoch_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournalStateResponseProto.lastPromisedEpoch)
}

// required uint32 httpPort = 2;
inline bool GetJournalStateResponseProto::has_httpport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetJournalStateResponseProto::set_has_httpport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetJournalStateResponseProto::clear_has_httpport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetJournalStateResponseProto::clear_httpport() {
  httpport_ = 0u;
  clear_has_httpport();
}
inline ::google::protobuf::uint32 GetJournalStateResponseProto::httpport() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalStateResponseProto.httpPort)
  return httpport_;
}
inline void GetJournalStateResponseProto::set_httpport(::google::protobuf::uint32 value) {
  set_has_httpport();
  httpport_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournalStateResponseProto.httpPort)
}

// optional string fromURL = 3;
inline bool GetJournalStateResponseProto::has_fromurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJournalStateResponseProto::set_has_fromurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJournalStateResponseProto::clear_has_fromurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJournalStateResponseProto::clear_fromurl() {
  fromurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromurl();
}
inline const ::std::string& GetJournalStateResponseProto::fromurl() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
  return fromurl_.GetNoArena();
}
inline void GetJournalStateResponseProto::set_fromurl(const ::std::string& value) {
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
}
#if LANG_CXX11
inline void GetJournalStateResponseProto::set_fromurl(::std::string&& value) {
  set_has_fromurl();
  fromurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
}
#endif
inline void GetJournalStateResponseProto::set_fromurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
}
inline void GetJournalStateResponseProto::set_fromurl(const char* value, size_t size) {
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
}
inline ::std::string* GetJournalStateResponseProto::mutable_fromurl() {
  set_has_fromurl();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
  return fromurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJournalStateResponseProto::release_fromurl() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
  if (!has_fromurl()) {
    return NULL;
  }
  clear_has_fromurl();
  return fromurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJournalStateResponseProto::set_allocated_fromurl(::std::string* fromurl) {
  if (fromurl != NULL) {
    set_has_fromurl();
  } else {
    clear_has_fromurl();
  }
  fromurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromurl);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournalStateResponseProto.fromURL)
}

// -------------------------------------------------------------------

// FormatRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool FormatRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormatRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormatRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormatRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& FormatRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& FormatRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.FormatRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* FormatRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.FormatRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* FormatRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.FormatRequestProto.jid)
  return jid_;
}
inline void FormatRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.FormatRequestProto.jid)
}

// required .hadoop.hdfs.NamespaceInfoProto nsInfo = 2;
inline bool FormatRequestProto::has_nsinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormatRequestProto::set_has_nsinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormatRequestProto::clear_has_nsinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hadoop::hdfs::NamespaceInfoProto& FormatRequestProto::_internal_nsinfo() const {
  return *nsinfo_;
}
inline const ::hadoop::hdfs::NamespaceInfoProto& FormatRequestProto::nsinfo() const {
  const ::hadoop::hdfs::NamespaceInfoProto* p = nsinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.FormatRequestProto.nsInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamespaceInfoProto*>(
      &::hadoop::hdfs::_NamespaceInfoProto_default_instance_);
}
inline ::hadoop::hdfs::NamespaceInfoProto* FormatRequestProto::release_nsinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.FormatRequestProto.nsInfo)
  clear_has_nsinfo();
  ::hadoop::hdfs::NamespaceInfoProto* temp = nsinfo_;
  nsinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamespaceInfoProto* FormatRequestProto::mutable_nsinfo() {
  set_has_nsinfo();
  if (nsinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamespaceInfoProto>(GetArenaNoVirtual());
    nsinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.FormatRequestProto.nsInfo)
  return nsinfo_;
}
inline void FormatRequestProto::set_allocated_nsinfo(::hadoop::hdfs::NamespaceInfoProto* nsinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(nsinfo_);
  }
  if (nsinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nsinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nsinfo, submessage_arena);
    }
    set_has_nsinfo();
  } else {
    clear_has_nsinfo();
  }
  nsinfo_ = nsinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.FormatRequestProto.nsInfo)
}

// optional string nameServiceId = 3;
inline bool FormatRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& FormatRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void FormatRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void FormatRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
}
#endif
inline void FormatRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
}
inline void FormatRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
}
inline ::std::string* FormatRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FormatRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FormatRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.FormatRequestProto.nameServiceId)
}

// optional bool force = 4 [default = false];
inline bool FormatRequestProto::has_force() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormatRequestProto::set_has_force() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormatRequestProto::clear_has_force() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormatRequestProto::clear_force() {
  force_ = false;
  clear_has_force();
}
inline bool FormatRequestProto::force() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.FormatRequestProto.force)
  return force_;
}
inline void FormatRequestProto::set_force(bool value) {
  set_has_force();
  force_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.FormatRequestProto.force)
}

// -------------------------------------------------------------------

// FormatResponseProto

// -------------------------------------------------------------------

// NewEpochRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool NewEpochRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewEpochRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewEpochRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewEpochRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& NewEpochRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& NewEpochRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.NewEpochRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* NewEpochRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.NewEpochRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* NewEpochRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.NewEpochRequestProto.jid)
  return jid_;
}
inline void NewEpochRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.NewEpochRequestProto.jid)
}

// required .hadoop.hdfs.NamespaceInfoProto nsInfo = 2;
inline bool NewEpochRequestProto::has_nsinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewEpochRequestProto::set_has_nsinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewEpochRequestProto::clear_has_nsinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hadoop::hdfs::NamespaceInfoProto& NewEpochRequestProto::_internal_nsinfo() const {
  return *nsinfo_;
}
inline const ::hadoop::hdfs::NamespaceInfoProto& NewEpochRequestProto::nsinfo() const {
  const ::hadoop::hdfs::NamespaceInfoProto* p = nsinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.NewEpochRequestProto.nsInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::NamespaceInfoProto*>(
      &::hadoop::hdfs::_NamespaceInfoProto_default_instance_);
}
inline ::hadoop::hdfs::NamespaceInfoProto* NewEpochRequestProto::release_nsinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.NewEpochRequestProto.nsInfo)
  clear_has_nsinfo();
  ::hadoop::hdfs::NamespaceInfoProto* temp = nsinfo_;
  nsinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::NamespaceInfoProto* NewEpochRequestProto::mutable_nsinfo() {
  set_has_nsinfo();
  if (nsinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::NamespaceInfoProto>(GetArenaNoVirtual());
    nsinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.NewEpochRequestProto.nsInfo)
  return nsinfo_;
}
inline void NewEpochRequestProto::set_allocated_nsinfo(::hadoop::hdfs::NamespaceInfoProto* nsinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(nsinfo_);
  }
  if (nsinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nsinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nsinfo, submessage_arena);
    }
    set_has_nsinfo();
  } else {
    clear_has_nsinfo();
  }
  nsinfo_ = nsinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.NewEpochRequestProto.nsInfo)
}

// required uint64 epoch = 3;
inline bool NewEpochRequestProto::has_epoch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewEpochRequestProto::set_has_epoch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewEpochRequestProto::clear_has_epoch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewEpochRequestProto::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
  clear_has_epoch();
}
inline ::google::protobuf::uint64 NewEpochRequestProto::epoch() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.NewEpochRequestProto.epoch)
  return epoch_;
}
inline void NewEpochRequestProto::set_epoch(::google::protobuf::uint64 value) {
  set_has_epoch();
  epoch_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.NewEpochRequestProto.epoch)
}

// optional string nameServiceId = 4;
inline bool NewEpochRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewEpochRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewEpochRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewEpochRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& NewEpochRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void NewEpochRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void NewEpochRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
}
#endif
inline void NewEpochRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
}
inline void NewEpochRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
}
inline ::std::string* NewEpochRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewEpochRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewEpochRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.NewEpochRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// NewEpochResponseProto

// optional uint64 lastSegmentTxId = 1;
inline bool NewEpochResponseProto::has_lastsegmenttxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewEpochResponseProto::set_has_lastsegmenttxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewEpochResponseProto::clear_has_lastsegmenttxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewEpochResponseProto::clear_lastsegmenttxid() {
  lastsegmenttxid_ = GOOGLE_ULONGLONG(0);
  clear_has_lastsegmenttxid();
}
inline ::google::protobuf::uint64 NewEpochResponseProto::lastsegmenttxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.NewEpochResponseProto.lastSegmentTxId)
  return lastsegmenttxid_;
}
inline void NewEpochResponseProto::set_lastsegmenttxid(::google::protobuf::uint64 value) {
  set_has_lastsegmenttxid();
  lastsegmenttxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.NewEpochResponseProto.lastSegmentTxId)
}

// -------------------------------------------------------------------

// GetEditLogManifestRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool GetEditLogManifestRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEditLogManifestRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEditLogManifestRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEditLogManifestRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetEditLogManifestRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetEditLogManifestRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetEditLogManifestRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetEditLogManifestRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.jid)
  return jid_;
}
inline void GetEditLogManifestRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.jid)
}

// required uint64 sinceTxId = 2;
inline bool GetEditLogManifestRequestProto::has_sincetxid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEditLogManifestRequestProto::set_has_sincetxid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEditLogManifestRequestProto::clear_has_sincetxid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEditLogManifestRequestProto::clear_sincetxid() {
  sincetxid_ = GOOGLE_ULONGLONG(0);
  clear_has_sincetxid();
}
inline ::google::protobuf::uint64 GetEditLogManifestRequestProto::sincetxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.sinceTxId)
  return sincetxid_;
}
inline void GetEditLogManifestRequestProto::set_sincetxid(::google::protobuf::uint64 value) {
  set_has_sincetxid();
  sincetxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.sinceTxId)
}

// optional bool inProgressOk = 4 [default = false];
inline bool GetEditLogManifestRequestProto::has_inprogressok() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetEditLogManifestRequestProto::set_has_inprogressok() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetEditLogManifestRequestProto::clear_has_inprogressok() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetEditLogManifestRequestProto::clear_inprogressok() {
  inprogressok_ = false;
  clear_has_inprogressok();
}
inline bool GetEditLogManifestRequestProto::inprogressok() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.inProgressOk)
  return inprogressok_;
}
inline void GetEditLogManifestRequestProto::set_inprogressok(bool value) {
  set_has_inprogressok();
  inprogressok_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.inProgressOk)
}

// optional string nameServiceId = 5;
inline bool GetEditLogManifestRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEditLogManifestRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEditLogManifestRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEditLogManifestRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& GetEditLogManifestRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void GetEditLogManifestRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void GetEditLogManifestRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
}
#endif
inline void GetEditLogManifestRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
}
inline void GetEditLogManifestRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
}
inline ::std::string* GetEditLogManifestRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEditLogManifestRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEditLogManifestRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetEditLogManifestRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// GetEditLogManifestResponseProto

// required .hadoop.hdfs.RemoteEditLogManifestProto manifest = 1;
inline bool GetEditLogManifestResponseProto::has_manifest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEditLogManifestResponseProto::set_has_manifest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEditLogManifestResponseProto::clear_has_manifest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hadoop::hdfs::RemoteEditLogManifestProto& GetEditLogManifestResponseProto::_internal_manifest() const {
  return *manifest_;
}
inline const ::hadoop::hdfs::RemoteEditLogManifestProto& GetEditLogManifestResponseProto::manifest() const {
  const ::hadoop::hdfs::RemoteEditLogManifestProto* p = manifest_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.manifest)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::RemoteEditLogManifestProto*>(
      &::hadoop::hdfs::_RemoteEditLogManifestProto_default_instance_);
}
inline ::hadoop::hdfs::RemoteEditLogManifestProto* GetEditLogManifestResponseProto::release_manifest() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.manifest)
  clear_has_manifest();
  ::hadoop::hdfs::RemoteEditLogManifestProto* temp = manifest_;
  manifest_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::RemoteEditLogManifestProto* GetEditLogManifestResponseProto::mutable_manifest() {
  set_has_manifest();
  if (manifest_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::RemoteEditLogManifestProto>(GetArenaNoVirtual());
    manifest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.manifest)
  return manifest_;
}
inline void GetEditLogManifestResponseProto::set_allocated_manifest(::hadoop::hdfs::RemoteEditLogManifestProto* manifest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(manifest_);
  }
  if (manifest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      manifest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, manifest, submessage_arena);
    }
    set_has_manifest();
  } else {
    clear_has_manifest();
  }
  manifest_ = manifest;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.manifest)
}

// required uint32 httpPort = 2;
inline bool GetEditLogManifestResponseProto::has_httpport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEditLogManifestResponseProto::set_has_httpport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEditLogManifestResponseProto::clear_has_httpport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEditLogManifestResponseProto::clear_httpport() {
  httpport_ = 0u;
  clear_has_httpport();
}
inline ::google::protobuf::uint32 GetEditLogManifestResponseProto::httpport() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.httpPort)
  return httpport_;
}
inline void GetEditLogManifestResponseProto::set_httpport(::google::protobuf::uint32 value) {
  set_has_httpport();
  httpport_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.httpPort)
}

// optional string fromURL = 3;
inline bool GetEditLogManifestResponseProto::has_fromurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEditLogManifestResponseProto::set_has_fromurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEditLogManifestResponseProto::clear_has_fromurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEditLogManifestResponseProto::clear_fromurl() {
  fromurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromurl();
}
inline const ::std::string& GetEditLogManifestResponseProto::fromurl() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
  return fromurl_.GetNoArena();
}
inline void GetEditLogManifestResponseProto::set_fromurl(const ::std::string& value) {
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
}
#if LANG_CXX11
inline void GetEditLogManifestResponseProto::set_fromurl(::std::string&& value) {
  set_has_fromurl();
  fromurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
}
#endif
inline void GetEditLogManifestResponseProto::set_fromurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
}
inline void GetEditLogManifestResponseProto::set_fromurl(const char* value, size_t size) {
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
}
inline ::std::string* GetEditLogManifestResponseProto::mutable_fromurl() {
  set_has_fromurl();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
  return fromurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEditLogManifestResponseProto::release_fromurl() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
  if (!has_fromurl()) {
    return NULL;
  }
  clear_has_fromurl();
  return fromurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEditLogManifestResponseProto::set_allocated_fromurl(::std::string* fromurl) {
  if (fromurl != NULL) {
    set_has_fromurl();
  } else {
    clear_has_fromurl();
  }
  fromurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromurl);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetEditLogManifestResponseProto.fromURL)
}

// -------------------------------------------------------------------

// GetJournaledEditsRequestProto

// required .hadoop.hdfs.qjournal.JournalIdProto jid = 1;
inline bool GetJournaledEditsRequestProto::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetJournaledEditsRequestProto::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetJournaledEditsRequestProto::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetJournaledEditsRequestProto::clear_jid() {
  if (jid_ != NULL) jid_->Clear();
  clear_has_jid();
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetJournaledEditsRequestProto::_internal_jid() const {
  return *jid_;
}
inline const ::hadoop::hdfs::qjournal::JournalIdProto& GetJournaledEditsRequestProto::jid() const {
  const ::hadoop::hdfs::qjournal::JournalIdProto* p = jid_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.jid)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::JournalIdProto*>(
      &::hadoop::hdfs::qjournal::_JournalIdProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetJournaledEditsRequestProto::release_jid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.jid)
  clear_has_jid();
  ::hadoop::hdfs::qjournal::JournalIdProto* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::JournalIdProto* GetJournaledEditsRequestProto::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::JournalIdProto>(GetArenaNoVirtual());
    jid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.jid)
  return jid_;
}
inline void GetJournaledEditsRequestProto::set_allocated_jid(::hadoop::hdfs::qjournal::JournalIdProto* jid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jid_;
  }
  if (jid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.jid)
}

// required uint64 sinceTxId = 2;
inline bool GetJournaledEditsRequestProto::has_sincetxid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetJournaledEditsRequestProto::set_has_sincetxid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetJournaledEditsRequestProto::clear_has_sincetxid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetJournaledEditsRequestProto::clear_sincetxid() {
  sincetxid_ = GOOGLE_ULONGLONG(0);
  clear_has_sincetxid();
}
inline ::google::protobuf::uint64 GetJournaledEditsRequestProto::sincetxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.sinceTxId)
  return sincetxid_;
}
inline void GetJournaledEditsRequestProto::set_sincetxid(::google::protobuf::uint64 value) {
  set_has_sincetxid();
  sincetxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.sinceTxId)
}

// required uint32 maxTxns = 3;
inline bool GetJournaledEditsRequestProto::has_maxtxns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetJournaledEditsRequestProto::set_has_maxtxns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetJournaledEditsRequestProto::clear_has_maxtxns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetJournaledEditsRequestProto::clear_maxtxns() {
  maxtxns_ = 0u;
  clear_has_maxtxns();
}
inline ::google::protobuf::uint32 GetJournaledEditsRequestProto::maxtxns() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.maxTxns)
  return maxtxns_;
}
inline void GetJournaledEditsRequestProto::set_maxtxns(::google::protobuf::uint32 value) {
  set_has_maxtxns();
  maxtxns_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.maxTxns)
}

// optional string nameServiceId = 4;
inline bool GetJournaledEditsRequestProto::has_nameserviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJournaledEditsRequestProto::set_has_nameserviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJournaledEditsRequestProto::clear_has_nameserviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJournaledEditsRequestProto::clear_nameserviceid() {
  nameserviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nameserviceid();
}
inline const ::std::string& GetJournaledEditsRequestProto::nameserviceid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
  return nameserviceid_.GetNoArena();
}
inline void GetJournaledEditsRequestProto::set_nameserviceid(const ::std::string& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
}
#if LANG_CXX11
inline void GetJournaledEditsRequestProto::set_nameserviceid(::std::string&& value) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
}
#endif
inline void GetJournaledEditsRequestProto::set_nameserviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
}
inline void GetJournaledEditsRequestProto::set_nameserviceid(const char* value, size_t size) {
  set_has_nameserviceid();
  nameserviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
}
inline ::std::string* GetJournaledEditsRequestProto::mutable_nameserviceid() {
  set_has_nameserviceid();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
  return nameserviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJournaledEditsRequestProto::release_nameserviceid() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
  if (!has_nameserviceid()) {
    return NULL;
  }
  clear_has_nameserviceid();
  return nameserviceid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJournaledEditsRequestProto::set_allocated_nameserviceid(::std::string* nameserviceid) {
  if (nameserviceid != NULL) {
    set_has_nameserviceid();
  } else {
    clear_has_nameserviceid();
  }
  nameserviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nameserviceid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournaledEditsRequestProto.nameServiceId)
}

// -------------------------------------------------------------------

// GetJournaledEditsResponseProto

// required uint32 txnCount = 1;
inline bool GetJournaledEditsResponseProto::has_txncount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetJournaledEditsResponseProto::set_has_txncount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetJournaledEditsResponseProto::clear_has_txncount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetJournaledEditsResponseProto::clear_txncount() {
  txncount_ = 0u;
  clear_has_txncount();
}
inline ::google::protobuf::uint32 GetJournaledEditsResponseProto::txncount() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.txnCount)
  return txncount_;
}
inline void GetJournaledEditsResponseProto::set_txncount(::google::protobuf::uint32 value) {
  set_has_txncount();
  txncount_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.txnCount)
}

// optional bytes editLog = 2;
inline bool GetJournaledEditsResponseProto::has_editlog() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJournaledEditsResponseProto::set_has_editlog() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJournaledEditsResponseProto::clear_has_editlog() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJournaledEditsResponseProto::clear_editlog() {
  editlog_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_editlog();
}
inline const ::std::string& GetJournaledEditsResponseProto::editlog() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
  return editlog_.GetNoArena();
}
inline void GetJournaledEditsResponseProto::set_editlog(const ::std::string& value) {
  set_has_editlog();
  editlog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
}
#if LANG_CXX11
inline void GetJournaledEditsResponseProto::set_editlog(::std::string&& value) {
  set_has_editlog();
  editlog_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
}
#endif
inline void GetJournaledEditsResponseProto::set_editlog(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_editlog();
  editlog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
}
inline void GetJournaledEditsResponseProto::set_editlog(const void* value, size_t size) {
  set_has_editlog();
  editlog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
}
inline ::std::string* GetJournaledEditsResponseProto::mutable_editlog() {
  set_has_editlog();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
  return editlog_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJournaledEditsResponseProto::release_editlog() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
  if (!has_editlog()) {
    return NULL;
  }
  clear_has_editlog();
  return editlog_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJournaledEditsResponseProto::set_allocated_editlog(::std::string* editlog) {
  if (editlog != NULL) {
    set_has_editlog();
  } else {
    clear_has_editlog();
  }
  editlog_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), editlog);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.GetJournaledEditsResponseProto.editLog)
}

// -------------------------------------------------------------------

// PrepareRecoveryRequestProto

// required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
inline bool PrepareRecoveryRequestProto::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepareRecoveryRequestProto::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepareRecoveryRequestProto::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepareRecoveryRequestProto::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->Clear();
  clear_has_reqinfo();
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& PrepareRecoveryRequestProto::_internal_reqinfo() const {
  return *reqinfo_;
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& PrepareRecoveryRequestProto::reqinfo() const {
  const ::hadoop::hdfs::qjournal::RequestInfoProto* p = reqinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto.reqInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::RequestInfoProto*>(
      &::hadoop::hdfs::qjournal::_RequestInfoProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* PrepareRecoveryRequestProto::release_reqinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto.reqInfo)
  clear_has_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* PrepareRecoveryRequestProto::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(GetArenaNoVirtual());
    reqinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto.reqInfo)
  return reqinfo_;
}
inline void PrepareRecoveryRequestProto::set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqinfo_;
  }
  if (reqinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqinfo, submessage_arena);
    }
    set_has_reqinfo();
  } else {
    clear_has_reqinfo();
  }
  reqinfo_ = reqinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto.reqInfo)
}

// required uint64 segmentTxId = 2;
inline bool PrepareRecoveryRequestProto::has_segmenttxid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrepareRecoveryRequestProto::set_has_segmenttxid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrepareRecoveryRequestProto::clear_has_segmenttxid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrepareRecoveryRequestProto::clear_segmenttxid() {
  segmenttxid_ = GOOGLE_ULONGLONG(0);
  clear_has_segmenttxid();
}
inline ::google::protobuf::uint64 PrepareRecoveryRequestProto::segmenttxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto.segmentTxId)
  return segmenttxid_;
}
inline void PrepareRecoveryRequestProto::set_segmenttxid(::google::protobuf::uint64 value) {
  set_has_segmenttxid();
  segmenttxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.PrepareRecoveryRequestProto.segmentTxId)
}

// -------------------------------------------------------------------

// PrepareRecoveryResponseProto

// optional .hadoop.hdfs.qjournal.SegmentStateProto segmentState = 1;
inline bool PrepareRecoveryResponseProto::has_segmentstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepareRecoveryResponseProto::set_has_segmentstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepareRecoveryResponseProto::clear_has_segmentstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepareRecoveryResponseProto::clear_segmentstate() {
  if (segmentstate_ != NULL) segmentstate_->Clear();
  clear_has_segmentstate();
}
inline const ::hadoop::hdfs::qjournal::SegmentStateProto& PrepareRecoveryResponseProto::_internal_segmentstate() const {
  return *segmentstate_;
}
inline const ::hadoop::hdfs::qjournal::SegmentStateProto& PrepareRecoveryResponseProto::segmentstate() const {
  const ::hadoop::hdfs::qjournal::SegmentStateProto* p = segmentstate_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.segmentState)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::SegmentStateProto*>(
      &::hadoop::hdfs::qjournal::_SegmentStateProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::SegmentStateProto* PrepareRecoveryResponseProto::release_segmentstate() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.segmentState)
  clear_has_segmentstate();
  ::hadoop::hdfs::qjournal::SegmentStateProto* temp = segmentstate_;
  segmentstate_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::SegmentStateProto* PrepareRecoveryResponseProto::mutable_segmentstate() {
  set_has_segmentstate();
  if (segmentstate_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::SegmentStateProto>(GetArenaNoVirtual());
    segmentstate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.segmentState)
  return segmentstate_;
}
inline void PrepareRecoveryResponseProto::set_allocated_segmentstate(::hadoop::hdfs::qjournal::SegmentStateProto* segmentstate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete segmentstate_;
  }
  if (segmentstate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      segmentstate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, segmentstate, submessage_arena);
    }
    set_has_segmentstate();
  } else {
    clear_has_segmentstate();
  }
  segmentstate_ = segmentstate;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.segmentState)
}

// optional uint64 acceptedInEpoch = 2;
inline bool PrepareRecoveryResponseProto::has_acceptedinepoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrepareRecoveryResponseProto::set_has_acceptedinepoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrepareRecoveryResponseProto::clear_has_acceptedinepoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrepareRecoveryResponseProto::clear_acceptedinepoch() {
  acceptedinepoch_ = GOOGLE_ULONGLONG(0);
  clear_has_acceptedinepoch();
}
inline ::google::protobuf::uint64 PrepareRecoveryResponseProto::acceptedinepoch() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.acceptedInEpoch)
  return acceptedinepoch_;
}
inline void PrepareRecoveryResponseProto::set_acceptedinepoch(::google::protobuf::uint64 value) {
  set_has_acceptedinepoch();
  acceptedinepoch_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.acceptedInEpoch)
}

// required uint64 lastWriterEpoch = 3;
inline bool PrepareRecoveryResponseProto::has_lastwriterepoch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrepareRecoveryResponseProto::set_has_lastwriterepoch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrepareRecoveryResponseProto::clear_has_lastwriterepoch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrepareRecoveryResponseProto::clear_lastwriterepoch() {
  lastwriterepoch_ = GOOGLE_ULONGLONG(0);
  clear_has_lastwriterepoch();
}
inline ::google::protobuf::uint64 PrepareRecoveryResponseProto::lastwriterepoch() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.lastWriterEpoch)
  return lastwriterepoch_;
}
inline void PrepareRecoveryResponseProto::set_lastwriterepoch(::google::protobuf::uint64 value) {
  set_has_lastwriterepoch();
  lastwriterepoch_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.lastWriterEpoch)
}

// optional uint64 lastCommittedTxId = 4;
inline bool PrepareRecoveryResponseProto::has_lastcommittedtxid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrepareRecoveryResponseProto::set_has_lastcommittedtxid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrepareRecoveryResponseProto::clear_has_lastcommittedtxid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrepareRecoveryResponseProto::clear_lastcommittedtxid() {
  lastcommittedtxid_ = GOOGLE_ULONGLONG(0);
  clear_has_lastcommittedtxid();
}
inline ::google::protobuf::uint64 PrepareRecoveryResponseProto::lastcommittedtxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.lastCommittedTxId)
  return lastcommittedtxid_;
}
inline void PrepareRecoveryResponseProto::set_lastcommittedtxid(::google::protobuf::uint64 value) {
  set_has_lastcommittedtxid();
  lastcommittedtxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.PrepareRecoveryResponseProto.lastCommittedTxId)
}

// -------------------------------------------------------------------

// AcceptRecoveryRequestProto

// required .hadoop.hdfs.qjournal.RequestInfoProto reqInfo = 1;
inline bool AcceptRecoveryRequestProto::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptRecoveryRequestProto::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptRecoveryRequestProto::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptRecoveryRequestProto::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->Clear();
  clear_has_reqinfo();
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& AcceptRecoveryRequestProto::_internal_reqinfo() const {
  return *reqinfo_;
}
inline const ::hadoop::hdfs::qjournal::RequestInfoProto& AcceptRecoveryRequestProto::reqinfo() const {
  const ::hadoop::hdfs::qjournal::RequestInfoProto* p = reqinfo_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.reqInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::RequestInfoProto*>(
      &::hadoop::hdfs::qjournal::_RequestInfoProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* AcceptRecoveryRequestProto::release_reqinfo() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.reqInfo)
  clear_has_reqinfo();
  ::hadoop::hdfs::qjournal::RequestInfoProto* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::RequestInfoProto* AcceptRecoveryRequestProto::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::RequestInfoProto>(GetArenaNoVirtual());
    reqinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.reqInfo)
  return reqinfo_;
}
inline void AcceptRecoveryRequestProto::set_allocated_reqinfo(::hadoop::hdfs::qjournal::RequestInfoProto* reqinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqinfo_;
  }
  if (reqinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqinfo, submessage_arena);
    }
    set_has_reqinfo();
  } else {
    clear_has_reqinfo();
  }
  reqinfo_ = reqinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.reqInfo)
}

// required .hadoop.hdfs.qjournal.SegmentStateProto stateToAccept = 2;
inline bool AcceptRecoveryRequestProto::has_statetoaccept() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcceptRecoveryRequestProto::set_has_statetoaccept() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcceptRecoveryRequestProto::clear_has_statetoaccept() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcceptRecoveryRequestProto::clear_statetoaccept() {
  if (statetoaccept_ != NULL) statetoaccept_->Clear();
  clear_has_statetoaccept();
}
inline const ::hadoop::hdfs::qjournal::SegmentStateProto& AcceptRecoveryRequestProto::_internal_statetoaccept() const {
  return *statetoaccept_;
}
inline const ::hadoop::hdfs::qjournal::SegmentStateProto& AcceptRecoveryRequestProto::statetoaccept() const {
  const ::hadoop::hdfs::qjournal::SegmentStateProto* p = statetoaccept_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.stateToAccept)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::qjournal::SegmentStateProto*>(
      &::hadoop::hdfs::qjournal::_SegmentStateProto_default_instance_);
}
inline ::hadoop::hdfs::qjournal::SegmentStateProto* AcceptRecoveryRequestProto::release_statetoaccept() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.stateToAccept)
  clear_has_statetoaccept();
  ::hadoop::hdfs::qjournal::SegmentStateProto* temp = statetoaccept_;
  statetoaccept_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::qjournal::SegmentStateProto* AcceptRecoveryRequestProto::mutable_statetoaccept() {
  set_has_statetoaccept();
  if (statetoaccept_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::qjournal::SegmentStateProto>(GetArenaNoVirtual());
    statetoaccept_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.stateToAccept)
  return statetoaccept_;
}
inline void AcceptRecoveryRequestProto::set_allocated_statetoaccept(::hadoop::hdfs::qjournal::SegmentStateProto* statetoaccept) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete statetoaccept_;
  }
  if (statetoaccept) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      statetoaccept = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statetoaccept, submessage_arena);
    }
    set_has_statetoaccept();
  } else {
    clear_has_statetoaccept();
  }
  statetoaccept_ = statetoaccept;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.stateToAccept)
}

// required string fromURL = 3;
inline bool AcceptRecoveryRequestProto::has_fromurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptRecoveryRequestProto::set_has_fromurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptRecoveryRequestProto::clear_has_fromurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptRecoveryRequestProto::clear_fromurl() {
  fromurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromurl();
}
inline const ::std::string& AcceptRecoveryRequestProto::fromurl() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
  return fromurl_.GetNoArena();
}
inline void AcceptRecoveryRequestProto::set_fromurl(const ::std::string& value) {
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
}
#if LANG_CXX11
inline void AcceptRecoveryRequestProto::set_fromurl(::std::string&& value) {
  set_has_fromurl();
  fromurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
}
#endif
inline void AcceptRecoveryRequestProto::set_fromurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
}
inline void AcceptRecoveryRequestProto::set_fromurl(const char* value, size_t size) {
  set_has_fromurl();
  fromurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
}
inline ::std::string* AcceptRecoveryRequestProto::mutable_fromurl() {
  set_has_fromurl();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
  return fromurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcceptRecoveryRequestProto::release_fromurl() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
  if (!has_fromurl()) {
    return NULL;
  }
  clear_has_fromurl();
  return fromurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcceptRecoveryRequestProto::set_allocated_fromurl(::std::string* fromurl) {
  if (fromurl != NULL) {
    set_has_fromurl();
  } else {
    clear_has_fromurl();
  }
  fromurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromurl);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.qjournal.AcceptRecoveryRequestProto.fromURL)
}

// -------------------------------------------------------------------

// AcceptRecoveryResponseProto

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace qjournal
}  // namespace hdfs
}  // namespace hadoop

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_QJournalProtocol_2eproto
