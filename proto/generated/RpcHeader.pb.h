// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RpcHeader.proto

#ifndef PROTOBUF_INCLUDED_RpcHeader_2eproto
#define PROTOBUF_INCLUDED_RpcHeader_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_RpcHeader_2eproto 

namespace protobuf_RpcHeader_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_RpcHeader_2eproto
namespace hadoop {
namespace common {
class RPCCallerContextProto;
class RPCCallerContextProtoDefaultTypeInternal;
extern RPCCallerContextProtoDefaultTypeInternal _RPCCallerContextProto_default_instance_;
class RPCTraceInfoProto;
class RPCTraceInfoProtoDefaultTypeInternal;
extern RPCTraceInfoProtoDefaultTypeInternal _RPCTraceInfoProto_default_instance_;
class RpcRequestHeaderProto;
class RpcRequestHeaderProtoDefaultTypeInternal;
extern RpcRequestHeaderProtoDefaultTypeInternal _RpcRequestHeaderProto_default_instance_;
class RpcResponseHeaderProto;
class RpcResponseHeaderProtoDefaultTypeInternal;
extern RpcResponseHeaderProtoDefaultTypeInternal _RpcResponseHeaderProto_default_instance_;
class RpcSaslProto;
class RpcSaslProtoDefaultTypeInternal;
extern RpcSaslProtoDefaultTypeInternal _RpcSaslProto_default_instance_;
class RpcSaslProto_SaslAuth;
class RpcSaslProto_SaslAuthDefaultTypeInternal;
extern RpcSaslProto_SaslAuthDefaultTypeInternal _RpcSaslProto_SaslAuth_default_instance_;
}  // namespace common
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::common::RPCCallerContextProto* Arena::CreateMaybeMessage<::hadoop::common::RPCCallerContextProto>(Arena*);
template<> ::hadoop::common::RPCTraceInfoProto* Arena::CreateMaybeMessage<::hadoop::common::RPCTraceInfoProto>(Arena*);
template<> ::hadoop::common::RpcRequestHeaderProto* Arena::CreateMaybeMessage<::hadoop::common::RpcRequestHeaderProto>(Arena*);
template<> ::hadoop::common::RpcResponseHeaderProto* Arena::CreateMaybeMessage<::hadoop::common::RpcResponseHeaderProto>(Arena*);
template<> ::hadoop::common::RpcSaslProto* Arena::CreateMaybeMessage<::hadoop::common::RpcSaslProto>(Arena*);
template<> ::hadoop::common::RpcSaslProto_SaslAuth* Arena::CreateMaybeMessage<::hadoop::common::RpcSaslProto_SaslAuth>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace common {

enum RpcRequestHeaderProto_OperationProto {
  RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET = 0,
  RpcRequestHeaderProto_OperationProto_RPC_CONTINUATION_PACKET = 1,
  RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION = 2
};
bool RpcRequestHeaderProto_OperationProto_IsValid(int value);
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto_OperationProto_OperationProto_MIN = RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET;
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto_OperationProto_OperationProto_MAX = RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION;
const int RpcRequestHeaderProto_OperationProto_OperationProto_ARRAYSIZE = RpcRequestHeaderProto_OperationProto_OperationProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcRequestHeaderProto_OperationProto_descriptor();
inline const ::std::string& RpcRequestHeaderProto_OperationProto_Name(RpcRequestHeaderProto_OperationProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcRequestHeaderProto_OperationProto_descriptor(), value);
}
inline bool RpcRequestHeaderProto_OperationProto_Parse(
    const ::std::string& name, RpcRequestHeaderProto_OperationProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcRequestHeaderProto_OperationProto>(
    RpcRequestHeaderProto_OperationProto_descriptor(), name, value);
}
enum RpcResponseHeaderProto_RpcStatusProto {
  RpcResponseHeaderProto_RpcStatusProto_SUCCESS = 0,
  RpcResponseHeaderProto_RpcStatusProto_ERROR = 1,
  RpcResponseHeaderProto_RpcStatusProto_FATAL = 2
};
bool RpcResponseHeaderProto_RpcStatusProto_IsValid(int value);
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MIN = RpcResponseHeaderProto_RpcStatusProto_SUCCESS;
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX = RpcResponseHeaderProto_RpcStatusProto_FATAL;
const int RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_ARRAYSIZE = RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcStatusProto_descriptor();
inline const ::std::string& RpcResponseHeaderProto_RpcStatusProto_Name(RpcResponseHeaderProto_RpcStatusProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcResponseHeaderProto_RpcStatusProto_descriptor(), value);
}
inline bool RpcResponseHeaderProto_RpcStatusProto_Parse(
    const ::std::string& name, RpcResponseHeaderProto_RpcStatusProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcResponseHeaderProto_RpcStatusProto>(
    RpcResponseHeaderProto_RpcStatusProto_descriptor(), name, value);
}
enum RpcResponseHeaderProto_RpcErrorCodeProto {
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION = 1,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_METHOD = 2,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_PROTOCOL = 3,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_SERVER = 4,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_SERIALIZING_RESPONSE = 5,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_VERSION_MISMATCH = 6,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNKNOWN = 10,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNSUPPORTED_SERIALIZATION = 11,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_INVALID_RPC_HEADER = 12,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_DESERIALIZING_REQUEST = 13,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_VERSION_MISMATCH = 14,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED = 15
};
bool RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(int value);
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MIN = RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX = RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED;
const int RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_ARRAYSIZE = RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
inline const ::std::string& RpcResponseHeaderProto_RpcErrorCodeProto_Name(RpcResponseHeaderProto_RpcErrorCodeProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcResponseHeaderProto_RpcErrorCodeProto_descriptor(), value);
}
inline bool RpcResponseHeaderProto_RpcErrorCodeProto_Parse(
    const ::std::string& name, RpcResponseHeaderProto_RpcErrorCodeProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcResponseHeaderProto_RpcErrorCodeProto>(
    RpcResponseHeaderProto_RpcErrorCodeProto_descriptor(), name, value);
}
enum RpcSaslProto_SaslState {
  RpcSaslProto_SaslState_SUCCESS = 0,
  RpcSaslProto_SaslState_NEGOTIATE = 1,
  RpcSaslProto_SaslState_INITIATE = 2,
  RpcSaslProto_SaslState_CHALLENGE = 3,
  RpcSaslProto_SaslState_RESPONSE = 4,
  RpcSaslProto_SaslState_WRAP = 5
};
bool RpcSaslProto_SaslState_IsValid(int value);
const RpcSaslProto_SaslState RpcSaslProto_SaslState_SaslState_MIN = RpcSaslProto_SaslState_SUCCESS;
const RpcSaslProto_SaslState RpcSaslProto_SaslState_SaslState_MAX = RpcSaslProto_SaslState_WRAP;
const int RpcSaslProto_SaslState_SaslState_ARRAYSIZE = RpcSaslProto_SaslState_SaslState_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcSaslProto_SaslState_descriptor();
inline const ::std::string& RpcSaslProto_SaslState_Name(RpcSaslProto_SaslState value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcSaslProto_SaslState_descriptor(), value);
}
inline bool RpcSaslProto_SaslState_Parse(
    const ::std::string& name, RpcSaslProto_SaslState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcSaslProto_SaslState>(
    RpcSaslProto_SaslState_descriptor(), name, value);
}
enum RpcKindProto {
  RPC_BUILTIN = 0,
  RPC_WRITABLE = 1,
  RPC_PROTOCOL_BUFFER = 2
};
bool RpcKindProto_IsValid(int value);
const RpcKindProto RpcKindProto_MIN = RPC_BUILTIN;
const RpcKindProto RpcKindProto_MAX = RPC_PROTOCOL_BUFFER;
const int RpcKindProto_ARRAYSIZE = RpcKindProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcKindProto_descriptor();
inline const ::std::string& RpcKindProto_Name(RpcKindProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcKindProto_descriptor(), value);
}
inline bool RpcKindProto_Parse(
    const ::std::string& name, RpcKindProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcKindProto>(
    RpcKindProto_descriptor(), name, value);
}
// ===================================================================

class RPCTraceInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.common.RPCTraceInfoProto) */ {
 public:
  RPCTraceInfoProto();
  virtual ~RPCTraceInfoProto();

  RPCTraceInfoProto(const RPCTraceInfoProto& from);

  inline RPCTraceInfoProto& operator=(const RPCTraceInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RPCTraceInfoProto(RPCTraceInfoProto&& from) noexcept
    : RPCTraceInfoProto() {
    *this = ::std::move(from);
  }

  inline RPCTraceInfoProto& operator=(RPCTraceInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCTraceInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RPCTraceInfoProto* internal_default_instance() {
    return reinterpret_cast<const RPCTraceInfoProto*>(
               &_RPCTraceInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RPCTraceInfoProto* other);
  friend void swap(RPCTraceInfoProto& a, RPCTraceInfoProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RPCTraceInfoProto* New() const final {
    return CreateMaybeMessage<RPCTraceInfoProto>(NULL);
  }

  RPCTraceInfoProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RPCTraceInfoProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RPCTraceInfoProto& from);
  void MergeFrom(const RPCTraceInfoProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPCTraceInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes spanContext = 3;
  bool has_spancontext() const;
  void clear_spancontext();
  static const int kSpanContextFieldNumber = 3;
  const ::std::string& spancontext() const;
  void set_spancontext(const ::std::string& value);
  #if LANG_CXX11
  void set_spancontext(::std::string&& value);
  #endif
  void set_spancontext(const char* value);
  void set_spancontext(const void* value, size_t size);
  ::std::string* mutable_spancontext();
  ::std::string* release_spancontext();
  void set_allocated_spancontext(::std::string* spancontext);

  // optional int64 traceId = 1;
  bool has_traceid() const;
  void clear_traceid();
  static const int kTraceIdFieldNumber = 1;
  ::google::protobuf::int64 traceid() const;
  void set_traceid(::google::protobuf::int64 value);

  // optional int64 parentId = 2;
  bool has_parentid() const;
  void clear_parentid();
  static const int kParentIdFieldNumber = 2;
  ::google::protobuf::int64 parentid() const;
  void set_parentid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.common.RPCTraceInfoProto)
 private:
  void set_has_traceid();
  void clear_has_traceid();
  void set_has_parentid();
  void clear_has_parentid();
  void set_has_spancontext();
  void clear_has_spancontext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr spancontext_;
  ::google::protobuf::int64 traceid_;
  ::google::protobuf::int64 parentid_;
  friend struct ::protobuf_RpcHeader_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RPCCallerContextProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.common.RPCCallerContextProto) */ {
 public:
  RPCCallerContextProto();
  virtual ~RPCCallerContextProto();

  RPCCallerContextProto(const RPCCallerContextProto& from);

  inline RPCCallerContextProto& operator=(const RPCCallerContextProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RPCCallerContextProto(RPCCallerContextProto&& from) noexcept
    : RPCCallerContextProto() {
    *this = ::std::move(from);
  }

  inline RPCCallerContextProto& operator=(RPCCallerContextProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCCallerContextProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RPCCallerContextProto* internal_default_instance() {
    return reinterpret_cast<const RPCCallerContextProto*>(
               &_RPCCallerContextProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RPCCallerContextProto* other);
  friend void swap(RPCCallerContextProto& a, RPCCallerContextProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RPCCallerContextProto* New() const final {
    return CreateMaybeMessage<RPCCallerContextProto>(NULL);
  }

  RPCCallerContextProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RPCCallerContextProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RPCCallerContextProto& from);
  void MergeFrom(const RPCCallerContextProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPCCallerContextProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::std::string& context() const;
  void set_context(const ::std::string& value);
  #if LANG_CXX11
  void set_context(::std::string&& value);
  #endif
  void set_context(const char* value);
  void set_context(const char* value, size_t size);
  ::std::string* mutable_context();
  ::std::string* release_context();
  void set_allocated_context(::std::string* context);

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:hadoop.common.RPCCallerContextProto)
 private:
  void set_has_context();
  void clear_has_context();
  void set_has_signature();
  void clear_has_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr context_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct ::protobuf_RpcHeader_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcRequestHeaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.common.RpcRequestHeaderProto) */ {
 public:
  RpcRequestHeaderProto();
  virtual ~RpcRequestHeaderProto();

  RpcRequestHeaderProto(const RpcRequestHeaderProto& from);

  inline RpcRequestHeaderProto& operator=(const RpcRequestHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcRequestHeaderProto(RpcRequestHeaderProto&& from) noexcept
    : RpcRequestHeaderProto() {
    *this = ::std::move(from);
  }

  inline RpcRequestHeaderProto& operator=(RpcRequestHeaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcRequestHeaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcRequestHeaderProto* internal_default_instance() {
    return reinterpret_cast<const RpcRequestHeaderProto*>(
               &_RpcRequestHeaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RpcRequestHeaderProto* other);
  friend void swap(RpcRequestHeaderProto& a, RpcRequestHeaderProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcRequestHeaderProto* New() const final {
    return CreateMaybeMessage<RpcRequestHeaderProto>(NULL);
  }

  RpcRequestHeaderProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RpcRequestHeaderProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RpcRequestHeaderProto& from);
  void MergeFrom(const RpcRequestHeaderProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcRequestHeaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RpcRequestHeaderProto_OperationProto OperationProto;
  static const OperationProto RPC_FINAL_PACKET =
    RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET;
  static const OperationProto RPC_CONTINUATION_PACKET =
    RpcRequestHeaderProto_OperationProto_RPC_CONTINUATION_PACKET;
  static const OperationProto RPC_CLOSE_CONNECTION =
    RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION;
  static inline bool OperationProto_IsValid(int value) {
    return RpcRequestHeaderProto_OperationProto_IsValid(value);
  }
  static const OperationProto OperationProto_MIN =
    RpcRequestHeaderProto_OperationProto_OperationProto_MIN;
  static const OperationProto OperationProto_MAX =
    RpcRequestHeaderProto_OperationProto_OperationProto_MAX;
  static const int OperationProto_ARRAYSIZE =
    RpcRequestHeaderProto_OperationProto_OperationProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OperationProto_descriptor() {
    return RpcRequestHeaderProto_OperationProto_descriptor();
  }
  static inline const ::std::string& OperationProto_Name(OperationProto value) {
    return RpcRequestHeaderProto_OperationProto_Name(value);
  }
  static inline bool OperationProto_Parse(const ::std::string& name,
      OperationProto* value) {
    return RpcRequestHeaderProto_OperationProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes clientId = 4;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 4;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const void* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // optional bytes routerFederatedState = 9;
  bool has_routerfederatedstate() const;
  void clear_routerfederatedstate();
  static const int kRouterFederatedStateFieldNumber = 9;
  const ::std::string& routerfederatedstate() const;
  void set_routerfederatedstate(const ::std::string& value);
  #if LANG_CXX11
  void set_routerfederatedstate(::std::string&& value);
  #endif
  void set_routerfederatedstate(const char* value);
  void set_routerfederatedstate(const void* value, size_t size);
  ::std::string* mutable_routerfederatedstate();
  ::std::string* release_routerfederatedstate();
  void set_allocated_routerfederatedstate(::std::string* routerfederatedstate);

  // optional .hadoop.common.RPCTraceInfoProto traceInfo = 6;
  bool has_traceinfo() const;
  void clear_traceinfo();
  static const int kTraceInfoFieldNumber = 6;
  private:
  const ::hadoop::common::RPCTraceInfoProto& _internal_traceinfo() const;
  public:
  const ::hadoop::common::RPCTraceInfoProto& traceinfo() const;
  ::hadoop::common::RPCTraceInfoProto* release_traceinfo();
  ::hadoop::common::RPCTraceInfoProto* mutable_traceinfo();
  void set_allocated_traceinfo(::hadoop::common::RPCTraceInfoProto* traceinfo);

  // optional .hadoop.common.RPCCallerContextProto callerContext = 7;
  bool has_callercontext() const;
  void clear_callercontext();
  static const int kCallerContextFieldNumber = 7;
  private:
  const ::hadoop::common::RPCCallerContextProto& _internal_callercontext() const;
  public:
  const ::hadoop::common::RPCCallerContextProto& callercontext() const;
  ::hadoop::common::RPCCallerContextProto* release_callercontext();
  ::hadoop::common::RPCCallerContextProto* mutable_callercontext();
  void set_allocated_callercontext(::hadoop::common::RPCCallerContextProto* callercontext);

  // optional .hadoop.common.RpcKindProto rpcKind = 1;
  bool has_rpckind() const;
  void clear_rpckind();
  static const int kRpcKindFieldNumber = 1;
  ::hadoop::common::RpcKindProto rpckind() const;
  void set_rpckind(::hadoop::common::RpcKindProto value);

  // optional .hadoop.common.RpcRequestHeaderProto.OperationProto rpcOp = 2;
  bool has_rpcop() const;
  void clear_rpcop();
  static const int kRpcOpFieldNumber = 2;
  ::hadoop::common::RpcRequestHeaderProto_OperationProto rpcop() const;
  void set_rpcop(::hadoop::common::RpcRequestHeaderProto_OperationProto value);

  // optional int64 stateId = 8;
  bool has_stateid() const;
  void clear_stateid();
  static const int kStateIdFieldNumber = 8;
  ::google::protobuf::int64 stateid() const;
  void set_stateid(::google::protobuf::int64 value);

  // required sint32 callId = 3;
  bool has_callid() const;
  void clear_callid();
  static const int kCallIdFieldNumber = 3;
  ::google::protobuf::int32 callid() const;
  void set_callid(::google::protobuf::int32 value);

  // optional sint32 retryCount = 5 [default = -1];
  bool has_retrycount() const;
  void clear_retrycount();
  static const int kRetryCountFieldNumber = 5;
  ::google::protobuf::int32 retrycount() const;
  void set_retrycount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hadoop.common.RpcRequestHeaderProto)
 private:
  void set_has_rpckind();
  void clear_has_rpckind();
  void set_has_rpcop();
  void clear_has_rpcop();
  void set_has_callid();
  void clear_has_callid();
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_retrycount();
  void clear_has_retrycount();
  void set_has_traceinfo();
  void clear_has_traceinfo();
  void set_has_callercontext();
  void clear_has_callercontext();
  void set_has_stateid();
  void clear_has_stateid();
  void set_has_routerfederatedstate();
  void clear_has_routerfederatedstate();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr routerfederatedstate_;
  ::hadoop::common::RPCTraceInfoProto* traceinfo_;
  ::hadoop::common::RPCCallerContextProto* callercontext_;
  int rpckind_;
  int rpcop_;
  ::google::protobuf::int64 stateid_;
  ::google::protobuf::int32 callid_;
  ::google::protobuf::int32 retrycount_;
  friend struct ::protobuf_RpcHeader_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcResponseHeaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.common.RpcResponseHeaderProto) */ {
 public:
  RpcResponseHeaderProto();
  virtual ~RpcResponseHeaderProto();

  RpcResponseHeaderProto(const RpcResponseHeaderProto& from);

  inline RpcResponseHeaderProto& operator=(const RpcResponseHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcResponseHeaderProto(RpcResponseHeaderProto&& from) noexcept
    : RpcResponseHeaderProto() {
    *this = ::std::move(from);
  }

  inline RpcResponseHeaderProto& operator=(RpcResponseHeaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcResponseHeaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcResponseHeaderProto* internal_default_instance() {
    return reinterpret_cast<const RpcResponseHeaderProto*>(
               &_RpcResponseHeaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RpcResponseHeaderProto* other);
  friend void swap(RpcResponseHeaderProto& a, RpcResponseHeaderProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcResponseHeaderProto* New() const final {
    return CreateMaybeMessage<RpcResponseHeaderProto>(NULL);
  }

  RpcResponseHeaderProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RpcResponseHeaderProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RpcResponseHeaderProto& from);
  void MergeFrom(const RpcResponseHeaderProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcResponseHeaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RpcResponseHeaderProto_RpcStatusProto RpcStatusProto;
  static const RpcStatusProto SUCCESS =
    RpcResponseHeaderProto_RpcStatusProto_SUCCESS;
  static const RpcStatusProto ERROR =
    RpcResponseHeaderProto_RpcStatusProto_ERROR;
  static const RpcStatusProto FATAL =
    RpcResponseHeaderProto_RpcStatusProto_FATAL;
  static inline bool RpcStatusProto_IsValid(int value) {
    return RpcResponseHeaderProto_RpcStatusProto_IsValid(value);
  }
  static const RpcStatusProto RpcStatusProto_MIN =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MIN;
  static const RpcStatusProto RpcStatusProto_MAX =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX;
  static const int RpcStatusProto_ARRAYSIZE =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RpcStatusProto_descriptor() {
    return RpcResponseHeaderProto_RpcStatusProto_descriptor();
  }
  static inline const ::std::string& RpcStatusProto_Name(RpcStatusProto value) {
    return RpcResponseHeaderProto_RpcStatusProto_Name(value);
  }
  static inline bool RpcStatusProto_Parse(const ::std::string& name,
      RpcStatusProto* value) {
    return RpcResponseHeaderProto_RpcStatusProto_Parse(name, value);
  }

  typedef RpcResponseHeaderProto_RpcErrorCodeProto RpcErrorCodeProto;
  static const RpcErrorCodeProto ERROR_APPLICATION =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION;
  static const RpcErrorCodeProto ERROR_NO_SUCH_METHOD =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_METHOD;
  static const RpcErrorCodeProto ERROR_NO_SUCH_PROTOCOL =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_PROTOCOL;
  static const RpcErrorCodeProto ERROR_RPC_SERVER =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_SERVER;
  static const RpcErrorCodeProto ERROR_SERIALIZING_RESPONSE =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_SERIALIZING_RESPONSE;
  static const RpcErrorCodeProto ERROR_RPC_VERSION_MISMATCH =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_VERSION_MISMATCH;
  static const RpcErrorCodeProto FATAL_UNKNOWN =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNKNOWN;
  static const RpcErrorCodeProto FATAL_UNSUPPORTED_SERIALIZATION =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNSUPPORTED_SERIALIZATION;
  static const RpcErrorCodeProto FATAL_INVALID_RPC_HEADER =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_INVALID_RPC_HEADER;
  static const RpcErrorCodeProto FATAL_DESERIALIZING_REQUEST =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_DESERIALIZING_REQUEST;
  static const RpcErrorCodeProto FATAL_VERSION_MISMATCH =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_VERSION_MISMATCH;
  static const RpcErrorCodeProto FATAL_UNAUTHORIZED =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED;
  static inline bool RpcErrorCodeProto_IsValid(int value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value);
  }
  static const RpcErrorCodeProto RpcErrorCodeProto_MIN =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MIN;
  static const RpcErrorCodeProto RpcErrorCodeProto_MAX =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX;
  static const int RpcErrorCodeProto_ARRAYSIZE =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RpcErrorCodeProto_descriptor() {
    return RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
  }
  static inline const ::std::string& RpcErrorCodeProto_Name(RpcErrorCodeProto value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_Name(value);
  }
  static inline bool RpcErrorCodeProto_Parse(const ::std::string& name,
      RpcErrorCodeProto* value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string exceptionClassName = 4;
  bool has_exceptionclassname() const;
  void clear_exceptionclassname();
  static const int kExceptionClassNameFieldNumber = 4;
  const ::std::string& exceptionclassname() const;
  void set_exceptionclassname(const ::std::string& value);
  #if LANG_CXX11
  void set_exceptionclassname(::std::string&& value);
  #endif
  void set_exceptionclassname(const char* value);
  void set_exceptionclassname(const char* value, size_t size);
  ::std::string* mutable_exceptionclassname();
  ::std::string* release_exceptionclassname();
  void set_allocated_exceptionclassname(::std::string* exceptionclassname);

  // optional string errorMsg = 5;
  bool has_errormsg() const;
  void clear_errormsg();
  static const int kErrorMsgFieldNumber = 5;
  const ::std::string& errormsg() const;
  void set_errormsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errormsg(::std::string&& value);
  #endif
  void set_errormsg(const char* value);
  void set_errormsg(const char* value, size_t size);
  ::std::string* mutable_errormsg();
  ::std::string* release_errormsg();
  void set_allocated_errormsg(::std::string* errormsg);

  // optional bytes clientId = 7;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 7;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const void* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // optional bytes routerFederatedState = 10;
  bool has_routerfederatedstate() const;
  void clear_routerfederatedstate();
  static const int kRouterFederatedStateFieldNumber = 10;
  const ::std::string& routerfederatedstate() const;
  void set_routerfederatedstate(const ::std::string& value);
  #if LANG_CXX11
  void set_routerfederatedstate(::std::string&& value);
  #endif
  void set_routerfederatedstate(const char* value);
  void set_routerfederatedstate(const void* value, size_t size);
  ::std::string* mutable_routerfederatedstate();
  ::std::string* release_routerfederatedstate();
  void set_allocated_routerfederatedstate(::std::string* routerfederatedstate);

  // required uint32 callId = 1;
  bool has_callid() const;
  void clear_callid();
  static const int kCallIdFieldNumber = 1;
  ::google::protobuf::uint32 callid() const;
  void set_callid(::google::protobuf::uint32 value);

  // required .hadoop.common.RpcResponseHeaderProto.RpcStatusProto status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::hadoop::common::RpcResponseHeaderProto_RpcStatusProto status() const;
  void set_status(::hadoop::common::RpcResponseHeaderProto_RpcStatusProto value);

  // optional int64 stateId = 9;
  bool has_stateid() const;
  void clear_stateid();
  static const int kStateIdFieldNumber = 9;
  ::google::protobuf::int64 stateid() const;
  void set_stateid(::google::protobuf::int64 value);

  // optional uint32 serverIpcVersionNum = 3;
  bool has_serveripcversionnum() const;
  void clear_serveripcversionnum();
  static const int kServerIpcVersionNumFieldNumber = 3;
  ::google::protobuf::uint32 serveripcversionnum() const;
  void set_serveripcversionnum(::google::protobuf::uint32 value);

  // optional .hadoop.common.RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
  bool has_errordetail() const;
  void clear_errordetail();
  static const int kErrorDetailFieldNumber = 6;
  ::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto errordetail() const;
  void set_errordetail(::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto value);

  // optional sint32 retryCount = 8 [default = -1];
  bool has_retrycount() const;
  void clear_retrycount();
  static const int kRetryCountFieldNumber = 8;
  ::google::protobuf::int32 retrycount() const;
  void set_retrycount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hadoop.common.RpcResponseHeaderProto)
 private:
  void set_has_callid();
  void clear_has_callid();
  void set_has_status();
  void clear_has_status();
  void set_has_serveripcversionnum();
  void clear_has_serveripcversionnum();
  void set_has_exceptionclassname();
  void clear_has_exceptionclassname();
  void set_has_errormsg();
  void clear_has_errormsg();
  void set_has_errordetail();
  void clear_has_errordetail();
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_retrycount();
  void clear_has_retrycount();
  void set_has_stateid();
  void clear_has_stateid();
  void set_has_routerfederatedstate();
  void clear_has_routerfederatedstate();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr exceptionclassname_;
  ::google::protobuf::internal::ArenaStringPtr errormsg_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr routerfederatedstate_;
  ::google::protobuf::uint32 callid_;
  int status_;
  ::google::protobuf::int64 stateid_;
  ::google::protobuf::uint32 serveripcversionnum_;
  int errordetail_;
  ::google::protobuf::int32 retrycount_;
  friend struct ::protobuf_RpcHeader_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcSaslProto_SaslAuth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.common.RpcSaslProto.SaslAuth) */ {
 public:
  RpcSaslProto_SaslAuth();
  virtual ~RpcSaslProto_SaslAuth();

  RpcSaslProto_SaslAuth(const RpcSaslProto_SaslAuth& from);

  inline RpcSaslProto_SaslAuth& operator=(const RpcSaslProto_SaslAuth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcSaslProto_SaslAuth(RpcSaslProto_SaslAuth&& from) noexcept
    : RpcSaslProto_SaslAuth() {
    *this = ::std::move(from);
  }

  inline RpcSaslProto_SaslAuth& operator=(RpcSaslProto_SaslAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcSaslProto_SaslAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcSaslProto_SaslAuth* internal_default_instance() {
    return reinterpret_cast<const RpcSaslProto_SaslAuth*>(
               &_RpcSaslProto_SaslAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RpcSaslProto_SaslAuth* other);
  friend void swap(RpcSaslProto_SaslAuth& a, RpcSaslProto_SaslAuth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcSaslProto_SaslAuth* New() const final {
    return CreateMaybeMessage<RpcSaslProto_SaslAuth>(NULL);
  }

  RpcSaslProto_SaslAuth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RpcSaslProto_SaslAuth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RpcSaslProto_SaslAuth& from);
  void MergeFrom(const RpcSaslProto_SaslAuth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcSaslProto_SaslAuth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string method = 1;
  bool has_method() const;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // required string mechanism = 2;
  bool has_mechanism() const;
  void clear_mechanism();
  static const int kMechanismFieldNumber = 2;
  const ::std::string& mechanism() const;
  void set_mechanism(const ::std::string& value);
  #if LANG_CXX11
  void set_mechanism(::std::string&& value);
  #endif
  void set_mechanism(const char* value);
  void set_mechanism(const char* value, size_t size);
  ::std::string* mutable_mechanism();
  ::std::string* release_mechanism();
  void set_allocated_mechanism(::std::string* mechanism);

  // optional string protocol = 3;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol(::std::string&& value);
  #endif
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);

  // optional string serverId = 4;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIdFieldNumber = 4;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // optional bytes challenge = 5;
  bool has_challenge() const;
  void clear_challenge();
  static const int kChallengeFieldNumber = 5;
  const ::std::string& challenge() const;
  void set_challenge(const ::std::string& value);
  #if LANG_CXX11
  void set_challenge(::std::string&& value);
  #endif
  void set_challenge(const char* value);
  void set_challenge(const void* value, size_t size);
  ::std::string* mutable_challenge();
  ::std::string* release_challenge();
  void set_allocated_challenge(::std::string* challenge);

  // @@protoc_insertion_point(class_scope:hadoop.common.RpcSaslProto.SaslAuth)
 private:
  void set_has_method();
  void clear_has_method();
  void set_has_mechanism();
  void clear_has_mechanism();
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_challenge();
  void clear_has_challenge();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::google::protobuf::internal::ArenaStringPtr mechanism_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  ::google::protobuf::internal::ArenaStringPtr challenge_;
  friend struct ::protobuf_RpcHeader_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcSaslProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.common.RpcSaslProto) */ {
 public:
  RpcSaslProto();
  virtual ~RpcSaslProto();

  RpcSaslProto(const RpcSaslProto& from);

  inline RpcSaslProto& operator=(const RpcSaslProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcSaslProto(RpcSaslProto&& from) noexcept
    : RpcSaslProto() {
    *this = ::std::move(from);
  }

  inline RpcSaslProto& operator=(RpcSaslProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcSaslProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcSaslProto* internal_default_instance() {
    return reinterpret_cast<const RpcSaslProto*>(
               &_RpcSaslProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RpcSaslProto* other);
  friend void swap(RpcSaslProto& a, RpcSaslProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcSaslProto* New() const final {
    return CreateMaybeMessage<RpcSaslProto>(NULL);
  }

  RpcSaslProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RpcSaslProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RpcSaslProto& from);
  void MergeFrom(const RpcSaslProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcSaslProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RpcSaslProto_SaslAuth SaslAuth;

  typedef RpcSaslProto_SaslState SaslState;
  static const SaslState SUCCESS =
    RpcSaslProto_SaslState_SUCCESS;
  static const SaslState NEGOTIATE =
    RpcSaslProto_SaslState_NEGOTIATE;
  static const SaslState INITIATE =
    RpcSaslProto_SaslState_INITIATE;
  static const SaslState CHALLENGE =
    RpcSaslProto_SaslState_CHALLENGE;
  static const SaslState RESPONSE =
    RpcSaslProto_SaslState_RESPONSE;
  static const SaslState WRAP =
    RpcSaslProto_SaslState_WRAP;
  static inline bool SaslState_IsValid(int value) {
    return RpcSaslProto_SaslState_IsValid(value);
  }
  static const SaslState SaslState_MIN =
    RpcSaslProto_SaslState_SaslState_MIN;
  static const SaslState SaslState_MAX =
    RpcSaslProto_SaslState_SaslState_MAX;
  static const int SaslState_ARRAYSIZE =
    RpcSaslProto_SaslState_SaslState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SaslState_descriptor() {
    return RpcSaslProto_SaslState_descriptor();
  }
  static inline const ::std::string& SaslState_Name(SaslState value) {
    return RpcSaslProto_SaslState_Name(value);
  }
  static inline bool SaslState_Parse(const ::std::string& name,
      SaslState* value) {
    return RpcSaslProto_SaslState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .hadoop.common.RpcSaslProto.SaslAuth auths = 4;
  int auths_size() const;
  void clear_auths();
  static const int kAuthsFieldNumber = 4;
  ::hadoop::common::RpcSaslProto_SaslAuth* mutable_auths(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::common::RpcSaslProto_SaslAuth >*
      mutable_auths();
  const ::hadoop::common::RpcSaslProto_SaslAuth& auths(int index) const;
  ::hadoop::common::RpcSaslProto_SaslAuth* add_auths();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::common::RpcSaslProto_SaslAuth >&
      auths() const;

  // optional bytes token = 3;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // required .hadoop.common.RpcSaslProto.SaslState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::hadoop::common::RpcSaslProto_SaslState state() const;
  void set_state(::hadoop::common::RpcSaslProto_SaslState value);

  // @@protoc_insertion_point(class_scope:hadoop.common.RpcSaslProto)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_state();
  void clear_has_state();
  void set_has_token();
  void clear_has_token();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::common::RpcSaslProto_SaslAuth > auths_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::uint32 version_;
  int state_;
  friend struct ::protobuf_RpcHeader_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RPCTraceInfoProto

// optional int64 traceId = 1;
inline bool RPCTraceInfoProto::has_traceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPCTraceInfoProto::set_has_traceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPCTraceInfoProto::clear_has_traceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPCTraceInfoProto::clear_traceid() {
  traceid_ = GOOGLE_LONGLONG(0);
  clear_has_traceid();
}
inline ::google::protobuf::int64 RPCTraceInfoProto::traceid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RPCTraceInfoProto.traceId)
  return traceid_;
}
inline void RPCTraceInfoProto::set_traceid(::google::protobuf::int64 value) {
  set_has_traceid();
  traceid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RPCTraceInfoProto.traceId)
}

// optional int64 parentId = 2;
inline bool RPCTraceInfoProto::has_parentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RPCTraceInfoProto::set_has_parentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RPCTraceInfoProto::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RPCTraceInfoProto::clear_parentid() {
  parentid_ = GOOGLE_LONGLONG(0);
  clear_has_parentid();
}
inline ::google::protobuf::int64 RPCTraceInfoProto::parentid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RPCTraceInfoProto.parentId)
  return parentid_;
}
inline void RPCTraceInfoProto::set_parentid(::google::protobuf::int64 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RPCTraceInfoProto.parentId)
}

// optional bytes spanContext = 3;
inline bool RPCTraceInfoProto::has_spancontext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPCTraceInfoProto::set_has_spancontext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPCTraceInfoProto::clear_has_spancontext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPCTraceInfoProto::clear_spancontext() {
  spancontext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_spancontext();
}
inline const ::std::string& RPCTraceInfoProto::spancontext() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RPCTraceInfoProto.spanContext)
  return spancontext_.GetNoArena();
}
inline void RPCTraceInfoProto::set_spancontext(const ::std::string& value) {
  set_has_spancontext();
  spancontext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RPCTraceInfoProto.spanContext)
}
#if LANG_CXX11
inline void RPCTraceInfoProto::set_spancontext(::std::string&& value) {
  set_has_spancontext();
  spancontext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RPCTraceInfoProto.spanContext)
}
#endif
inline void RPCTraceInfoProto::set_spancontext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_spancontext();
  spancontext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RPCTraceInfoProto.spanContext)
}
inline void RPCTraceInfoProto::set_spancontext(const void* value, size_t size) {
  set_has_spancontext();
  spancontext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RPCTraceInfoProto.spanContext)
}
inline ::std::string* RPCTraceInfoProto::mutable_spancontext() {
  set_has_spancontext();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RPCTraceInfoProto.spanContext)
  return spancontext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RPCTraceInfoProto::release_spancontext() {
  // @@protoc_insertion_point(field_release:hadoop.common.RPCTraceInfoProto.spanContext)
  if (!has_spancontext()) {
    return NULL;
  }
  clear_has_spancontext();
  return spancontext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RPCTraceInfoProto::set_allocated_spancontext(::std::string* spancontext) {
  if (spancontext != NULL) {
    set_has_spancontext();
  } else {
    clear_has_spancontext();
  }
  spancontext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spancontext);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RPCTraceInfoProto.spanContext)
}

// -------------------------------------------------------------------

// RPCCallerContextProto

// required string context = 1;
inline bool RPCCallerContextProto::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPCCallerContextProto::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPCCallerContextProto::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPCCallerContextProto::clear_context() {
  context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_context();
}
inline const ::std::string& RPCCallerContextProto::context() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RPCCallerContextProto.context)
  return context_.GetNoArena();
}
inline void RPCCallerContextProto::set_context(const ::std::string& value) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RPCCallerContextProto.context)
}
#if LANG_CXX11
inline void RPCCallerContextProto::set_context(::std::string&& value) {
  set_has_context();
  context_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RPCCallerContextProto.context)
}
#endif
inline void RPCCallerContextProto::set_context(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RPCCallerContextProto.context)
}
inline void RPCCallerContextProto::set_context(const char* value, size_t size) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RPCCallerContextProto.context)
}
inline ::std::string* RPCCallerContextProto::mutable_context() {
  set_has_context();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RPCCallerContextProto.context)
  return context_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RPCCallerContextProto::release_context() {
  // @@protoc_insertion_point(field_release:hadoop.common.RPCCallerContextProto.context)
  if (!has_context()) {
    return NULL;
  }
  clear_has_context();
  return context_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RPCCallerContextProto::set_allocated_context(::std::string* context) {
  if (context != NULL) {
    set_has_context();
  } else {
    clear_has_context();
  }
  context_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), context);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RPCCallerContextProto.context)
}

// optional bytes signature = 2;
inline bool RPCCallerContextProto::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPCCallerContextProto::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPCCallerContextProto::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPCCallerContextProto::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& RPCCallerContextProto::signature() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RPCCallerContextProto.signature)
  return signature_.GetNoArena();
}
inline void RPCCallerContextProto::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RPCCallerContextProto.signature)
}
#if LANG_CXX11
inline void RPCCallerContextProto::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RPCCallerContextProto.signature)
}
#endif
inline void RPCCallerContextProto::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RPCCallerContextProto.signature)
}
inline void RPCCallerContextProto::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RPCCallerContextProto.signature)
}
inline ::std::string* RPCCallerContextProto::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RPCCallerContextProto.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RPCCallerContextProto::release_signature() {
  // @@protoc_insertion_point(field_release:hadoop.common.RPCCallerContextProto.signature)
  if (!has_signature()) {
    return NULL;
  }
  clear_has_signature();
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RPCCallerContextProto::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RPCCallerContextProto.signature)
}

// -------------------------------------------------------------------

// RpcRequestHeaderProto

// optional .hadoop.common.RpcKindProto rpcKind = 1;
inline bool RpcRequestHeaderProto::has_rpckind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpcRequestHeaderProto::set_has_rpckind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpcRequestHeaderProto::clear_has_rpckind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpcRequestHeaderProto::clear_rpckind() {
  rpckind_ = 0;
  clear_has_rpckind();
}
inline ::hadoop::common::RpcKindProto RpcRequestHeaderProto::rpckind() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.rpcKind)
  return static_cast< ::hadoop::common::RpcKindProto >(rpckind_);
}
inline void RpcRequestHeaderProto::set_rpckind(::hadoop::common::RpcKindProto value) {
  assert(::hadoop::common::RpcKindProto_IsValid(value));
  set_has_rpckind();
  rpckind_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcRequestHeaderProto.rpcKind)
}

// optional .hadoop.common.RpcRequestHeaderProto.OperationProto rpcOp = 2;
inline bool RpcRequestHeaderProto::has_rpcop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpcRequestHeaderProto::set_has_rpcop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpcRequestHeaderProto::clear_has_rpcop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpcRequestHeaderProto::clear_rpcop() {
  rpcop_ = 0;
  clear_has_rpcop();
}
inline ::hadoop::common::RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::rpcop() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.rpcOp)
  return static_cast< ::hadoop::common::RpcRequestHeaderProto_OperationProto >(rpcop_);
}
inline void RpcRequestHeaderProto::set_rpcop(::hadoop::common::RpcRequestHeaderProto_OperationProto value) {
  assert(::hadoop::common::RpcRequestHeaderProto_OperationProto_IsValid(value));
  set_has_rpcop();
  rpcop_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcRequestHeaderProto.rpcOp)
}

// required sint32 callId = 3;
inline bool RpcRequestHeaderProto::has_callid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpcRequestHeaderProto::set_has_callid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpcRequestHeaderProto::clear_has_callid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpcRequestHeaderProto::clear_callid() {
  callid_ = 0;
  clear_has_callid();
}
inline ::google::protobuf::int32 RpcRequestHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.callId)
  return callid_;
}
inline void RpcRequestHeaderProto::set_callid(::google::protobuf::int32 value) {
  set_has_callid();
  callid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcRequestHeaderProto.callId)
}

// required bytes clientId = 4;
inline bool RpcRequestHeaderProto::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcRequestHeaderProto::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcRequestHeaderProto::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcRequestHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& RpcRequestHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.clientId)
  return clientid_.GetNoArena();
}
inline void RpcRequestHeaderProto::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcRequestHeaderProto.clientId)
}
#if LANG_CXX11
inline void RpcRequestHeaderProto::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcRequestHeaderProto.clientId)
}
#endif
inline void RpcRequestHeaderProto::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcRequestHeaderProto.clientId)
}
inline void RpcRequestHeaderProto::set_clientid(const void* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcRequestHeaderProto.clientId)
}
inline ::std::string* RpcRequestHeaderProto::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcRequestHeaderProto.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcRequestHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcRequestHeaderProto.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequestHeaderProto::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcRequestHeaderProto.clientId)
}

// optional sint32 retryCount = 5 [default = -1];
inline bool RpcRequestHeaderProto::has_retrycount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpcRequestHeaderProto::set_has_retrycount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpcRequestHeaderProto::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpcRequestHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  clear_has_retrycount();
}
inline ::google::protobuf::int32 RpcRequestHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.retryCount)
  return retrycount_;
}
inline void RpcRequestHeaderProto::set_retrycount(::google::protobuf::int32 value) {
  set_has_retrycount();
  retrycount_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcRequestHeaderProto.retryCount)
}

// optional .hadoop.common.RPCTraceInfoProto traceInfo = 6;
inline bool RpcRequestHeaderProto::has_traceinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcRequestHeaderProto::set_has_traceinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcRequestHeaderProto::clear_has_traceinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcRequestHeaderProto::clear_traceinfo() {
  if (traceinfo_ != NULL) traceinfo_->Clear();
  clear_has_traceinfo();
}
inline const ::hadoop::common::RPCTraceInfoProto& RpcRequestHeaderProto::_internal_traceinfo() const {
  return *traceinfo_;
}
inline const ::hadoop::common::RPCTraceInfoProto& RpcRequestHeaderProto::traceinfo() const {
  const ::hadoop::common::RPCTraceInfoProto* p = traceinfo_;
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.traceInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::common::RPCTraceInfoProto*>(
      &::hadoop::common::_RPCTraceInfoProto_default_instance_);
}
inline ::hadoop::common::RPCTraceInfoProto* RpcRequestHeaderProto::release_traceinfo() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcRequestHeaderProto.traceInfo)
  clear_has_traceinfo();
  ::hadoop::common::RPCTraceInfoProto* temp = traceinfo_;
  traceinfo_ = NULL;
  return temp;
}
inline ::hadoop::common::RPCTraceInfoProto* RpcRequestHeaderProto::mutable_traceinfo() {
  set_has_traceinfo();
  if (traceinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::common::RPCTraceInfoProto>(GetArenaNoVirtual());
    traceinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcRequestHeaderProto.traceInfo)
  return traceinfo_;
}
inline void RpcRequestHeaderProto::set_allocated_traceinfo(::hadoop::common::RPCTraceInfoProto* traceinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete traceinfo_;
  }
  if (traceinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traceinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traceinfo, submessage_arena);
    }
    set_has_traceinfo();
  } else {
    clear_has_traceinfo();
  }
  traceinfo_ = traceinfo;
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcRequestHeaderProto.traceInfo)
}

// optional .hadoop.common.RPCCallerContextProto callerContext = 7;
inline bool RpcRequestHeaderProto::has_callercontext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcRequestHeaderProto::set_has_callercontext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcRequestHeaderProto::clear_has_callercontext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcRequestHeaderProto::clear_callercontext() {
  if (callercontext_ != NULL) callercontext_->Clear();
  clear_has_callercontext();
}
inline const ::hadoop::common::RPCCallerContextProto& RpcRequestHeaderProto::_internal_callercontext() const {
  return *callercontext_;
}
inline const ::hadoop::common::RPCCallerContextProto& RpcRequestHeaderProto::callercontext() const {
  const ::hadoop::common::RPCCallerContextProto* p = callercontext_;
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.callerContext)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::common::RPCCallerContextProto*>(
      &::hadoop::common::_RPCCallerContextProto_default_instance_);
}
inline ::hadoop::common::RPCCallerContextProto* RpcRequestHeaderProto::release_callercontext() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcRequestHeaderProto.callerContext)
  clear_has_callercontext();
  ::hadoop::common::RPCCallerContextProto* temp = callercontext_;
  callercontext_ = NULL;
  return temp;
}
inline ::hadoop::common::RPCCallerContextProto* RpcRequestHeaderProto::mutable_callercontext() {
  set_has_callercontext();
  if (callercontext_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::common::RPCCallerContextProto>(GetArenaNoVirtual());
    callercontext_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcRequestHeaderProto.callerContext)
  return callercontext_;
}
inline void RpcRequestHeaderProto::set_allocated_callercontext(::hadoop::common::RPCCallerContextProto* callercontext) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete callercontext_;
  }
  if (callercontext) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      callercontext = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, callercontext, submessage_arena);
    }
    set_has_callercontext();
  } else {
    clear_has_callercontext();
  }
  callercontext_ = callercontext;
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcRequestHeaderProto.callerContext)
}

// optional int64 stateId = 8;
inline bool RpcRequestHeaderProto::has_stateid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpcRequestHeaderProto::set_has_stateid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpcRequestHeaderProto::clear_has_stateid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpcRequestHeaderProto::clear_stateid() {
  stateid_ = GOOGLE_LONGLONG(0);
  clear_has_stateid();
}
inline ::google::protobuf::int64 RpcRequestHeaderProto::stateid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.stateId)
  return stateid_;
}
inline void RpcRequestHeaderProto::set_stateid(::google::protobuf::int64 value) {
  set_has_stateid();
  stateid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcRequestHeaderProto.stateId)
}

// optional bytes routerFederatedState = 9;
inline bool RpcRequestHeaderProto::has_routerfederatedstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcRequestHeaderProto::set_has_routerfederatedstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcRequestHeaderProto::clear_has_routerfederatedstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcRequestHeaderProto::clear_routerfederatedstate() {
  routerfederatedstate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_routerfederatedstate();
}
inline const ::std::string& RpcRequestHeaderProto::routerfederatedstate() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
  return routerfederatedstate_.GetNoArena();
}
inline void RpcRequestHeaderProto::set_routerfederatedstate(const ::std::string& value) {
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
}
#if LANG_CXX11
inline void RpcRequestHeaderProto::set_routerfederatedstate(::std::string&& value) {
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
}
#endif
inline void RpcRequestHeaderProto::set_routerfederatedstate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
}
inline void RpcRequestHeaderProto::set_routerfederatedstate(const void* value, size_t size) {
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
}
inline ::std::string* RpcRequestHeaderProto::mutable_routerfederatedstate() {
  set_has_routerfederatedstate();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
  return routerfederatedstate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcRequestHeaderProto::release_routerfederatedstate() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
  if (!has_routerfederatedstate()) {
    return NULL;
  }
  clear_has_routerfederatedstate();
  return routerfederatedstate_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequestHeaderProto::set_allocated_routerfederatedstate(::std::string* routerfederatedstate) {
  if (routerfederatedstate != NULL) {
    set_has_routerfederatedstate();
  } else {
    clear_has_routerfederatedstate();
  }
  routerfederatedstate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), routerfederatedstate);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcRequestHeaderProto.routerFederatedState)
}

// -------------------------------------------------------------------

// RpcResponseHeaderProto

// required uint32 callId = 1;
inline bool RpcResponseHeaderProto::has_callid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpcResponseHeaderProto::set_has_callid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpcResponseHeaderProto::clear_has_callid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpcResponseHeaderProto::clear_callid() {
  callid_ = 0u;
  clear_has_callid();
}
inline ::google::protobuf::uint32 RpcResponseHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.callId)
  return callid_;
}
inline void RpcResponseHeaderProto::set_callid(::google::protobuf::uint32 value) {
  set_has_callid();
  callid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.callId)
}

// required .hadoop.common.RpcResponseHeaderProto.RpcStatusProto status = 2;
inline bool RpcResponseHeaderProto::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpcResponseHeaderProto::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpcResponseHeaderProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpcResponseHeaderProto::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::hadoop::common::RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::status() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.status)
  return static_cast< ::hadoop::common::RpcResponseHeaderProto_RpcStatusProto >(status_);
}
inline void RpcResponseHeaderProto::set_status(::hadoop::common::RpcResponseHeaderProto_RpcStatusProto value) {
  assert(::hadoop::common::RpcResponseHeaderProto_RpcStatusProto_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.status)
}

// optional uint32 serverIpcVersionNum = 3;
inline bool RpcResponseHeaderProto::has_serveripcversionnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpcResponseHeaderProto::set_has_serveripcversionnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpcResponseHeaderProto::clear_has_serveripcversionnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpcResponseHeaderProto::clear_serveripcversionnum() {
  serveripcversionnum_ = 0u;
  clear_has_serveripcversionnum();
}
inline ::google::protobuf::uint32 RpcResponseHeaderProto::serveripcversionnum() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.serverIpcVersionNum)
  return serveripcversionnum_;
}
inline void RpcResponseHeaderProto::set_serveripcversionnum(::google::protobuf::uint32 value) {
  set_has_serveripcversionnum();
  serveripcversionnum_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.serverIpcVersionNum)
}

// optional string exceptionClassName = 4;
inline bool RpcResponseHeaderProto::has_exceptionclassname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcResponseHeaderProto::set_has_exceptionclassname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcResponseHeaderProto::clear_has_exceptionclassname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcResponseHeaderProto::clear_exceptionclassname() {
  exceptionclassname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exceptionclassname();
}
inline const ::std::string& RpcResponseHeaderProto::exceptionclassname() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
  return exceptionclassname_.GetNoArena();
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const ::std::string& value) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
}
#if LANG_CXX11
inline void RpcResponseHeaderProto::set_exceptionclassname(::std::string&& value) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
}
#endif
inline void RpcResponseHeaderProto::set_exceptionclassname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const char* value, size_t size) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
}
inline ::std::string* RpcResponseHeaderProto::mutable_exceptionclassname() {
  set_has_exceptionclassname();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
  return exceptionclassname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponseHeaderProto::release_exceptionclassname() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
  if (!has_exceptionclassname()) {
    return NULL;
  }
  clear_has_exceptionclassname();
  return exceptionclassname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_exceptionclassname(::std::string* exceptionclassname) {
  if (exceptionclassname != NULL) {
    set_has_exceptionclassname();
  } else {
    clear_has_exceptionclassname();
  }
  exceptionclassname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exceptionclassname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcResponseHeaderProto.exceptionClassName)
}

// optional string errorMsg = 5;
inline bool RpcResponseHeaderProto::has_errormsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcResponseHeaderProto::set_has_errormsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcResponseHeaderProto::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcResponseHeaderProto::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormsg();
}
inline const ::std::string& RpcResponseHeaderProto::errormsg() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.errorMsg)
  return errormsg_.GetNoArena();
}
inline void RpcResponseHeaderProto::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.errorMsg)
}
#if LANG_CXX11
inline void RpcResponseHeaderProto::set_errormsg(::std::string&& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcResponseHeaderProto.errorMsg)
}
#endif
inline void RpcResponseHeaderProto::set_errormsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcResponseHeaderProto.errorMsg)
}
inline void RpcResponseHeaderProto::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcResponseHeaderProto.errorMsg)
}
inline ::std::string* RpcResponseHeaderProto::mutable_errormsg() {
  set_has_errormsg();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcResponseHeaderProto.errorMsg)
  return errormsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponseHeaderProto::release_errormsg() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcResponseHeaderProto.errorMsg)
  if (!has_errormsg()) {
    return NULL;
  }
  clear_has_errormsg();
  return errormsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg != NULL) {
    set_has_errormsg();
  } else {
    clear_has_errormsg();
  }
  errormsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcResponseHeaderProto.errorMsg)
}

// optional .hadoop.common.RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
inline bool RpcResponseHeaderProto::has_errordetail() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpcResponseHeaderProto::set_has_errordetail() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpcResponseHeaderProto::clear_has_errordetail() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpcResponseHeaderProto::clear_errordetail() {
  errordetail_ = 1;
  clear_has_errordetail();
}
inline ::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::errordetail() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.errorDetail)
  return static_cast< ::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto >(errordetail_);
}
inline void RpcResponseHeaderProto::set_errordetail(::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto value) {
  assert(::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value));
  set_has_errordetail();
  errordetail_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.errorDetail)
}

// optional bytes clientId = 7;
inline bool RpcResponseHeaderProto::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcResponseHeaderProto::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcResponseHeaderProto::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcResponseHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& RpcResponseHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.clientId)
  return clientid_.GetNoArena();
}
inline void RpcResponseHeaderProto::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.clientId)
}
#if LANG_CXX11
inline void RpcResponseHeaderProto::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcResponseHeaderProto.clientId)
}
#endif
inline void RpcResponseHeaderProto::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcResponseHeaderProto.clientId)
}
inline void RpcResponseHeaderProto::set_clientid(const void* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcResponseHeaderProto.clientId)
}
inline ::std::string* RpcResponseHeaderProto::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcResponseHeaderProto.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponseHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcResponseHeaderProto.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcResponseHeaderProto.clientId)
}

// optional sint32 retryCount = 8 [default = -1];
inline bool RpcResponseHeaderProto::has_retrycount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpcResponseHeaderProto::set_has_retrycount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpcResponseHeaderProto::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpcResponseHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  clear_has_retrycount();
}
inline ::google::protobuf::int32 RpcResponseHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.retryCount)
  return retrycount_;
}
inline void RpcResponseHeaderProto::set_retrycount(::google::protobuf::int32 value) {
  set_has_retrycount();
  retrycount_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.retryCount)
}

// optional int64 stateId = 9;
inline bool RpcResponseHeaderProto::has_stateid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpcResponseHeaderProto::set_has_stateid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpcResponseHeaderProto::clear_has_stateid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpcResponseHeaderProto::clear_stateid() {
  stateid_ = GOOGLE_LONGLONG(0);
  clear_has_stateid();
}
inline ::google::protobuf::int64 RpcResponseHeaderProto::stateid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.stateId)
  return stateid_;
}
inline void RpcResponseHeaderProto::set_stateid(::google::protobuf::int64 value) {
  set_has_stateid();
  stateid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.stateId)
}

// optional bytes routerFederatedState = 10;
inline bool RpcResponseHeaderProto::has_routerfederatedstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcResponseHeaderProto::set_has_routerfederatedstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcResponseHeaderProto::clear_has_routerfederatedstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcResponseHeaderProto::clear_routerfederatedstate() {
  routerfederatedstate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_routerfederatedstate();
}
inline const ::std::string& RpcResponseHeaderProto::routerfederatedstate() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
  return routerfederatedstate_.GetNoArena();
}
inline void RpcResponseHeaderProto::set_routerfederatedstate(const ::std::string& value) {
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
}
#if LANG_CXX11
inline void RpcResponseHeaderProto::set_routerfederatedstate(::std::string&& value) {
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
}
#endif
inline void RpcResponseHeaderProto::set_routerfederatedstate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
}
inline void RpcResponseHeaderProto::set_routerfederatedstate(const void* value, size_t size) {
  set_has_routerfederatedstate();
  routerfederatedstate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
}
inline ::std::string* RpcResponseHeaderProto::mutable_routerfederatedstate() {
  set_has_routerfederatedstate();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
  return routerfederatedstate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponseHeaderProto::release_routerfederatedstate() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
  if (!has_routerfederatedstate()) {
    return NULL;
  }
  clear_has_routerfederatedstate();
  return routerfederatedstate_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_routerfederatedstate(::std::string* routerfederatedstate) {
  if (routerfederatedstate != NULL) {
    set_has_routerfederatedstate();
  } else {
    clear_has_routerfederatedstate();
  }
  routerfederatedstate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), routerfederatedstate);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcResponseHeaderProto.routerFederatedState)
}

// -------------------------------------------------------------------

// RpcSaslProto_SaslAuth

// required string method = 1;
inline bool RpcSaslProto_SaslAuth::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcSaslProto_SaslAuth::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcSaslProto_SaslAuth::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcSaslProto_SaslAuth::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_method();
}
inline const ::std::string& RpcSaslProto_SaslAuth::method() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.SaslAuth.method)
  return method_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::set_method(const ::std::string& value) {
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.SaslAuth.method)
}
#if LANG_CXX11
inline void RpcSaslProto_SaslAuth::set_method(::std::string&& value) {
  set_has_method();
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcSaslProto.SaslAuth.method)
}
#endif
inline void RpcSaslProto_SaslAuth::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcSaslProto.SaslAuth.method)
}
inline void RpcSaslProto_SaslAuth::set_method(const char* value, size_t size) {
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcSaslProto.SaslAuth.method)
}
inline ::std::string* RpcSaslProto_SaslAuth::mutable_method() {
  set_has_method();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcSaslProto.SaslAuth.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcSaslProto_SaslAuth::release_method() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcSaslProto.SaslAuth.method)
  if (!has_method()) {
    return NULL;
  }
  clear_has_method();
  return method_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    set_has_method();
  } else {
    clear_has_method();
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcSaslProto.SaslAuth.method)
}

// required string mechanism = 2;
inline bool RpcSaslProto_SaslAuth::has_mechanism() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcSaslProto_SaslAuth::set_has_mechanism() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcSaslProto_SaslAuth::clear_has_mechanism() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcSaslProto_SaslAuth::clear_mechanism() {
  mechanism_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mechanism();
}
inline const ::std::string& RpcSaslProto_SaslAuth::mechanism() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
  return mechanism_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::set_mechanism(const ::std::string& value) {
  set_has_mechanism();
  mechanism_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
}
#if LANG_CXX11
inline void RpcSaslProto_SaslAuth::set_mechanism(::std::string&& value) {
  set_has_mechanism();
  mechanism_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
}
#endif
inline void RpcSaslProto_SaslAuth::set_mechanism(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mechanism();
  mechanism_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
}
inline void RpcSaslProto_SaslAuth::set_mechanism(const char* value, size_t size) {
  set_has_mechanism();
  mechanism_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
}
inline ::std::string* RpcSaslProto_SaslAuth::mutable_mechanism() {
  set_has_mechanism();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
  return mechanism_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcSaslProto_SaslAuth::release_mechanism() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
  if (!has_mechanism()) {
    return NULL;
  }
  clear_has_mechanism();
  return mechanism_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_mechanism(::std::string* mechanism) {
  if (mechanism != NULL) {
    set_has_mechanism();
  } else {
    clear_has_mechanism();
  }
  mechanism_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mechanism);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcSaslProto.SaslAuth.mechanism)
}

// optional string protocol = 3;
inline bool RpcSaslProto_SaslAuth::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcSaslProto_SaslAuth::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcSaslProto_SaslAuth::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcSaslProto_SaslAuth::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol();
}
inline const ::std::string& RpcSaslProto_SaslAuth::protocol() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.SaslAuth.protocol)
  return protocol_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.SaslAuth.protocol)
}
#if LANG_CXX11
inline void RpcSaslProto_SaslAuth::set_protocol(::std::string&& value) {
  set_has_protocol();
  protocol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcSaslProto.SaslAuth.protocol)
}
#endif
inline void RpcSaslProto_SaslAuth::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcSaslProto.SaslAuth.protocol)
}
inline void RpcSaslProto_SaslAuth::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcSaslProto.SaslAuth.protocol)
}
inline ::std::string* RpcSaslProto_SaslAuth::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcSaslProto.SaslAuth.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcSaslProto_SaslAuth::release_protocol() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcSaslProto.SaslAuth.protocol)
  if (!has_protocol()) {
    return NULL;
  }
  clear_has_protocol();
  return protocol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcSaslProto.SaslAuth.protocol)
}

// optional string serverId = 4;
inline bool RpcSaslProto_SaslAuth::has_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcSaslProto_SaslAuth::set_has_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcSaslProto_SaslAuth::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcSaslProto_SaslAuth::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& RpcSaslProto_SaslAuth::serverid() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.SaslAuth.serverId)
  return serverid_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.SaslAuth.serverId)
}
#if LANG_CXX11
inline void RpcSaslProto_SaslAuth::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcSaslProto.SaslAuth.serverId)
}
#endif
inline void RpcSaslProto_SaslAuth::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcSaslProto.SaslAuth.serverId)
}
inline void RpcSaslProto_SaslAuth::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcSaslProto.SaslAuth.serverId)
}
inline ::std::string* RpcSaslProto_SaslAuth::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcSaslProto.SaslAuth.serverId)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcSaslProto_SaslAuth::release_serverid() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcSaslProto.SaslAuth.serverId)
  if (!has_serverid()) {
    return NULL;
  }
  clear_has_serverid();
  return serverid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcSaslProto.SaslAuth.serverId)
}

// optional bytes challenge = 5;
inline bool RpcSaslProto_SaslAuth::has_challenge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpcSaslProto_SaslAuth::set_has_challenge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpcSaslProto_SaslAuth::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpcSaslProto_SaslAuth::clear_challenge() {
  challenge_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_challenge();
}
inline const ::std::string& RpcSaslProto_SaslAuth::challenge() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.SaslAuth.challenge)
  return challenge_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::set_challenge(const ::std::string& value) {
  set_has_challenge();
  challenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.SaslAuth.challenge)
}
#if LANG_CXX11
inline void RpcSaslProto_SaslAuth::set_challenge(::std::string&& value) {
  set_has_challenge();
  challenge_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcSaslProto.SaslAuth.challenge)
}
#endif
inline void RpcSaslProto_SaslAuth::set_challenge(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_challenge();
  challenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcSaslProto.SaslAuth.challenge)
}
inline void RpcSaslProto_SaslAuth::set_challenge(const void* value, size_t size) {
  set_has_challenge();
  challenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcSaslProto.SaslAuth.challenge)
}
inline ::std::string* RpcSaslProto_SaslAuth::mutable_challenge() {
  set_has_challenge();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcSaslProto.SaslAuth.challenge)
  return challenge_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcSaslProto_SaslAuth::release_challenge() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcSaslProto.SaslAuth.challenge)
  if (!has_challenge()) {
    return NULL;
  }
  clear_has_challenge();
  return challenge_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_challenge(::std::string* challenge) {
  if (challenge != NULL) {
    set_has_challenge();
  } else {
    clear_has_challenge();
  }
  challenge_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), challenge);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcSaslProto.SaslAuth.challenge)
}

// -------------------------------------------------------------------

// RpcSaslProto

// optional uint32 version = 1;
inline bool RpcSaslProto::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcSaslProto::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcSaslProto::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcSaslProto::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 RpcSaslProto::version() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.version)
  return version_;
}
inline void RpcSaslProto::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.version)
}

// required .hadoop.common.RpcSaslProto.SaslState state = 2;
inline bool RpcSaslProto::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcSaslProto::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcSaslProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcSaslProto::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::hadoop::common::RpcSaslProto_SaslState RpcSaslProto::state() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.state)
  return static_cast< ::hadoop::common::RpcSaslProto_SaslState >(state_);
}
inline void RpcSaslProto::set_state(::hadoop::common::RpcSaslProto_SaslState value) {
  assert(::hadoop::common::RpcSaslProto_SaslState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.state)
}

// optional bytes token = 3;
inline bool RpcSaslProto::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcSaslProto::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcSaslProto::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcSaslProto::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& RpcSaslProto::token() const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.token)
  return token_.GetNoArena();
}
inline void RpcSaslProto::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.common.RpcSaslProto.token)
}
#if LANG_CXX11
inline void RpcSaslProto::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.common.RpcSaslProto.token)
}
#endif
inline void RpcSaslProto::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.common.RpcSaslProto.token)
}
inline void RpcSaslProto::set_token(const void* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.common.RpcSaslProto.token)
}
inline ::std::string* RpcSaslProto::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcSaslProto.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcSaslProto::release_token() {
  // @@protoc_insertion_point(field_release:hadoop.common.RpcSaslProto.token)
  if (!has_token()) {
    return NULL;
  }
  clear_has_token();
  return token_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:hadoop.common.RpcSaslProto.token)
}

// repeated .hadoop.common.RpcSaslProto.SaslAuth auths = 4;
inline int RpcSaslProto::auths_size() const {
  return auths_.size();
}
inline void RpcSaslProto::clear_auths() {
  auths_.Clear();
}
inline ::hadoop::common::RpcSaslProto_SaslAuth* RpcSaslProto::mutable_auths(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.common.RpcSaslProto.auths)
  return auths_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::common::RpcSaslProto_SaslAuth >*
RpcSaslProto::mutable_auths() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.common.RpcSaslProto.auths)
  return &auths_;
}
inline const ::hadoop::common::RpcSaslProto_SaslAuth& RpcSaslProto::auths(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.common.RpcSaslProto.auths)
  return auths_.Get(index);
}
inline ::hadoop::common::RpcSaslProto_SaslAuth* RpcSaslProto::add_auths() {
  // @@protoc_insertion_point(field_add:hadoop.common.RpcSaslProto.auths)
  return auths_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::common::RpcSaslProto_SaslAuth >&
RpcSaslProto::auths() const {
  // @@protoc_insertion_point(field_list:hadoop.common.RpcSaslProto.auths)
  return auths_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace hadoop

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hadoop::common::RpcRequestHeaderProto_OperationProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::common::RpcRequestHeaderProto_OperationProto>() {
  return ::hadoop::common::RpcRequestHeaderProto_OperationProto_descriptor();
}
template <> struct is_proto_enum< ::hadoop::common::RpcResponseHeaderProto_RpcStatusProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::common::RpcResponseHeaderProto_RpcStatusProto>() {
  return ::hadoop::common::RpcResponseHeaderProto_RpcStatusProto_descriptor();
}
template <> struct is_proto_enum< ::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto>() {
  return ::hadoop::common::RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
}
template <> struct is_proto_enum< ::hadoop::common::RpcSaslProto_SaslState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::common::RpcSaslProto_SaslState>() {
  return ::hadoop::common::RpcSaslProto_SaslState_descriptor();
}
template <> struct is_proto_enum< ::hadoop::common::RpcKindProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::common::RpcKindProto>() {
  return ::hadoop::common::RpcKindProto_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_RpcHeader_2eproto
