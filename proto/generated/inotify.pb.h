// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: inotify.proto

#ifndef PROTOBUF_INCLUDED_inotify_2eproto
#define PROTOBUF_INCLUDED_inotify_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "acl.pb.h"
#include "xattr.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_inotify_2eproto 

namespace protobuf_inotify_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_inotify_2eproto
namespace hadoop {
namespace hdfs {
class AppendEventProto;
class AppendEventProtoDefaultTypeInternal;
extern AppendEventProtoDefaultTypeInternal _AppendEventProto_default_instance_;
class CloseEventProto;
class CloseEventProtoDefaultTypeInternal;
extern CloseEventProtoDefaultTypeInternal _CloseEventProto_default_instance_;
class CreateEventProto;
class CreateEventProtoDefaultTypeInternal;
extern CreateEventProtoDefaultTypeInternal _CreateEventProto_default_instance_;
class EventBatchProto;
class EventBatchProtoDefaultTypeInternal;
extern EventBatchProtoDefaultTypeInternal _EventBatchProto_default_instance_;
class EventProto;
class EventProtoDefaultTypeInternal;
extern EventProtoDefaultTypeInternal _EventProto_default_instance_;
class EventsListProto;
class EventsListProtoDefaultTypeInternal;
extern EventsListProtoDefaultTypeInternal _EventsListProto_default_instance_;
class MetadataUpdateEventProto;
class MetadataUpdateEventProtoDefaultTypeInternal;
extern MetadataUpdateEventProtoDefaultTypeInternal _MetadataUpdateEventProto_default_instance_;
class RenameEventProto;
class RenameEventProtoDefaultTypeInternal;
extern RenameEventProtoDefaultTypeInternal _RenameEventProto_default_instance_;
class TruncateEventProto;
class TruncateEventProtoDefaultTypeInternal;
extern TruncateEventProtoDefaultTypeInternal _TruncateEventProto_default_instance_;
class UnlinkEventProto;
class UnlinkEventProtoDefaultTypeInternal;
extern UnlinkEventProtoDefaultTypeInternal _UnlinkEventProto_default_instance_;
}  // namespace hdfs
}  // namespace hadoop
namespace google {
namespace protobuf {
template<> ::hadoop::hdfs::AppendEventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::AppendEventProto>(Arena*);
template<> ::hadoop::hdfs::CloseEventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::CloseEventProto>(Arena*);
template<> ::hadoop::hdfs::CreateEventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::CreateEventProto>(Arena*);
template<> ::hadoop::hdfs::EventBatchProto* Arena::CreateMaybeMessage<::hadoop::hdfs::EventBatchProto>(Arena*);
template<> ::hadoop::hdfs::EventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::EventProto>(Arena*);
template<> ::hadoop::hdfs::EventsListProto* Arena::CreateMaybeMessage<::hadoop::hdfs::EventsListProto>(Arena*);
template<> ::hadoop::hdfs::MetadataUpdateEventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::MetadataUpdateEventProto>(Arena*);
template<> ::hadoop::hdfs::RenameEventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::RenameEventProto>(Arena*);
template<> ::hadoop::hdfs::TruncateEventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::TruncateEventProto>(Arena*);
template<> ::hadoop::hdfs::UnlinkEventProto* Arena::CreateMaybeMessage<::hadoop::hdfs::UnlinkEventProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hadoop {
namespace hdfs {

enum EventType {
  EVENT_CREATE = 0,
  EVENT_CLOSE = 1,
  EVENT_APPEND = 2,
  EVENT_RENAME = 3,
  EVENT_METADATA = 4,
  EVENT_UNLINK = 5,
  EVENT_TRUNCATE = 6
};
bool EventType_IsValid(int value);
const EventType EventType_MIN = EVENT_CREATE;
const EventType EventType_MAX = EVENT_TRUNCATE;
const int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventType_descriptor();
inline const ::std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventType_descriptor(), value);
}
inline bool EventType_Parse(
    const ::std::string& name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
enum INodeType {
  I_TYPE_FILE = 0,
  I_TYPE_DIRECTORY = 1,
  I_TYPE_SYMLINK = 2
};
bool INodeType_IsValid(int value);
const INodeType INodeType_MIN = I_TYPE_FILE;
const INodeType INodeType_MAX = I_TYPE_SYMLINK;
const int INodeType_ARRAYSIZE = INodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* INodeType_descriptor();
inline const ::std::string& INodeType_Name(INodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    INodeType_descriptor(), value);
}
inline bool INodeType_Parse(
    const ::std::string& name, INodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<INodeType>(
    INodeType_descriptor(), name, value);
}
enum MetadataUpdateType {
  META_TYPE_TIMES = 0,
  META_TYPE_REPLICATION = 1,
  META_TYPE_OWNER = 2,
  META_TYPE_PERMS = 3,
  META_TYPE_ACLS = 4,
  META_TYPE_XATTRS = 5
};
bool MetadataUpdateType_IsValid(int value);
const MetadataUpdateType MetadataUpdateType_MIN = META_TYPE_TIMES;
const MetadataUpdateType MetadataUpdateType_MAX = META_TYPE_XATTRS;
const int MetadataUpdateType_ARRAYSIZE = MetadataUpdateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MetadataUpdateType_descriptor();
inline const ::std::string& MetadataUpdateType_Name(MetadataUpdateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MetadataUpdateType_descriptor(), value);
}
inline bool MetadataUpdateType_Parse(
    const ::std::string& name, MetadataUpdateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MetadataUpdateType>(
    MetadataUpdateType_descriptor(), name, value);
}
// ===================================================================

class EventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.EventProto) */ {
 public:
  EventProto();
  virtual ~EventProto();

  EventProto(const EventProto& from);

  inline EventProto& operator=(const EventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventProto(EventProto&& from) noexcept
    : EventProto() {
    *this = ::std::move(from);
  }

  inline EventProto& operator=(EventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventProto* internal_default_instance() {
    return reinterpret_cast<const EventProto*>(
               &_EventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EventProto* other);
  friend void swap(EventProto& a, EventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventProto* New() const final {
    return CreateMaybeMessage<EventProto>(NULL);
  }

  EventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventProto& from);
  void MergeFrom(const EventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes contents = 2;
  bool has_contents() const;
  void clear_contents();
  static const int kContentsFieldNumber = 2;
  const ::std::string& contents() const;
  void set_contents(const ::std::string& value);
  #if LANG_CXX11
  void set_contents(::std::string&& value);
  #endif
  void set_contents(const char* value);
  void set_contents(const void* value, size_t size);
  ::std::string* mutable_contents();
  ::std::string* release_contents();
  void set_allocated_contents(::std::string* contents);

  // required .hadoop.hdfs.EventType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::hadoop::hdfs::EventType type() const;
  void set_type(::hadoop::hdfs::EventType value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.EventProto)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_contents();
  void clear_has_contents();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr contents_;
  int type_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EventBatchProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.EventBatchProto) */ {
 public:
  EventBatchProto();
  virtual ~EventBatchProto();

  EventBatchProto(const EventBatchProto& from);

  inline EventBatchProto& operator=(const EventBatchProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventBatchProto(EventBatchProto&& from) noexcept
    : EventBatchProto() {
    *this = ::std::move(from);
  }

  inline EventBatchProto& operator=(EventBatchProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventBatchProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventBatchProto* internal_default_instance() {
    return reinterpret_cast<const EventBatchProto*>(
               &_EventBatchProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EventBatchProto* other);
  friend void swap(EventBatchProto& a, EventBatchProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventBatchProto* New() const final {
    return CreateMaybeMessage<EventBatchProto>(NULL);
  }

  EventBatchProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventBatchProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventBatchProto& from);
  void MergeFrom(const EventBatchProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBatchProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.EventProto events = 2;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 2;
  ::hadoop::hdfs::EventProto* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >*
      mutable_events();
  const ::hadoop::hdfs::EventProto& events(int index) const;
  ::hadoop::hdfs::EventProto* add_events();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >&
      events() const;

  // required int64 txid = 1;
  bool has_txid() const;
  void clear_txid();
  static const int kTxidFieldNumber = 1;
  ::google::protobuf::int64 txid() const;
  void set_txid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.EventBatchProto)
 private:
  void set_has_txid();
  void clear_has_txid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto > events_;
  ::google::protobuf::int64 txid_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateEventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.CreateEventProto) */ {
 public:
  CreateEventProto();
  virtual ~CreateEventProto();

  CreateEventProto(const CreateEventProto& from);

  inline CreateEventProto& operator=(const CreateEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateEventProto(CreateEventProto&& from) noexcept
    : CreateEventProto() {
    *this = ::std::move(from);
  }

  inline CreateEventProto& operator=(CreateEventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateEventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateEventProto* internal_default_instance() {
    return reinterpret_cast<const CreateEventProto*>(
               &_CreateEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CreateEventProto* other);
  friend void swap(CreateEventProto& a, CreateEventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateEventProto* New() const final {
    return CreateMaybeMessage<CreateEventProto>(NULL);
  }

  CreateEventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateEventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateEventProto& from);
  void MergeFrom(const CreateEventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required string ownerName = 4;
  bool has_ownername() const;
  void clear_ownername();
  static const int kOwnerNameFieldNumber = 4;
  const ::std::string& ownername() const;
  void set_ownername(const ::std::string& value);
  #if LANG_CXX11
  void set_ownername(::std::string&& value);
  #endif
  void set_ownername(const char* value);
  void set_ownername(const char* value, size_t size);
  ::std::string* mutable_ownername();
  ::std::string* release_ownername();
  void set_allocated_ownername(::std::string* ownername);

  // required string groupName = 5;
  bool has_groupname() const;
  void clear_groupname();
  static const int kGroupNameFieldNumber = 5;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  #if LANG_CXX11
  void set_groupname(::std::string&& value);
  #endif
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // optional string symlinkTarget = 8;
  bool has_symlinktarget() const;
  void clear_symlinktarget();
  static const int kSymlinkTargetFieldNumber = 8;
  const ::std::string& symlinktarget() const;
  void set_symlinktarget(const ::std::string& value);
  #if LANG_CXX11
  void set_symlinktarget(::std::string&& value);
  #endif
  void set_symlinktarget(const char* value);
  void set_symlinktarget(const char* value, size_t size);
  ::std::string* mutable_symlinktarget();
  ::std::string* release_symlinktarget();
  void set_allocated_symlinktarget(::std::string* symlinktarget);

  // required .hadoop.hdfs.FsPermissionProto perms = 6;
  bool has_perms() const;
  void clear_perms();
  static const int kPermsFieldNumber = 6;
  private:
  const ::hadoop::hdfs::FsPermissionProto& _internal_perms() const;
  public:
  const ::hadoop::hdfs::FsPermissionProto& perms() const;
  ::hadoop::hdfs::FsPermissionProto* release_perms();
  ::hadoop::hdfs::FsPermissionProto* mutable_perms();
  void set_allocated_perms(::hadoop::hdfs::FsPermissionProto* perms);

  // required int64 ctime = 3;
  bool has_ctime() const;
  void clear_ctime();
  static const int kCtimeFieldNumber = 3;
  ::google::protobuf::int64 ctime() const;
  void set_ctime(::google::protobuf::int64 value);

  // required .hadoop.hdfs.INodeType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::hadoop::hdfs::INodeType type() const;
  void set_type(::hadoop::hdfs::INodeType value);

  // optional int32 replication = 7;
  bool has_replication() const;
  void clear_replication();
  static const int kReplicationFieldNumber = 7;
  ::google::protobuf::int32 replication() const;
  void set_replication(::google::protobuf::int32 value);

  // optional int64 defaultBlockSize = 10 [default = 0];
  bool has_defaultblocksize() const;
  void clear_defaultblocksize();
  static const int kDefaultBlockSizeFieldNumber = 10;
  ::google::protobuf::int64 defaultblocksize() const;
  void set_defaultblocksize(::google::protobuf::int64 value);

  // optional bool overwrite = 9;
  bool has_overwrite() const;
  void clear_overwrite();
  static const int kOverwriteFieldNumber = 9;
  bool overwrite() const;
  void set_overwrite(bool value);

  // optional bool erasureCoded = 11;
  bool has_erasurecoded() const;
  void clear_erasurecoded();
  static const int kErasureCodedFieldNumber = 11;
  bool erasurecoded() const;
  void set_erasurecoded(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.CreateEventProto)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_path();
  void clear_has_path();
  void set_has_ctime();
  void clear_has_ctime();
  void set_has_ownername();
  void clear_has_ownername();
  void set_has_groupname();
  void clear_has_groupname();
  void set_has_perms();
  void clear_has_perms();
  void set_has_replication();
  void clear_has_replication();
  void set_has_symlinktarget();
  void clear_has_symlinktarget();
  void set_has_overwrite();
  void clear_has_overwrite();
  void set_has_defaultblocksize();
  void clear_has_defaultblocksize();
  void set_has_erasurecoded();
  void clear_has_erasurecoded();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr ownername_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  ::google::protobuf::internal::ArenaStringPtr symlinktarget_;
  ::hadoop::hdfs::FsPermissionProto* perms_;
  ::google::protobuf::int64 ctime_;
  int type_;
  ::google::protobuf::int32 replication_;
  ::google::protobuf::int64 defaultblocksize_;
  bool overwrite_;
  bool erasurecoded_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseEventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.CloseEventProto) */ {
 public:
  CloseEventProto();
  virtual ~CloseEventProto();

  CloseEventProto(const CloseEventProto& from);

  inline CloseEventProto& operator=(const CloseEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseEventProto(CloseEventProto&& from) noexcept
    : CloseEventProto() {
    *this = ::std::move(from);
  }

  inline CloseEventProto& operator=(CloseEventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseEventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseEventProto* internal_default_instance() {
    return reinterpret_cast<const CloseEventProto*>(
               &_CloseEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CloseEventProto* other);
  friend void swap(CloseEventProto& a, CloseEventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseEventProto* New() const final {
    return CreateMaybeMessage<CloseEventProto>(NULL);
  }

  CloseEventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseEventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseEventProto& from);
  void MergeFrom(const CloseEventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseEventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required int64 fileSize = 2;
  bool has_filesize() const;
  void clear_filesize();
  static const int kFileSizeFieldNumber = 2;
  ::google::protobuf::int64 filesize() const;
  void set_filesize(::google::protobuf::int64 value);

  // required int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.CloseEventProto)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_filesize();
  void clear_has_filesize();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int64 filesize_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TruncateEventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.TruncateEventProto) */ {
 public:
  TruncateEventProto();
  virtual ~TruncateEventProto();

  TruncateEventProto(const TruncateEventProto& from);

  inline TruncateEventProto& operator=(const TruncateEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TruncateEventProto(TruncateEventProto&& from) noexcept
    : TruncateEventProto() {
    *this = ::std::move(from);
  }

  inline TruncateEventProto& operator=(TruncateEventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateEventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TruncateEventProto* internal_default_instance() {
    return reinterpret_cast<const TruncateEventProto*>(
               &_TruncateEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TruncateEventProto* other);
  friend void swap(TruncateEventProto& a, TruncateEventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TruncateEventProto* New() const final {
    return CreateMaybeMessage<TruncateEventProto>(NULL);
  }

  TruncateEventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TruncateEventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TruncateEventProto& from);
  void MergeFrom(const TruncateEventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateEventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required int64 fileSize = 2;
  bool has_filesize() const;
  void clear_filesize();
  static const int kFileSizeFieldNumber = 2;
  ::google::protobuf::int64 filesize() const;
  void set_filesize(::google::protobuf::int64 value);

  // required int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.TruncateEventProto)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_filesize();
  void clear_has_filesize();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int64 filesize_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AppendEventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.AppendEventProto) */ {
 public:
  AppendEventProto();
  virtual ~AppendEventProto();

  AppendEventProto(const AppendEventProto& from);

  inline AppendEventProto& operator=(const AppendEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEventProto(AppendEventProto&& from) noexcept
    : AppendEventProto() {
    *this = ::std::move(from);
  }

  inline AppendEventProto& operator=(AppendEventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEventProto* internal_default_instance() {
    return reinterpret_cast<const AppendEventProto*>(
               &_AppendEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AppendEventProto* other);
  friend void swap(AppendEventProto& a, AppendEventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEventProto* New() const final {
    return CreateMaybeMessage<AppendEventProto>(NULL);
  }

  AppendEventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AppendEventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AppendEventProto& from);
  void MergeFrom(const AppendEventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional bool newBlock = 2 [default = false];
  bool has_newblock() const;
  void clear_newblock();
  static const int kNewBlockFieldNumber = 2;
  bool newblock() const;
  void set_newblock(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.AppendEventProto)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_newblock();
  void clear_has_newblock();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  bool newblock_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RenameEventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.RenameEventProto) */ {
 public:
  RenameEventProto();
  virtual ~RenameEventProto();

  RenameEventProto(const RenameEventProto& from);

  inline RenameEventProto& operator=(const RenameEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RenameEventProto(RenameEventProto&& from) noexcept
    : RenameEventProto() {
    *this = ::std::move(from);
  }

  inline RenameEventProto& operator=(RenameEventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameEventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RenameEventProto* internal_default_instance() {
    return reinterpret_cast<const RenameEventProto*>(
               &_RenameEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RenameEventProto* other);
  friend void swap(RenameEventProto& a, RenameEventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RenameEventProto* New() const final {
    return CreateMaybeMessage<RenameEventProto>(NULL);
  }

  RenameEventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RenameEventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RenameEventProto& from);
  void MergeFrom(const RenameEventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameEventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string srcPath = 1;
  bool has_srcpath() const;
  void clear_srcpath();
  static const int kSrcPathFieldNumber = 1;
  const ::std::string& srcpath() const;
  void set_srcpath(const ::std::string& value);
  #if LANG_CXX11
  void set_srcpath(::std::string&& value);
  #endif
  void set_srcpath(const char* value);
  void set_srcpath(const char* value, size_t size);
  ::std::string* mutable_srcpath();
  ::std::string* release_srcpath();
  void set_allocated_srcpath(::std::string* srcpath);

  // required string destPath = 2;
  bool has_destpath() const;
  void clear_destpath();
  static const int kDestPathFieldNumber = 2;
  const ::std::string& destpath() const;
  void set_destpath(const ::std::string& value);
  #if LANG_CXX11
  void set_destpath(::std::string&& value);
  #endif
  void set_destpath(const char* value);
  void set_destpath(const char* value, size_t size);
  ::std::string* mutable_destpath();
  ::std::string* release_destpath();
  void set_allocated_destpath(::std::string* destpath);

  // required int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.RenameEventProto)
 private:
  void set_has_srcpath();
  void clear_has_srcpath();
  void set_has_destpath();
  void clear_has_destpath();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr srcpath_;
  ::google::protobuf::internal::ArenaStringPtr destpath_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetadataUpdateEventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.MetadataUpdateEventProto) */ {
 public:
  MetadataUpdateEventProto();
  virtual ~MetadataUpdateEventProto();

  MetadataUpdateEventProto(const MetadataUpdateEventProto& from);

  inline MetadataUpdateEventProto& operator=(const MetadataUpdateEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetadataUpdateEventProto(MetadataUpdateEventProto&& from) noexcept
    : MetadataUpdateEventProto() {
    *this = ::std::move(from);
  }

  inline MetadataUpdateEventProto& operator=(MetadataUpdateEventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetadataUpdateEventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetadataUpdateEventProto* internal_default_instance() {
    return reinterpret_cast<const MetadataUpdateEventProto*>(
               &_MetadataUpdateEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MetadataUpdateEventProto* other);
  friend void swap(MetadataUpdateEventProto& a, MetadataUpdateEventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetadataUpdateEventProto* New() const final {
    return CreateMaybeMessage<MetadataUpdateEventProto>(NULL);
  }

  MetadataUpdateEventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MetadataUpdateEventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MetadataUpdateEventProto& from);
  void MergeFrom(const MetadataUpdateEventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataUpdateEventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.AclEntryProto acls = 9;
  int acls_size() const;
  void clear_acls();
  static const int kAclsFieldNumber = 9;
  ::hadoop::hdfs::AclEntryProto* mutable_acls(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AclEntryProto >*
      mutable_acls();
  const ::hadoop::hdfs::AclEntryProto& acls(int index) const;
  ::hadoop::hdfs::AclEntryProto* add_acls();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AclEntryProto >&
      acls() const;

  // repeated .hadoop.hdfs.XAttrProto xAttrs = 10;
  int xattrs_size() const;
  void clear_xattrs();
  static const int kXAttrsFieldNumber = 10;
  ::hadoop::hdfs::XAttrProto* mutable_xattrs(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::XAttrProto >*
      mutable_xattrs();
  const ::hadoop::hdfs::XAttrProto& xattrs(int index) const;
  ::hadoop::hdfs::XAttrProto* add_xattrs();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::XAttrProto >&
      xattrs() const;

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional string ownerName = 6;
  bool has_ownername() const;
  void clear_ownername();
  static const int kOwnerNameFieldNumber = 6;
  const ::std::string& ownername() const;
  void set_ownername(const ::std::string& value);
  #if LANG_CXX11
  void set_ownername(::std::string&& value);
  #endif
  void set_ownername(const char* value);
  void set_ownername(const char* value, size_t size);
  ::std::string* mutable_ownername();
  ::std::string* release_ownername();
  void set_allocated_ownername(::std::string* ownername);

  // optional string groupName = 7;
  bool has_groupname() const;
  void clear_groupname();
  static const int kGroupNameFieldNumber = 7;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  #if LANG_CXX11
  void set_groupname(::std::string&& value);
  #endif
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // optional .hadoop.hdfs.FsPermissionProto perms = 8;
  bool has_perms() const;
  void clear_perms();
  static const int kPermsFieldNumber = 8;
  private:
  const ::hadoop::hdfs::FsPermissionProto& _internal_perms() const;
  public:
  const ::hadoop::hdfs::FsPermissionProto& perms() const;
  ::hadoop::hdfs::FsPermissionProto* release_perms();
  ::hadoop::hdfs::FsPermissionProto* mutable_perms();
  void set_allocated_perms(::hadoop::hdfs::FsPermissionProto* perms);

  // optional int64 mtime = 3;
  bool has_mtime() const;
  void clear_mtime();
  static const int kMtimeFieldNumber = 3;
  ::google::protobuf::int64 mtime() const;
  void set_mtime(::google::protobuf::int64 value);

  // required .hadoop.hdfs.MetadataUpdateType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::hadoop::hdfs::MetadataUpdateType type() const;
  void set_type(::hadoop::hdfs::MetadataUpdateType value);

  // optional int32 replication = 5;
  bool has_replication() const;
  void clear_replication();
  static const int kReplicationFieldNumber = 5;
  ::google::protobuf::int32 replication() const;
  void set_replication(::google::protobuf::int32 value);

  // optional int64 atime = 4;
  bool has_atime() const;
  void clear_atime();
  static const int kAtimeFieldNumber = 4;
  ::google::protobuf::int64 atime() const;
  void set_atime(::google::protobuf::int64 value);

  // optional bool xAttrsRemoved = 11;
  bool has_xattrsremoved() const;
  void clear_xattrsremoved();
  static const int kXAttrsRemovedFieldNumber = 11;
  bool xattrsremoved() const;
  void set_xattrsremoved(bool value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.MetadataUpdateEventProto)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_type();
  void clear_has_type();
  void set_has_mtime();
  void clear_has_mtime();
  void set_has_atime();
  void clear_has_atime();
  void set_has_replication();
  void clear_has_replication();
  void set_has_ownername();
  void clear_has_ownername();
  void set_has_groupname();
  void clear_has_groupname();
  void set_has_perms();
  void clear_has_perms();
  void set_has_xattrsremoved();
  void clear_has_xattrsremoved();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AclEntryProto > acls_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::XAttrProto > xattrs_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr ownername_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  ::hadoop::hdfs::FsPermissionProto* perms_;
  ::google::protobuf::int64 mtime_;
  int type_;
  ::google::protobuf::int32 replication_;
  ::google::protobuf::int64 atime_;
  bool xattrsremoved_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnlinkEventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.UnlinkEventProto) */ {
 public:
  UnlinkEventProto();
  virtual ~UnlinkEventProto();

  UnlinkEventProto(const UnlinkEventProto& from);

  inline UnlinkEventProto& operator=(const UnlinkEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlinkEventProto(UnlinkEventProto&& from) noexcept
    : UnlinkEventProto() {
    *this = ::std::move(from);
  }

  inline UnlinkEventProto& operator=(UnlinkEventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlinkEventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnlinkEventProto* internal_default_instance() {
    return reinterpret_cast<const UnlinkEventProto*>(
               &_UnlinkEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(UnlinkEventProto* other);
  friend void swap(UnlinkEventProto& a, UnlinkEventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlinkEventProto* New() const final {
    return CreateMaybeMessage<UnlinkEventProto>(NULL);
  }

  UnlinkEventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnlinkEventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnlinkEventProto& from);
  void MergeFrom(const UnlinkEventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlinkEventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.UnlinkEventProto)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EventsListProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hadoop.hdfs.EventsListProto) */ {
 public:
  EventsListProto();
  virtual ~EventsListProto();

  EventsListProto(const EventsListProto& from);

  inline EventsListProto& operator=(const EventsListProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventsListProto(EventsListProto&& from) noexcept
    : EventsListProto() {
    *this = ::std::move(from);
  }

  inline EventsListProto& operator=(EventsListProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventsListProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventsListProto* internal_default_instance() {
    return reinterpret_cast<const EventsListProto*>(
               &_EventsListProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(EventsListProto* other);
  friend void swap(EventsListProto& a, EventsListProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventsListProto* New() const final {
    return CreateMaybeMessage<EventsListProto>(NULL);
  }

  EventsListProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventsListProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventsListProto& from);
  void MergeFrom(const EventsListProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsListProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hadoop.hdfs.EventProto events = 1;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 1;
  ::hadoop::hdfs::EventProto* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >*
      mutable_events();
  const ::hadoop::hdfs::EventProto& events(int index) const;
  ::hadoop::hdfs::EventProto* add_events();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >&
      events() const;

  // repeated .hadoop.hdfs.EventBatchProto batch = 5;
  int batch_size() const;
  void clear_batch();
  static const int kBatchFieldNumber = 5;
  ::hadoop::hdfs::EventBatchProto* mutable_batch(int index);
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventBatchProto >*
      mutable_batch();
  const ::hadoop::hdfs::EventBatchProto& batch(int index) const;
  ::hadoop::hdfs::EventBatchProto* add_batch();
  const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventBatchProto >&
      batch() const;

  // required int64 firstTxid = 2;
  bool has_firsttxid() const;
  void clear_firsttxid();
  static const int kFirstTxidFieldNumber = 2;
  ::google::protobuf::int64 firsttxid() const;
  void set_firsttxid(::google::protobuf::int64 value);

  // required int64 lastTxid = 3;
  bool has_lasttxid() const;
  void clear_lasttxid();
  static const int kLastTxidFieldNumber = 3;
  ::google::protobuf::int64 lasttxid() const;
  void set_lasttxid(::google::protobuf::int64 value);

  // required int64 syncTxid = 4;
  bool has_synctxid() const;
  void clear_synctxid();
  static const int kSyncTxidFieldNumber = 4;
  ::google::protobuf::int64 synctxid() const;
  void set_synctxid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hadoop.hdfs.EventsListProto)
 private:
  void set_has_firsttxid();
  void clear_has_firsttxid();
  void set_has_lasttxid();
  void clear_has_lasttxid();
  void set_has_synctxid();
  void clear_has_synctxid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto > events_;
  ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventBatchProto > batch_;
  ::google::protobuf::int64 firsttxid_;
  ::google::protobuf::int64 lasttxid_;
  ::google::protobuf::int64 synctxid_;
  friend struct ::protobuf_inotify_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EventProto

// required .hadoop.hdfs.EventType type = 1;
inline bool EventProto::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventProto::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::hadoop::hdfs::EventType EventProto::type() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventProto.type)
  return static_cast< ::hadoop::hdfs::EventType >(type_);
}
inline void EventProto::set_type(::hadoop::hdfs::EventType value) {
  assert(::hadoop::hdfs::EventType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EventProto.type)
}

// required bytes contents = 2;
inline bool EventProto::has_contents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventProto::set_has_contents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventProto::clear_has_contents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventProto::clear_contents() {
  contents_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contents();
}
inline const ::std::string& EventProto::contents() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventProto.contents)
  return contents_.GetNoArena();
}
inline void EventProto::set_contents(const ::std::string& value) {
  set_has_contents();
  contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EventProto.contents)
}
#if LANG_CXX11
inline void EventProto::set_contents(::std::string&& value) {
  set_has_contents();
  contents_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.EventProto.contents)
}
#endif
inline void EventProto::set_contents(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contents();
  contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.EventProto.contents)
}
inline void EventProto::set_contents(const void* value, size_t size) {
  set_has_contents();
  contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.EventProto.contents)
}
inline ::std::string* EventProto::mutable_contents() {
  set_has_contents();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.EventProto.contents)
  return contents_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventProto::release_contents() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.EventProto.contents)
  if (!has_contents()) {
    return NULL;
  }
  clear_has_contents();
  return contents_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventProto::set_allocated_contents(::std::string* contents) {
  if (contents != NULL) {
    set_has_contents();
  } else {
    clear_has_contents();
  }
  contents_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contents);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.EventProto.contents)
}

// -------------------------------------------------------------------

// EventBatchProto

// required int64 txid = 1;
inline bool EventBatchProto::has_txid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventBatchProto::set_has_txid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventBatchProto::clear_has_txid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventBatchProto::clear_txid() {
  txid_ = GOOGLE_LONGLONG(0);
  clear_has_txid();
}
inline ::google::protobuf::int64 EventBatchProto::txid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventBatchProto.txid)
  return txid_;
}
inline void EventBatchProto::set_txid(::google::protobuf::int64 value) {
  set_has_txid();
  txid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EventBatchProto.txid)
}

// repeated .hadoop.hdfs.EventProto events = 2;
inline int EventBatchProto::events_size() const {
  return events_.size();
}
inline void EventBatchProto::clear_events() {
  events_.Clear();
}
inline ::hadoop::hdfs::EventProto* EventBatchProto::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.EventBatchProto.events)
  return events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >*
EventBatchProto::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.EventBatchProto.events)
  return &events_;
}
inline const ::hadoop::hdfs::EventProto& EventBatchProto::events(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventBatchProto.events)
  return events_.Get(index);
}
inline ::hadoop::hdfs::EventProto* EventBatchProto::add_events() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.EventBatchProto.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >&
EventBatchProto::events() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.EventBatchProto.events)
  return events_;
}

// -------------------------------------------------------------------

// CreateEventProto

// required .hadoop.hdfs.INodeType type = 1;
inline bool CreateEventProto::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateEventProto::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateEventProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateEventProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::hadoop::hdfs::INodeType CreateEventProto::type() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.type)
  return static_cast< ::hadoop::hdfs::INodeType >(type_);
}
inline void CreateEventProto::set_type(::hadoop::hdfs::INodeType value) {
  assert(::hadoop::hdfs::INodeType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.type)
}

// required string path = 2;
inline bool CreateEventProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateEventProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateEventProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateEventProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& CreateEventProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.path)
  return path_.GetNoArena();
}
inline void CreateEventProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.path)
}
#if LANG_CXX11
inline void CreateEventProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CreateEventProto.path)
}
#endif
inline void CreateEventProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CreateEventProto.path)
}
inline void CreateEventProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CreateEventProto.path)
}
inline ::std::string* CreateEventProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CreateEventProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateEventProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CreateEventProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateEventProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CreateEventProto.path)
}

// required int64 ctime = 3;
inline bool CreateEventProto::has_ctime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateEventProto::set_has_ctime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateEventProto::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateEventProto::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::int64 CreateEventProto::ctime() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.ctime)
  return ctime_;
}
inline void CreateEventProto::set_ctime(::google::protobuf::int64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.ctime)
}

// required string ownerName = 4;
inline bool CreateEventProto::has_ownername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateEventProto::set_has_ownername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateEventProto::clear_has_ownername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateEventProto::clear_ownername() {
  ownername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ownername();
}
inline const ::std::string& CreateEventProto::ownername() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.ownerName)
  return ownername_.GetNoArena();
}
inline void CreateEventProto::set_ownername(const ::std::string& value) {
  set_has_ownername();
  ownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.ownerName)
}
#if LANG_CXX11
inline void CreateEventProto::set_ownername(::std::string&& value) {
  set_has_ownername();
  ownername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CreateEventProto.ownerName)
}
#endif
inline void CreateEventProto::set_ownername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ownername();
  ownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CreateEventProto.ownerName)
}
inline void CreateEventProto::set_ownername(const char* value, size_t size) {
  set_has_ownername();
  ownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CreateEventProto.ownerName)
}
inline ::std::string* CreateEventProto::mutable_ownername() {
  set_has_ownername();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CreateEventProto.ownerName)
  return ownername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateEventProto::release_ownername() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CreateEventProto.ownerName)
  if (!has_ownername()) {
    return NULL;
  }
  clear_has_ownername();
  return ownername_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateEventProto::set_allocated_ownername(::std::string* ownername) {
  if (ownername != NULL) {
    set_has_ownername();
  } else {
    clear_has_ownername();
  }
  ownername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ownername);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CreateEventProto.ownerName)
}

// required string groupName = 5;
inline bool CreateEventProto::has_groupname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateEventProto::set_has_groupname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateEventProto::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateEventProto::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupname();
}
inline const ::std::string& CreateEventProto::groupname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.groupName)
  return groupname_.GetNoArena();
}
inline void CreateEventProto::set_groupname(const ::std::string& value) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.groupName)
}
#if LANG_CXX11
inline void CreateEventProto::set_groupname(::std::string&& value) {
  set_has_groupname();
  groupname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CreateEventProto.groupName)
}
#endif
inline void CreateEventProto::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CreateEventProto.groupName)
}
inline void CreateEventProto::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CreateEventProto.groupName)
}
inline ::std::string* CreateEventProto::mutable_groupname() {
  set_has_groupname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CreateEventProto.groupName)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateEventProto::release_groupname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CreateEventProto.groupName)
  if (!has_groupname()) {
    return NULL;
  }
  clear_has_groupname();
  return groupname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateEventProto::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    set_has_groupname();
  } else {
    clear_has_groupname();
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CreateEventProto.groupName)
}

// required .hadoop.hdfs.FsPermissionProto perms = 6;
inline bool CreateEventProto::has_perms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateEventProto::set_has_perms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateEventProto::clear_has_perms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hadoop::hdfs::FsPermissionProto& CreateEventProto::_internal_perms() const {
  return *perms_;
}
inline const ::hadoop::hdfs::FsPermissionProto& CreateEventProto::perms() const {
  const ::hadoop::hdfs::FsPermissionProto* p = perms_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.perms)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::FsPermissionProto*>(
      &::hadoop::hdfs::_FsPermissionProto_default_instance_);
}
inline ::hadoop::hdfs::FsPermissionProto* CreateEventProto::release_perms() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CreateEventProto.perms)
  clear_has_perms();
  ::hadoop::hdfs::FsPermissionProto* temp = perms_;
  perms_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::FsPermissionProto* CreateEventProto::mutable_perms() {
  set_has_perms();
  if (perms_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::FsPermissionProto>(GetArenaNoVirtual());
    perms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CreateEventProto.perms)
  return perms_;
}
inline void CreateEventProto::set_allocated_perms(::hadoop::hdfs::FsPermissionProto* perms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(perms_);
  }
  if (perms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      perms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, perms, submessage_arena);
    }
    set_has_perms();
  } else {
    clear_has_perms();
  }
  perms_ = perms;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CreateEventProto.perms)
}

// optional int32 replication = 7;
inline bool CreateEventProto::has_replication() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateEventProto::set_has_replication() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateEventProto::clear_has_replication() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateEventProto::clear_replication() {
  replication_ = 0;
  clear_has_replication();
}
inline ::google::protobuf::int32 CreateEventProto::replication() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.replication)
  return replication_;
}
inline void CreateEventProto::set_replication(::google::protobuf::int32 value) {
  set_has_replication();
  replication_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.replication)
}

// optional string symlinkTarget = 8;
inline bool CreateEventProto::has_symlinktarget() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateEventProto::set_has_symlinktarget() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateEventProto::clear_has_symlinktarget() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateEventProto::clear_symlinktarget() {
  symlinktarget_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symlinktarget();
}
inline const ::std::string& CreateEventProto::symlinktarget() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.symlinkTarget)
  return symlinktarget_.GetNoArena();
}
inline void CreateEventProto::set_symlinktarget(const ::std::string& value) {
  set_has_symlinktarget();
  symlinktarget_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.symlinkTarget)
}
#if LANG_CXX11
inline void CreateEventProto::set_symlinktarget(::std::string&& value) {
  set_has_symlinktarget();
  symlinktarget_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CreateEventProto.symlinkTarget)
}
#endif
inline void CreateEventProto::set_symlinktarget(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symlinktarget();
  symlinktarget_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CreateEventProto.symlinkTarget)
}
inline void CreateEventProto::set_symlinktarget(const char* value, size_t size) {
  set_has_symlinktarget();
  symlinktarget_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CreateEventProto.symlinkTarget)
}
inline ::std::string* CreateEventProto::mutable_symlinktarget() {
  set_has_symlinktarget();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CreateEventProto.symlinkTarget)
  return symlinktarget_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateEventProto::release_symlinktarget() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CreateEventProto.symlinkTarget)
  if (!has_symlinktarget()) {
    return NULL;
  }
  clear_has_symlinktarget();
  return symlinktarget_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateEventProto::set_allocated_symlinktarget(::std::string* symlinktarget) {
  if (symlinktarget != NULL) {
    set_has_symlinktarget();
  } else {
    clear_has_symlinktarget();
  }
  symlinktarget_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symlinktarget);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CreateEventProto.symlinkTarget)
}

// optional bool overwrite = 9;
inline bool CreateEventProto::has_overwrite() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CreateEventProto::set_has_overwrite() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CreateEventProto::clear_has_overwrite() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CreateEventProto::clear_overwrite() {
  overwrite_ = false;
  clear_has_overwrite();
}
inline bool CreateEventProto::overwrite() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.overwrite)
  return overwrite_;
}
inline void CreateEventProto::set_overwrite(bool value) {
  set_has_overwrite();
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.overwrite)
}

// optional int64 defaultBlockSize = 10 [default = 0];
inline bool CreateEventProto::has_defaultblocksize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateEventProto::set_has_defaultblocksize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateEventProto::clear_has_defaultblocksize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateEventProto::clear_defaultblocksize() {
  defaultblocksize_ = GOOGLE_LONGLONG(0);
  clear_has_defaultblocksize();
}
inline ::google::protobuf::int64 CreateEventProto::defaultblocksize() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.defaultBlockSize)
  return defaultblocksize_;
}
inline void CreateEventProto::set_defaultblocksize(::google::protobuf::int64 value) {
  set_has_defaultblocksize();
  defaultblocksize_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.defaultBlockSize)
}

// optional bool erasureCoded = 11;
inline bool CreateEventProto::has_erasurecoded() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CreateEventProto::set_has_erasurecoded() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CreateEventProto::clear_has_erasurecoded() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CreateEventProto::clear_erasurecoded() {
  erasurecoded_ = false;
  clear_has_erasurecoded();
}
inline bool CreateEventProto::erasurecoded() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CreateEventProto.erasureCoded)
  return erasurecoded_;
}
inline void CreateEventProto::set_erasurecoded(bool value) {
  set_has_erasurecoded();
  erasurecoded_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CreateEventProto.erasureCoded)
}

// -------------------------------------------------------------------

// CloseEventProto

// required string path = 1;
inline bool CloseEventProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseEventProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseEventProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseEventProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& CloseEventProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CloseEventProto.path)
  return path_.GetNoArena();
}
inline void CloseEventProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CloseEventProto.path)
}
#if LANG_CXX11
inline void CloseEventProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.CloseEventProto.path)
}
#endif
inline void CloseEventProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.CloseEventProto.path)
}
inline void CloseEventProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.CloseEventProto.path)
}
inline ::std::string* CloseEventProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.CloseEventProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseEventProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.CloseEventProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseEventProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.CloseEventProto.path)
}

// required int64 fileSize = 2;
inline bool CloseEventProto::has_filesize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseEventProto::set_has_filesize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseEventProto::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseEventProto::clear_filesize() {
  filesize_ = GOOGLE_LONGLONG(0);
  clear_has_filesize();
}
inline ::google::protobuf::int64 CloseEventProto::filesize() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CloseEventProto.fileSize)
  return filesize_;
}
inline void CloseEventProto::set_filesize(::google::protobuf::int64 value) {
  set_has_filesize();
  filesize_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CloseEventProto.fileSize)
}

// required int64 timestamp = 3;
inline bool CloseEventProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CloseEventProto::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CloseEventProto::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CloseEventProto::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 CloseEventProto::timestamp() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.CloseEventProto.timestamp)
  return timestamp_;
}
inline void CloseEventProto::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.CloseEventProto.timestamp)
}

// -------------------------------------------------------------------

// TruncateEventProto

// required string path = 1;
inline bool TruncateEventProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TruncateEventProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TruncateEventProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TruncateEventProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& TruncateEventProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.TruncateEventProto.path)
  return path_.GetNoArena();
}
inline void TruncateEventProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.TruncateEventProto.path)
}
#if LANG_CXX11
inline void TruncateEventProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.TruncateEventProto.path)
}
#endif
inline void TruncateEventProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.TruncateEventProto.path)
}
inline void TruncateEventProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.TruncateEventProto.path)
}
inline ::std::string* TruncateEventProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.TruncateEventProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TruncateEventProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.TruncateEventProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TruncateEventProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.TruncateEventProto.path)
}

// required int64 fileSize = 2;
inline bool TruncateEventProto::has_filesize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TruncateEventProto::set_has_filesize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TruncateEventProto::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TruncateEventProto::clear_filesize() {
  filesize_ = GOOGLE_LONGLONG(0);
  clear_has_filesize();
}
inline ::google::protobuf::int64 TruncateEventProto::filesize() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.TruncateEventProto.fileSize)
  return filesize_;
}
inline void TruncateEventProto::set_filesize(::google::protobuf::int64 value) {
  set_has_filesize();
  filesize_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.TruncateEventProto.fileSize)
}

// required int64 timestamp = 3;
inline bool TruncateEventProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TruncateEventProto::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TruncateEventProto::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TruncateEventProto::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 TruncateEventProto::timestamp() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.TruncateEventProto.timestamp)
  return timestamp_;
}
inline void TruncateEventProto::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.TruncateEventProto.timestamp)
}

// -------------------------------------------------------------------

// AppendEventProto

// required string path = 1;
inline bool AppendEventProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendEventProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendEventProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendEventProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& AppendEventProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.AppendEventProto.path)
  return path_.GetNoArena();
}
inline void AppendEventProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.AppendEventProto.path)
}
#if LANG_CXX11
inline void AppendEventProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.AppendEventProto.path)
}
#endif
inline void AppendEventProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.AppendEventProto.path)
}
inline void AppendEventProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.AppendEventProto.path)
}
inline ::std::string* AppendEventProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.AppendEventProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppendEventProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.AppendEventProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppendEventProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.AppendEventProto.path)
}

// optional bool newBlock = 2 [default = false];
inline bool AppendEventProto::has_newblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppendEventProto::set_has_newblock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppendEventProto::clear_has_newblock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppendEventProto::clear_newblock() {
  newblock_ = false;
  clear_has_newblock();
}
inline bool AppendEventProto::newblock() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.AppendEventProto.newBlock)
  return newblock_;
}
inline void AppendEventProto::set_newblock(bool value) {
  set_has_newblock();
  newblock_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.AppendEventProto.newBlock)
}

// -------------------------------------------------------------------

// RenameEventProto

// required string srcPath = 1;
inline bool RenameEventProto::has_srcpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenameEventProto::set_has_srcpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenameEventProto::clear_has_srcpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenameEventProto::clear_srcpath() {
  srcpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_srcpath();
}
inline const ::std::string& RenameEventProto::srcpath() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.RenameEventProto.srcPath)
  return srcpath_.GetNoArena();
}
inline void RenameEventProto::set_srcpath(const ::std::string& value) {
  set_has_srcpath();
  srcpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.RenameEventProto.srcPath)
}
#if LANG_CXX11
inline void RenameEventProto::set_srcpath(::std::string&& value) {
  set_has_srcpath();
  srcpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.RenameEventProto.srcPath)
}
#endif
inline void RenameEventProto::set_srcpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_srcpath();
  srcpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.RenameEventProto.srcPath)
}
inline void RenameEventProto::set_srcpath(const char* value, size_t size) {
  set_has_srcpath();
  srcpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.RenameEventProto.srcPath)
}
inline ::std::string* RenameEventProto::mutable_srcpath() {
  set_has_srcpath();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.RenameEventProto.srcPath)
  return srcpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RenameEventProto::release_srcpath() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.RenameEventProto.srcPath)
  if (!has_srcpath()) {
    return NULL;
  }
  clear_has_srcpath();
  return srcpath_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RenameEventProto::set_allocated_srcpath(::std::string* srcpath) {
  if (srcpath != NULL) {
    set_has_srcpath();
  } else {
    clear_has_srcpath();
  }
  srcpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), srcpath);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.RenameEventProto.srcPath)
}

// required string destPath = 2;
inline bool RenameEventProto::has_destpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RenameEventProto::set_has_destpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RenameEventProto::clear_has_destpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RenameEventProto::clear_destpath() {
  destpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destpath();
}
inline const ::std::string& RenameEventProto::destpath() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.RenameEventProto.destPath)
  return destpath_.GetNoArena();
}
inline void RenameEventProto::set_destpath(const ::std::string& value) {
  set_has_destpath();
  destpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.RenameEventProto.destPath)
}
#if LANG_CXX11
inline void RenameEventProto::set_destpath(::std::string&& value) {
  set_has_destpath();
  destpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.RenameEventProto.destPath)
}
#endif
inline void RenameEventProto::set_destpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destpath();
  destpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.RenameEventProto.destPath)
}
inline void RenameEventProto::set_destpath(const char* value, size_t size) {
  set_has_destpath();
  destpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.RenameEventProto.destPath)
}
inline ::std::string* RenameEventProto::mutable_destpath() {
  set_has_destpath();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.RenameEventProto.destPath)
  return destpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RenameEventProto::release_destpath() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.RenameEventProto.destPath)
  if (!has_destpath()) {
    return NULL;
  }
  clear_has_destpath();
  return destpath_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RenameEventProto::set_allocated_destpath(::std::string* destpath) {
  if (destpath != NULL) {
    set_has_destpath();
  } else {
    clear_has_destpath();
  }
  destpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destpath);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.RenameEventProto.destPath)
}

// required int64 timestamp = 3;
inline bool RenameEventProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RenameEventProto::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RenameEventProto::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RenameEventProto::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 RenameEventProto::timestamp() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.RenameEventProto.timestamp)
  return timestamp_;
}
inline void RenameEventProto::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.RenameEventProto.timestamp)
}

// -------------------------------------------------------------------

// MetadataUpdateEventProto

// required string path = 1;
inline bool MetadataUpdateEventProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetadataUpdateEventProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetadataUpdateEventProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetadataUpdateEventProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& MetadataUpdateEventProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.path)
  return path_.GetNoArena();
}
inline void MetadataUpdateEventProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.path)
}
#if LANG_CXX11
inline void MetadataUpdateEventProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.MetadataUpdateEventProto.path)
}
#endif
inline void MetadataUpdateEventProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.MetadataUpdateEventProto.path)
}
inline void MetadataUpdateEventProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.MetadataUpdateEventProto.path)
}
inline ::std::string* MetadataUpdateEventProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.MetadataUpdateEventProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetadataUpdateEventProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.MetadataUpdateEventProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetadataUpdateEventProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.MetadataUpdateEventProto.path)
}

// required .hadoop.hdfs.MetadataUpdateType type = 2;
inline bool MetadataUpdateEventProto::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MetadataUpdateEventProto::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MetadataUpdateEventProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MetadataUpdateEventProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::hadoop::hdfs::MetadataUpdateType MetadataUpdateEventProto::type() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.type)
  return static_cast< ::hadoop::hdfs::MetadataUpdateType >(type_);
}
inline void MetadataUpdateEventProto::set_type(::hadoop::hdfs::MetadataUpdateType value) {
  assert(::hadoop::hdfs::MetadataUpdateType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.type)
}

// optional int64 mtime = 3;
inline bool MetadataUpdateEventProto::has_mtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetadataUpdateEventProto::set_has_mtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetadataUpdateEventProto::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetadataUpdateEventProto::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  clear_has_mtime();
}
inline ::google::protobuf::int64 MetadataUpdateEventProto::mtime() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.mtime)
  return mtime_;
}
inline void MetadataUpdateEventProto::set_mtime(::google::protobuf::int64 value) {
  set_has_mtime();
  mtime_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.mtime)
}

// optional int64 atime = 4;
inline bool MetadataUpdateEventProto::has_atime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MetadataUpdateEventProto::set_has_atime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MetadataUpdateEventProto::clear_has_atime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MetadataUpdateEventProto::clear_atime() {
  atime_ = GOOGLE_LONGLONG(0);
  clear_has_atime();
}
inline ::google::protobuf::int64 MetadataUpdateEventProto::atime() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.atime)
  return atime_;
}
inline void MetadataUpdateEventProto::set_atime(::google::protobuf::int64 value) {
  set_has_atime();
  atime_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.atime)
}

// optional int32 replication = 5;
inline bool MetadataUpdateEventProto::has_replication() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MetadataUpdateEventProto::set_has_replication() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MetadataUpdateEventProto::clear_has_replication() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MetadataUpdateEventProto::clear_replication() {
  replication_ = 0;
  clear_has_replication();
}
inline ::google::protobuf::int32 MetadataUpdateEventProto::replication() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.replication)
  return replication_;
}
inline void MetadataUpdateEventProto::set_replication(::google::protobuf::int32 value) {
  set_has_replication();
  replication_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.replication)
}

// optional string ownerName = 6;
inline bool MetadataUpdateEventProto::has_ownername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetadataUpdateEventProto::set_has_ownername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetadataUpdateEventProto::clear_has_ownername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetadataUpdateEventProto::clear_ownername() {
  ownername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ownername();
}
inline const ::std::string& MetadataUpdateEventProto::ownername() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
  return ownername_.GetNoArena();
}
inline void MetadataUpdateEventProto::set_ownername(const ::std::string& value) {
  set_has_ownername();
  ownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
}
#if LANG_CXX11
inline void MetadataUpdateEventProto::set_ownername(::std::string&& value) {
  set_has_ownername();
  ownername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
}
#endif
inline void MetadataUpdateEventProto::set_ownername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ownername();
  ownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
}
inline void MetadataUpdateEventProto::set_ownername(const char* value, size_t size) {
  set_has_ownername();
  ownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
}
inline ::std::string* MetadataUpdateEventProto::mutable_ownername() {
  set_has_ownername();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
  return ownername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetadataUpdateEventProto::release_ownername() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
  if (!has_ownername()) {
    return NULL;
  }
  clear_has_ownername();
  return ownername_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetadataUpdateEventProto::set_allocated_ownername(::std::string* ownername) {
  if (ownername != NULL) {
    set_has_ownername();
  } else {
    clear_has_ownername();
  }
  ownername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ownername);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.MetadataUpdateEventProto.ownerName)
}

// optional string groupName = 7;
inline bool MetadataUpdateEventProto::has_groupname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetadataUpdateEventProto::set_has_groupname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetadataUpdateEventProto::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetadataUpdateEventProto::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupname();
}
inline const ::std::string& MetadataUpdateEventProto::groupname() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.groupName)
  return groupname_.GetNoArena();
}
inline void MetadataUpdateEventProto::set_groupname(const ::std::string& value) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.groupName)
}
#if LANG_CXX11
inline void MetadataUpdateEventProto::set_groupname(::std::string&& value) {
  set_has_groupname();
  groupname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.MetadataUpdateEventProto.groupName)
}
#endif
inline void MetadataUpdateEventProto::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.MetadataUpdateEventProto.groupName)
}
inline void MetadataUpdateEventProto::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.MetadataUpdateEventProto.groupName)
}
inline ::std::string* MetadataUpdateEventProto::mutable_groupname() {
  set_has_groupname();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.MetadataUpdateEventProto.groupName)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetadataUpdateEventProto::release_groupname() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.MetadataUpdateEventProto.groupName)
  if (!has_groupname()) {
    return NULL;
  }
  clear_has_groupname();
  return groupname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetadataUpdateEventProto::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    set_has_groupname();
  } else {
    clear_has_groupname();
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.MetadataUpdateEventProto.groupName)
}

// optional .hadoop.hdfs.FsPermissionProto perms = 8;
inline bool MetadataUpdateEventProto::has_perms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetadataUpdateEventProto::set_has_perms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetadataUpdateEventProto::clear_has_perms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hadoop::hdfs::FsPermissionProto& MetadataUpdateEventProto::_internal_perms() const {
  return *perms_;
}
inline const ::hadoop::hdfs::FsPermissionProto& MetadataUpdateEventProto::perms() const {
  const ::hadoop::hdfs::FsPermissionProto* p = perms_;
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.perms)
  return p != NULL ? *p : *reinterpret_cast<const ::hadoop::hdfs::FsPermissionProto*>(
      &::hadoop::hdfs::_FsPermissionProto_default_instance_);
}
inline ::hadoop::hdfs::FsPermissionProto* MetadataUpdateEventProto::release_perms() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.MetadataUpdateEventProto.perms)
  clear_has_perms();
  ::hadoop::hdfs::FsPermissionProto* temp = perms_;
  perms_ = NULL;
  return temp;
}
inline ::hadoop::hdfs::FsPermissionProto* MetadataUpdateEventProto::mutable_perms() {
  set_has_perms();
  if (perms_ == NULL) {
    auto* p = CreateMaybeMessage<::hadoop::hdfs::FsPermissionProto>(GetArenaNoVirtual());
    perms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.MetadataUpdateEventProto.perms)
  return perms_;
}
inline void MetadataUpdateEventProto::set_allocated_perms(::hadoop::hdfs::FsPermissionProto* perms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(perms_);
  }
  if (perms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      perms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, perms, submessage_arena);
    }
    set_has_perms();
  } else {
    clear_has_perms();
  }
  perms_ = perms;
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.MetadataUpdateEventProto.perms)
}

// repeated .hadoop.hdfs.AclEntryProto acls = 9;
inline int MetadataUpdateEventProto::acls_size() const {
  return acls_.size();
}
inline ::hadoop::hdfs::AclEntryProto* MetadataUpdateEventProto::mutable_acls(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.MetadataUpdateEventProto.acls)
  return acls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AclEntryProto >*
MetadataUpdateEventProto::mutable_acls() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.MetadataUpdateEventProto.acls)
  return &acls_;
}
inline const ::hadoop::hdfs::AclEntryProto& MetadataUpdateEventProto::acls(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.acls)
  return acls_.Get(index);
}
inline ::hadoop::hdfs::AclEntryProto* MetadataUpdateEventProto::add_acls() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.MetadataUpdateEventProto.acls)
  return acls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::AclEntryProto >&
MetadataUpdateEventProto::acls() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.MetadataUpdateEventProto.acls)
  return acls_;
}

// repeated .hadoop.hdfs.XAttrProto xAttrs = 10;
inline int MetadataUpdateEventProto::xattrs_size() const {
  return xattrs_.size();
}
inline ::hadoop::hdfs::XAttrProto* MetadataUpdateEventProto::mutable_xattrs(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.MetadataUpdateEventProto.xAttrs)
  return xattrs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::XAttrProto >*
MetadataUpdateEventProto::mutable_xattrs() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.MetadataUpdateEventProto.xAttrs)
  return &xattrs_;
}
inline const ::hadoop::hdfs::XAttrProto& MetadataUpdateEventProto::xattrs(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.xAttrs)
  return xattrs_.Get(index);
}
inline ::hadoop::hdfs::XAttrProto* MetadataUpdateEventProto::add_xattrs() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.MetadataUpdateEventProto.xAttrs)
  return xattrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::XAttrProto >&
MetadataUpdateEventProto::xattrs() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.MetadataUpdateEventProto.xAttrs)
  return xattrs_;
}

// optional bool xAttrsRemoved = 11;
inline bool MetadataUpdateEventProto::has_xattrsremoved() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MetadataUpdateEventProto::set_has_xattrsremoved() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MetadataUpdateEventProto::clear_has_xattrsremoved() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MetadataUpdateEventProto::clear_xattrsremoved() {
  xattrsremoved_ = false;
  clear_has_xattrsremoved();
}
inline bool MetadataUpdateEventProto::xattrsremoved() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.MetadataUpdateEventProto.xAttrsRemoved)
  return xattrsremoved_;
}
inline void MetadataUpdateEventProto::set_xattrsremoved(bool value) {
  set_has_xattrsremoved();
  xattrsremoved_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.MetadataUpdateEventProto.xAttrsRemoved)
}

// -------------------------------------------------------------------

// UnlinkEventProto

// required string path = 1;
inline bool UnlinkEventProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlinkEventProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlinkEventProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlinkEventProto::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& UnlinkEventProto::path() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.UnlinkEventProto.path)
  return path_.GetNoArena();
}
inline void UnlinkEventProto::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hadoop.hdfs.UnlinkEventProto.path)
}
#if LANG_CXX11
inline void UnlinkEventProto::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hadoop.hdfs.UnlinkEventProto.path)
}
#endif
inline void UnlinkEventProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hadoop.hdfs.UnlinkEventProto.path)
}
inline void UnlinkEventProto::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hadoop.hdfs.UnlinkEventProto.path)
}
inline ::std::string* UnlinkEventProto::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.UnlinkEventProto.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlinkEventProto::release_path() {
  // @@protoc_insertion_point(field_release:hadoop.hdfs.UnlinkEventProto.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlinkEventProto::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hadoop.hdfs.UnlinkEventProto.path)
}

// required int64 timestamp = 2;
inline bool UnlinkEventProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnlinkEventProto::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnlinkEventProto::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnlinkEventProto::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 UnlinkEventProto::timestamp() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.UnlinkEventProto.timestamp)
  return timestamp_;
}
inline void UnlinkEventProto::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.UnlinkEventProto.timestamp)
}

// -------------------------------------------------------------------

// EventsListProto

// repeated .hadoop.hdfs.EventProto events = 1;
inline int EventsListProto::events_size() const {
  return events_.size();
}
inline void EventsListProto::clear_events() {
  events_.Clear();
}
inline ::hadoop::hdfs::EventProto* EventsListProto::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.EventsListProto.events)
  return events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >*
EventsListProto::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.EventsListProto.events)
  return &events_;
}
inline const ::hadoop::hdfs::EventProto& EventsListProto::events(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventsListProto.events)
  return events_.Get(index);
}
inline ::hadoop::hdfs::EventProto* EventsListProto::add_events() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.EventsListProto.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventProto >&
EventsListProto::events() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.EventsListProto.events)
  return events_;
}

// required int64 firstTxid = 2;
inline bool EventsListProto::has_firsttxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventsListProto::set_has_firsttxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventsListProto::clear_has_firsttxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventsListProto::clear_firsttxid() {
  firsttxid_ = GOOGLE_LONGLONG(0);
  clear_has_firsttxid();
}
inline ::google::protobuf::int64 EventsListProto::firsttxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventsListProto.firstTxid)
  return firsttxid_;
}
inline void EventsListProto::set_firsttxid(::google::protobuf::int64 value) {
  set_has_firsttxid();
  firsttxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EventsListProto.firstTxid)
}

// required int64 lastTxid = 3;
inline bool EventsListProto::has_lasttxid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventsListProto::set_has_lasttxid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventsListProto::clear_has_lasttxid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventsListProto::clear_lasttxid() {
  lasttxid_ = GOOGLE_LONGLONG(0);
  clear_has_lasttxid();
}
inline ::google::protobuf::int64 EventsListProto::lasttxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventsListProto.lastTxid)
  return lasttxid_;
}
inline void EventsListProto::set_lasttxid(::google::protobuf::int64 value) {
  set_has_lasttxid();
  lasttxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EventsListProto.lastTxid)
}

// required int64 syncTxid = 4;
inline bool EventsListProto::has_synctxid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventsListProto::set_has_synctxid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventsListProto::clear_has_synctxid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventsListProto::clear_synctxid() {
  synctxid_ = GOOGLE_LONGLONG(0);
  clear_has_synctxid();
}
inline ::google::protobuf::int64 EventsListProto::synctxid() const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventsListProto.syncTxid)
  return synctxid_;
}
inline void EventsListProto::set_synctxid(::google::protobuf::int64 value) {
  set_has_synctxid();
  synctxid_ = value;
  // @@protoc_insertion_point(field_set:hadoop.hdfs.EventsListProto.syncTxid)
}

// repeated .hadoop.hdfs.EventBatchProto batch = 5;
inline int EventsListProto::batch_size() const {
  return batch_.size();
}
inline void EventsListProto::clear_batch() {
  batch_.Clear();
}
inline ::hadoop::hdfs::EventBatchProto* EventsListProto::mutable_batch(int index) {
  // @@protoc_insertion_point(field_mutable:hadoop.hdfs.EventsListProto.batch)
  return batch_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventBatchProto >*
EventsListProto::mutable_batch() {
  // @@protoc_insertion_point(field_mutable_list:hadoop.hdfs.EventsListProto.batch)
  return &batch_;
}
inline const ::hadoop::hdfs::EventBatchProto& EventsListProto::batch(int index) const {
  // @@protoc_insertion_point(field_get:hadoop.hdfs.EventsListProto.batch)
  return batch_.Get(index);
}
inline ::hadoop::hdfs::EventBatchProto* EventsListProto::add_batch() {
  // @@protoc_insertion_point(field_add:hadoop.hdfs.EventsListProto.batch)
  return batch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hadoop::hdfs::EventBatchProto >&
EventsListProto::batch() const {
  // @@protoc_insertion_point(field_list:hadoop.hdfs.EventsListProto.batch)
  return batch_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdfs
}  // namespace hadoop

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hadoop::hdfs::EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::hdfs::EventType>() {
  return ::hadoop::hdfs::EventType_descriptor();
}
template <> struct is_proto_enum< ::hadoop::hdfs::INodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::hdfs::INodeType>() {
  return ::hadoop::hdfs::INodeType_descriptor();
}
template <> struct is_proto_enum< ::hadoop::hdfs::MetadataUpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hadoop::hdfs::MetadataUpdateType>() {
  return ::hadoop::hdfs::MetadataUpdateType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_inotify_2eproto
